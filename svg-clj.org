* ;;
#+Title: svg-clj
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: excl
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:deps 
 {org.clojure/clojure       {:mvn/version "1.10.1"}
  org.clojure/clojurescript {:mvn/version "1.10.597"}
  org.clojure/spec.alpha    {:mvn/version "0.2.187"}
  org.clojure/test.check    {:mvn/version "1.1.0"}
  org.clojure/data.xml      {:mvn/version "0.0.8"}
  hawk/hawk                 {:mvn/version "0.2.11"}
  hiccup/hiccup             {:mvn/version "2.0.0-alpha2"}}}
#+end_src

** readme
#+BEGIN_SRC markdown :tangle ./readme.md
# svg-clj

A helper library for creating SVGs in Clojure/Clojurescript.

You can play around with the library [here](https://adam-james-v.github.io/dev/svg-clj/)

This is currently a work in progress. Until a stable release is provided, this library is considered to be in a 'prototype' state. Breaking changes are possible until a proper release is achieved.

![An SVG Image of Circles Spiralling, shrinking, and fading towards the image center.](https://github.com/adam-james-v/svg-clj/blob/main/examples/circles.svg "Circles")

These circles are produced by the following code:

```clj
(ns example
  (:require [svg-clj.main :as svg]
            [svg-clj.transforms :refer [rotate-pt]]
            [hiccup.core :refer [html]]))

(def circles
  (svg/svg
   [200 200 1]
   (->>
    (svg/g 
      (for [a (range 0 12)]
        (->> (svg/circle (+ 5 (* a 4)))
             (svg/translate [(/ (+ 5 (* a 4)) 2) 0])
             (svg/translate (rotate-pt (* a -40) [20 0]))
             (svg/style 
               {:stroke (str "rgba(163,190,140," (/ (inc a) 10.0) ")")
                :stroke-width "2px"
                :fill "none"}))))
    (svg/translate [100 100]))))

;; use hiccup or your favourite hiccup compiler.
;; the SVG library works in reagent as well.
(html circles)
```

### Deps.edn

```clj
svg-clj/svg-clj {:git/url "https://github.com/adam-james-v/svg-clj"
                 :sha "grab-latest-sha"}}
```


If you would like to understand my motivations, decisions, and reasoning for the choices I've made in this library, you can read the .org file in the top level of this repo.

[svg-clj.org](https://github.com/adam-james-v/svg-clj/blob/main/svg-clj.org). I attempt to do literate programming in my org files, but I have a scattered approach, so please be patient if you're reading the notes; they may not always make sense. Proper documentation is, naturally, a key element in bringing this project from prototype to release.

## Other Work

[Dali](https://github.com/stathissideris/dali) is a library by Stathis Sideris that also works with SVG. Since I have only recently heard about this library, I have not yet had time to do a detailed comparison but, at a glance, some differences I see are:

|                    svg-clj                   |                       dali                      |
|:--------------------------------------------:|:-----------------------------------------------:|
| users write functions which emit hiccup data | users write hiccup data directly                |
| no layout engine                             | layout engine                                   |
| no built-in rasterization                    | rasterize SVGs using Batik                      |
| Clojure and Clojurescript                    | Clojure only                                    |
| SVG primitives only (for now)                | SVG primitives + 'prefabs' (eg. markers/arrows) |

Stay tuned for updates!

#+END_SRC

* admin
** todo
Some tasks that need to be done on this project.
*** DONE remove forge dependency
*** TODO fix svg fn to properly handle incorrect args (eg. missing [w h sc]
*** TODO build a mechanism for changing rotate behavior from local to global -> probably use *dynamic-var* 
*** TODO build a mechanism for changing transform 'baking' behavior
*** TODO make centroid only work on sets of pts of same dimension
*** TODO make centroid more readable. Maybe juxt?s
*** TODO fix in utils -- str->xf-map, and related fns.
*** TODO re-implement scale transform. incomplete as is.
*** TODO for circle and ellipse, try to remove the transform rotate(0 x y) idea. Seems confusing and unnecessary anyway.
*** TODO org-mode auto-comlpete in code blocks... look up 'indiret buffer'
** roadmap
Some features that are planned for implementation.

*** candidate-features
Should I add these to the svg-clj library? Or should they be some different library?

I think these make more sense in separate libraries. Perhaps as ns inside a 2d-cad-drawing lib or something along those lines. 

- math helpers
  - to-deg
  - to-rad
  - vector arithemetic helpers v* v+ v-
- drawing features  
  - regular-polygon-pts  
  - offset
- 'composite' shapes and containers
  - arrows
  - dimensions
  - figure containers
  - 

** misc-notes
Remember in REPL you can't re-def the defmulti dispatch function with some ns magic.

https://clojuredocs.org/clojure.core/defmulti#example-55d9e498e4b0831e02cddf1b

#+begin_src clojure
(defmulti x (fn[_] :dec)) ;; Can't redefine :(
(x 0) ;; => 1 ;; STILL :(
(ns-unmap *ns* 'x) ;; => unmap the var from the namespace

#+end_src


Maikerusan suggests:

A mechanism for setting up global defaults when a user has loaded the library.
Config would control:
 - all shapes centering behaviour (eg. center at centroid, corner, whatever)

 - whether translate/rotate are 'baked' or not.
   - 'baked' is the default and means you technically lose information when compiling to SVG (eg you cannot tell that a line was translated if the coords have the translate baked in)

* design
** intent
The purpose of this library is to allow users to create simple functional programs that compile to SVG elements. 

The expected kinds of input are .clj files with svg-clj code, STDIN with svg-clj code. The expected output is hiccup-style clojure data structures, and optionally a compiled SVG string to file or STDOUT.

Basically, this is just a library, but I will add a small CLI interface and create a binary distribution so that the library can stand alone as a small utility, perhaps as a useful tool in a bash scripting pipeline.

** structure
The library uses hiccup syntax to represent the SVG diagrams being created. The user writes functional code to define various elements of the SVG and has access to transformations via utility functions.

Since the library functions emit hiccup data structures, the user can extend and manipulate their data using other clojure libraries or their own approaches. 

The library has two 'groups' of functions:

- elements
  - container elements (svg, figure...)
  - composites (custom functions using shapes.. eg. arrow)
  - shapes
    - circle
    - ellipse
    - line
    - path
    - polygon
    - polyline
    - rect
  - text
  - g
  - animation (maybe in future)

- transforms
  - rotate
  - translate
  - scale
  - style

There are utility type functions as well
- geometric utilities (centroid, bounds)
- data manipulation utilities

** opinionated-approach
This is not quite a straight wrapper for SVG functionality. I have altered the default behavior of some functions.

For example, a rectangle is drawn centered around the orgin by default. Plain SVG rectangles draw with the first corner located at the origin by default.

All rotations are applied to shapes locally by default. This means that a circle at [10 0] rotated by 90 deg will not appear to move using svg-clj; the shape itself is being spun around it's center, but that center point is not moving. Default SVG behaviour rotates around the origin by default. So, any elements offset from the orgin will move large distances away from their starting positions. 

This choice was made because it feels more intuitive (to me, at least) to draw with local transformation operations in mind.

As much as possible, all transformation calculations are 'baked' into shape coordinates and points directly. This means that a [10 20] rectangle that gets translated by [100 100] will be rendered to SVG as follows:

#+begin_src clojure
(comment 
  (translate [100 100] (rect 10 20))
  ;; => [:rect {:width 10, :height 20, :x 95.0, :y 90.0, :transform "rotate(0 100.0 100.0)"}]
  (def a *1)
  (html a)
  ;; => "<rect height=\"20\" transform=\"rotate(0 100.0 100.0)\" width=\"10\" x=\"95.0\" y=\"90.0\"></rect>"
)
#+end_src

* utils
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(ns svg-clj.utils
  (:require [clojure.string :as st]
            #?(:cljs
               [cljs.reader :refer [read-string]])))

;; vector arithmetic helpers
(def v+ (partial mapv +))
(def v- (partial mapv -))
(def v* (partial mapv *))

;; simple calcs
(defn to-deg
  [rad]
  (* rad (/ 180 Math/PI)))

(defn to-rad
  [deg]
  (* deg (/ Math/PI 180)))

(defn round
  [num places]
  (let [d (Math/pow 10 places)]
    (/ (Math/round (* num d)) d)))

(defn average
  [& numbers]
  (let [n (count numbers)]
    (/ (apply + numbers) n)))

;; some string transformation tools
(defn v->s
  "Turns the vector `v` into a string formatted for use in SVG attributes."
  [v]
  (apply str (interpose "," v)))

(defn s->v
  "Turns a string of comma or space separated numbers into a vector."
  [s]
  (-> s
      (st/trim)
      (st/split #"[, ]")
      (#(filter (complement empty?) %))
      (#(mapv read-string %))))

(defn xf-kv->str
  [[k v]]
  (str (symbol k) (apply list v)))

(defn str->xf-kv
  [s]
  (let [split (st/split s #"\(")
        key (keyword (first split))
        val (vec (read-string (str "(" (second split))))]
    [key val]))

(defn xf-map->str
  [m]
  (apply str (interpose "\n" (map xf-kv->str m))))

(defn str->xf-map
  [s]
  (if-let [s s]
    (into {} (map str->xf-kv (st/split-lines s)))
    {}))

;; geom
(defn distance
  "compute distance between two points"
  [a b]
  (let [v (v- b a)
        v2 (reduce + (v* v v))]
    (Math/sqrt v2)))

(defn move-pt
  [mv pt]
  (v+ pt mv))

(defn rotate-pt
  [deg [x y]]
  (let [c (Math/cos (to-rad deg))
        s (Math/sin (to-rad deg))]
    [(- (* x c) (* y s))
     (+ (* x s) (* y c))]))

(defn rotate-pt-around-center
  [deg center pt]
  (->> pt
       (move-pt (map - center))
       (rotate-pt deg)
       (move-pt center)))

(defn dot*
  "calculates the dot product of two vectors"
  [a b]
  (reduce + (map * a b)))
;; https://math.stackexchange.com/questions/361412/finding-the-angle-between-three-points
(defn angle-from-pts
  [p1 p2 p3]
  (let [v1 (v- p2 p1)
        v2 (v- p2 p3)
        l1 (distance p1 p2)
        l2 (distance p3 p2)
        n (dot* v1 v2)
        d (Math/abs (* l1 l2))]
    (when (not (= 0.0 (float d)))
      (to-deg (Math/acos (/ n d))))))
#+end_src

* specs-preds
#+begin_src clojure :tangle ./src/svg_clj/specs.cljc
(ns svg-clj.specs
  (:require [clojure.string :as st]
            [clojure.spec.alpha :as s]))
            
(s/def ::pt2d (s/tuple number? number?))
(s/def ::pts (s/coll-of ::pt2d))

(def svg-element-keys
  "SVG elements provided by the library."
  #{:circle
    :ellipse
    :line
    :path
    :polygon
    :polyline
    :rect
    :text
    :image
    :g})

(s/def ::basic-element
  (s/cat :tag svg-element-keys
         :props map?))

(s/def ::text-element
  (s/cat :tag #{:text}
         :props map?
         :content string?))

(s/def ::g-element
  (s/cat :tag #{:g}
         :props map?
         :content (s/* ::svg-element)))

(s/def ::svg-element
  (s/or :basic (s/spec ::basic-element)
        :text (s/spec ::text-element)
        :group (s/spec ::g-element)))

(s/def ::path-element
  (s/cat :tag #{:path}
         :props (s/keys :req-un [::d]) 
         :content (s/* ::svg-element)))

#_(s/def ::groupable
  (s/or :flat (s/every ::svg-element)
        :nested (s/coll-of (s/every ::svg-element))))

(defn pt2d? [a] (s/valid? ::pt2d a))
(defn pts? [s] (s/valid? ::pts s))

(defn element?
  "Checks if `elem` is an SVG element."
  [elem]
  (s/valid? ::svg-element elem))

(defn path-string-allowed? 
  [string] 
  (empty? (st/replace string #"[MmZzLlHhVvCcSsQqTtAaeE0-9-,.\s]" "")))

(defn path-string-valid-syntax?
  [string]
  (nil? (re-find #"[a-zA-Z][a-zA-Z]" string)))

(defn path-string-valid-start?
  [string]
  (nil? (re-find #"^[0-9-,.]" string)))

(defn path-string-valid-end?
  [string]
  (nil? (re-find #".*[-,.]$" string)))

(defn path-string-single-command?
  [string]
  (= 1 (count (re-seq #"[A-DF-Za-df-z]" string))))

(s/def ::path-string
  (s/and string?
         (complement empty?)
         path-string-allowed?
         path-string-valid-syntax?
         path-string-valid-start?
         path-string-valid-end?
         (complement path-string-single-command?)))

(s/def ::command-string
  (s/and string?
         (complement empty?)
         path-string-allowed?
         path-string-valid-syntax?
         path-string-valid-start?
         path-string-valid-end?
         path-string-single-command?))

(def commands #{"M" "L" "H" "V" "C" "S" "Q" "T" "A" "Z"})
(s/def ::command commands)
(s/def ::coordsys #{:rel :abs})
(s/def ::input (s/or :data (s/+ number?)
                     :nil nil?))
(s/def ::command-map
  (s/keys :req-un [::command ::coordsys ::input]))

(defn any-vh?
  [cmds]
  {:pre [(s/valid? (s/coll-of ::command-map) cmds)]}
  (not (empty? (filter #{:vline :hline} (map :command cmds)))))

(s/def ::bounds
  (s/tuple ::pt2d ::pt2d ::pt2d ::pt2d))
#+end_src

* path-dsl
The path element has a small DSL to create compound curves. This includes the following (taken from [[https://www.w3schools.com/graphics/svg_path.asp]]):

 M = moveto
 L = lineto
 H = horizontal lineto
 V = vertical lineto
 C = curveto
 S = smooth curveto
 Q = quadratic Bézier curve
 T = smooth quadratic Bézier curveto
 A = elliptical Arc
 Z = closepath

** ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(ns svg-clj.path
  (:require [clojure.string :as st]
            [clojure.spec.alpha :as s]
            [svg-clj.utils :as utils]
            [svg-clj.specs :as specs]))
#+END_SRC

** path
*** path
This path function is usable by the user but provides no path generation assistance. There are several functions defined later that handle path generation.

#+begin_src clojure :tangle ./src/svg_clj/path.cljc
(defn path
  "Wraps a path string `d` in a hiccup-style data structure.
  The path string is minimally evaluated and is otherwise untouched. Users should consider the function `polygon-path` for constructing paths from points. More complex paths can be built by combining paths with the function `merge-paths`"
  [d]
  [:path {:d d
          :fill-rule "evenodd"}])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef path
   :args (s/cat :d ::path-string)
   :ret ::path-element)
 #+end_src

** commands
Path strings are a sequence of commands. These commands can be thought of as moving a pen along the canvas to draw shapes/lines according to the command's inputs.

The order of these commands must be maintained, otherwise the shape will be drawn differently.

I'm going to make a few functions to split paths into commands and put them in a clojure map.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- path-command-strings
  "Split the path string `ps` into a vector of path command strings."
  [ps]
  (-> ps
      (st/replace #"\n" " ")
      (st/split #"(?=[A-DF-Za-df-z])")
      (#(map st/trim %))
      (#(filter (complement empty?) %))))

(defn- relative?
  "True if the path command string `cs` has a relative coordinate command.
  Relative coordinate commands are lowercase.
  Absolute coordinate commands are uppercase."
  [cs]
  {:pre [(s/valid? :svg-clj.specs/command-string cs)]}
  (let [csx (first (st/split cs #"[a-z]"))]
    (not (= cs csx))))

(defn- coord-sys-key
  "Returns the command string `cs`'s coord. system key.
  Key is either :rel or :abs."
  [cs]
  (if (relative? cs) :rel :abs))

(defn- command-input
  [cs]
  (let [i (st/split cs #"[A-DF-Za-df-z]")]
    (when (not (empty? (rest i)))
      (apply utils/s->v (rest i)))))

(defn- command
  "Transforms a command string `cs` into a map."
  [cs]
  {:command  (st/upper-case (re-find #"[A-DF-Za-df-z]" cs))
   :coordsys (coord-sys-key cs)
   :input (command-input cs)})

(defn- merge-cursor
  [[pcmd ccmd]]
  (let [cursor (vec (take-last 2 (:input pcmd)))]
    (assoc ccmd :cursor cursor)))

(defn path-string->commands
  "Turns path string `ps` into a list of its command maps."
  [ps]
  (->> ps
       path-command-strings
       (map command)
       (concat [{:command "M"
                 :coordsys :abs
                 :input [0 0]}])
       (partition 2 1)
       (map merge-cursor)))
#+END_SRC

*** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef path-command-strings
  :args (s/cat :path-string ::path-string)
  :ret (s/coll-of ::command-string))

(s/fdef command
  :args (s/cat :command-string ::command-string)
  :ret ::command-map)

(s/fdef path-string->commands
  :args (s/cat :path-string ::path-string)
  :ret (s/coll-of ::command-map))
#+END_SRC

** converting-vh
Given a list of commands, go until you find a V or H with a NON V NON H command preceding it.
Use the previous command to get the missing X or Y value
Create an equivalent L command using the recovered coord. and the V or H coord.
Recreate the sequence having swapped the V or H with the new L command.
Repeat this process over the whole sequence.
If the entire sequence has NO V or H, done.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- convert-vh
  [[pcmd ccmd]]
  (if (and (not (specs/any-vh? [pcmd])) ;;prev. cmd must NOT be VH
           (specs/any-vh? [ccmd])) ;; curr. cmd must be VH
    (let [[px py] (take-last 2 (:input pcmd))
          vh (:command ccmd)
          xinput (cond (= vh :hline) [(first (:input ccmd)) py]
                       (= vh :vline) [px (first (:input ccmd))])
          ncmd (-> ccmd
                   (assoc :command :line)
                   (assoc :input xinput))]
      [pcmd ncmd])
    [pcmd ccmd]))

(defn- convert-first-vh-cmd
  [cmds]
  (let [icmd (first cmds)]
    (cons icmd 
          (->> cmds
               (partition 2 1)
               (map convert-vh)
               (map second)))))

(defn- vh->l
  [cmds]
  (let [iters (iterate convert-first-vh-cmd cmds)]
    (->> iters
         (partition 2 1)
         (take-while (fn [[a b]] (not= a b)))
         last
         last)))
#+END_SRC

*** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef vh->l
  :argrs (s/cat :commands (s/coll-of ::command-map))
  :ret (complement any-vh?))
#+END_SRC

** build-path-strings
Given a sequence of command maps, produce a path string.

Then, we can losely consider a sequence of command maps to be the internal data structure for path manipulation. This means you can create multi-path path strings by passing a sequence of sequences of command maps.

For each cmd seq., convert to path-string, then apply string to concatenate these path strings into the final string. You can alternatively treat each path string as the attribute for a new path element and draw them separately.

The requirement is that if a user puts a path string into the system but does not transform it in any way, they should expect an equivalent string to be emitted from the cmds->str fn.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- cmd->path-string
  [{:keys [:command :coordsys :input] :as cmd}]
  (let [c (if (= coordsys :abs)
            command
            (st/lower-case command))]
    (str c (apply str (interpose " " input)))))

(defn cmds->path-string
  [cmds]
  (apply str (interpose " " (map cmd->path-string cmds))))
#+END_SRC

** merge-paths
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn merge-paths
  "Merges a list of path elements together, keeping props from last path in the list."
  [& paths]
  (let [props (second (last paths))
        d (apply str (interpose " " (map #(get-in % [1 :d]) paths)))]
    [:path (assoc props :d d)]))
#+END_SRC

*** spec
#+begin_src clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef merge-paths
  :args (s/cat :paths (s/coll-of ::path-element))
  :ret ::path-element)
#+END_SRC

** partial-commands
The polygon-path function is a way to create valid path strings from a set of points. The idea is that any call to the polygon fn can be replaced with polygon-path and no visual difference would occur.

Then, paths can be further manipulated by combine and merge.

Convert list of pts into list of commands.
 - first command will be a MOVE command
 - last command will be a CLOSE command
   - can generalize this to polyline by having a close? flag

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- pt->l
  [pt]
  {:command "L"
   :coordsys :abs
   :input (vec pt)})

(defn- pt->m
  [pt]
  {:command "M"
   :coordsys :abs
   :input (vec pt)})
#+END_SRC

** polygons-polylines
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn line-path
  [a b]
  (-> [(pt->m a) (pt->l b)]
      cmds->path-string
      path))

(defn polygon-path
  [pts]
  (let [open (pt->m (first pts))
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> (map pt->l (rest pts))
        (conj open)
        vec
        (conj close)
        cmds->path-string
        path)))

(defn polyline-path
  [pts]
  (let [open (pt->m (first pts))]
    (-> (map pt->l (rest pts))
        (conj open)
        vec
        cmds->path-string
        path)))

(defn rect-path
  [w h]
  (let [w2 (/ w 2.0)
        h2 (/ h 2.0)]
    (polygon-path [ [(- w2) (- h2)] [w2 (- h2)] 
                    [w2 h2]         [(- w2) h2] ])))
#+END_SRC

** bezier
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- partial-bezier
  ([a]
   (-> {:command "T"
        :coordsys :abs
        :input (vec a)}
       cmd->path-string))

  ([a b]
   (-> {:command "S"
        :coordsys :abs
        :input (concat a b)}
       cmd->path-string)))

(defn bezier
  ([a b c]
   (let [open (pt->m a)]
     (-> {:command "Q"
          :coordsys :abs
          :input (concat b c)}
         list
         (conj open)
         vec
         cmds->path-string
         path)))

  ([a b c d]
   (let [open (pt->m a)]
     (-> {:command "C"
          :coordsys :abs
          :input (concat b c d)}
         list
         (conj open)
         vec
         cmds->path-string
         path))))
#+END_SRC

** arc
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- partial-arc
  [rx ry rot laf sw a]
  (let [open (pt->m a)]
    (-> {:command "A"
         :coordsys :abs
         :input (concat [rx ry rot laf sw] a)}
        cmd->path-string)))

(defn- build-arc
  [rx ry rot laf sw a b]
  (let [open (pt->m a)]
    (-> {:command "A"
         :coordsys :abs
         :input (concat [rx ry rot laf sw] b)}
        list
        (conj open)
        vec
        cmds->path-string
        path)))

(defn arc
  [a ctr deg]
  (let [r (utils/distance a ctr)
        angle 0
        b (utils/rotate-pt-around-center deg ctr a)
        laf (if (<= deg 180) 0 1)]
     (build-arc r r angle laf 1 a b)))

(defn circle-path
  [r]
  (let [open (pt->m [r 0])
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> [open
         {:command "A"
          :coordsys :abs
          :input [r r 0 1 0 (- r) 0]}
         {:command "A"
          :coordsys :abs
          :input [r r 0 1 0 r 0]}
         close]
        cmds->path-string
        path)))

(defn ellipse-path
  [rx ry]
  (let [open (pt->m [rx 0])
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> [open
         {:command "A"
          :coordsys :abs
          :input [rx ry 0 1 0 (- rx) 0]}
         {:command "A"
          :coordsys :abs
          :input [rx ry 0 1 0 rx 0]}
         close]
        cmds->path-string
        path)))

#+END_SRC

*** spec
#+begin_src clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef polygon-path
  :args (s/cat :pts ::pts)
  :ret ::path-element)
#+END_SRC
* transforms-computations
Computations refer to calculatable properties of svg elements. They are bounds and centroid.

Transforms are translate, rotate, and scale. All transforms work well for most objects (:g and :text are exceptions). They all transform about the object's center point. This has the effect of 'local first' transformation.

This leads to challenges with groups. Groups must have their centroid calculated such that rotation and translation can correctly occur about the group's centroid. Internally, this means that the group's centroid is treated as the 'temporary global origin' and all objects are globally rotated about that temp. origin. This has the appearance of a group rotating locally, which is the intended outcome.

** ns
#+begin_src clojure :tangle ./src/svg_clj/transforms.cljc
(ns svg-clj.transforms
   (:require [clojure.string :as st]
             [clojure.spec.alpha :as s]
             [svg-clj.specs :as specs]
             [svg-clj.utils :as utils :refer [move-pt
                                              rotate-pt
                                              rotate-pt-around-center]]
             [svg-clj.path :as path]))
#+end_src

** calcs
For transforms, it is necessary to extract basic point data from commands. In general, all commands have simple point data. The exception is arcs, which need some calculation.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti command->pts :command)

(defmethod command->pts :default
  [{:keys [input]}]
  (mapv vec (partition 2 input)))

;; this is not implemented correctly yet.
;; just a 'stub' returning the end point of the arc
(defmethod command->pts "A"
  [{:keys [input cursor]}]
  (let [[rx ry deg laf sw x y] input
        b [x y]
        #_ctr #_[(- x (* (Math/cos (utils/to-rad deg)) rx))
             (- y (* (Math/sin (utils/to-rad deg)) rx))]
        ctr (utils/v+ cursor [rx 0])
        sa (utils/angle-from-pts cursor ctr b)
        angle (if (= 1 laf) (- 360 sa) sa)
        mids (mapv #(rotate-pt-around-center % ctr cursor) (rest (range 0 angle 90)))]
    (conj mids b)))
#+END_SRC

** centroid
*** centroid-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn centroid-of-pts
  "Calculates the arithmetic mean position of all the given `pts`."
  [pts]
  (let [ndim (count (first (sort-by count pts)))
        splits (for [axis (range 0 ndim)]
                 (map #(nth % axis) pts))]
    (mapv #(apply utils/average %) splits)))

(defmulti centroid-element
  (fn [element]
    (first element)))

(defmethod centroid-element :circle
  [[_ props]]
  [(:cx props) (:cy props)])  

(defmethod centroid-element :ellipse
  [[_ props]]
  [(:cx props) (:cy props)])

(defmethod centroid-element :line
  [[_ props]]
  (let [a (mapv #(get props %) [:x1 :y1])
        b (mapv #(get props %) [:x2 :y2])]
    (centroid-of-pts [a b])))

(defmethod centroid-element :polygon
  [[_ props]]
  (let [pts (mapv utils/s->v (st/split (:points props) #" "))]
    (centroid-of-pts pts)))

(defmethod centroid-element :polyline
  [[_ props]]
  (let [pts (mapv utils/s->v (st/split (:points props) #" "))]
    (centroid-of-pts pts)))

(defmethod centroid-element :rect
  [[_ props]]
  [(+ (:x props) (/ (:width  props) 2.0))
   (+ (:y props) (/ (:height props) 2.0))])

(defmethod centroid-element :image
  [[_ props]]
  [(+ (:x props) (/ (:width  props) 2.0))
   (+ (:y props) (/ (:height props) 2.0))])

;; this is not done yet. Text in general needs a redo.
(defmethod centroid-element :text
  [[_ props text]]
  [(:x props) (:y props)])
#+END_SRC

**** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef centroid-of-pts
  :args (s/cat :pts ::pts)
  :ret ::pt2d)
#+END_SRC

*** centroid-element-path
The first idea for calculating path centroid is to get all point data from every command, mapcat them together, and just run centroid-of-pts on that list of points.

I don't know yet if the 'easy' method will be accurate for paths that contain curves and arcs. It is possible that the centroid calculated by pts/control points is not accurate.

Ideas to keep in mind:
- parametric bezier curve, sample t and regular interval to build a polyline approximating the curve, and calculate centroid from those pts
- tessellate the whole path and get centroids of every triangle, then centroid of centroids... should be ok

#+begin_src clojure :tangle ./src/svg_clj/transforms.cljc
(defmethod centroid-element :path
  [[_ props]]
  (let [cmds (path/path-string->commands (:d props))
        pts (mapcat command->pts cmds)]
    (centroid-of-pts (vec (into #{} pts)))))
#+end_src

*** group-centroid
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(declare centroid)
(defmethod centroid-element :g
  [[_ props & content]]
  (centroid-of-pts (into #{} (map centroid content))))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn centroid
  "Calculates the arithmetic mean position of all points of all given `elems`."
  [& elems]
  (if (and (= 1 (count elems))
           (not (keyword? (first (first elems)))))
    ;; content is a list of a list of elements
    (recur (first elems))
    ;; content is a single element OR a list of elements
    (centroid-of-pts (mapv centroid-element elems))))
#+END_SRC

**** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef centroid
  :args (s/or :one (s/coll-of ::svg-element)
              :many (s/coll-of (s/+ ::svg-element)))
  :ret ::pt2d)
#+END_SRC
** bounds
*** bounds-fn
#+begin_src clojure :results none :tangle ./src/svg_clj/transforms.cljc
(defn pts->bounds
  [pts]
  (let [xmax (apply max (map first pts))
        ymax (apply max (map second pts))
        xmin (apply min (map first pts))
        ymin (apply min (map second pts))]
    (vector [xmin ymin]
            [xmax ymin]
            [xmax ymax]
            [xmin ymax])))
#+end_src

*** bounds-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti bounds-element
  (fn [element]
    (first element)))

(defmethod bounds-element :circle
  [[_ props]]
  (let [c [(:cx props) (:cy props)]
        r (:r props)
        pts (mapv #(utils/v+ c %) [[r 0]
                             [0 r]
                             [(- r) 0]
                             [0 (- r)]])]
    (pts->bounds pts)))

(defmethod bounds-element :ellipse
  [[_ props]]
  (let [xf (utils/str->xf-map  (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        c [(:cx props) (:cy props)]
        rx (:rx props)
        ry (:ry props)
        pts (mapv #(utils/v+ c %) [[rx 0]
                             [0 ry] 
                             [(- rx) 0]
                             [0 (- ry)]])
        bb (pts->bounds pts)
        obb (mapv #(rotate-pt-around-center deg [mx my] %) bb)
        xpts (mapv #(rotate-pt-around-center deg [mx my] %) pts)
        small-bb (pts->bounds xpts)
        large-bb (pts->bounds obb)]
    ;; not accurate, but good enough for now
    ;; take the bb to be the average between the small and large
    (pts->bounds (mapv #(centroid-of-pts [%1 %2]) small-bb large-bb))))

(defmethod bounds-element :line
  [[_ props]]
  (let [a (mapv #(get props %) [:x1 :y1])
        b (mapv #(get props %) [:x2 :y2])]
    (pts->bounds [a b])))

(defmethod bounds-element :polygon
  [[_ props]]
  (let [pts (mapv utils/s->v (st/split (:points props) #" "))]
    (pts->bounds pts)))

(defmethod bounds-element :polyline
  [[_ props]]
  (let [pts (mapv utils/s->v (st/split (:points props) #" "))]
    (pts->bounds pts)))

(defmethod bounds-element :rect
  [[_ props]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        x (:x props)
        y (:y props)
        w (:width props)
        h (:height props)
        pts [[x y]
             [(+ x w) y]
             [(+ x w) (+ y h)]
             [x (+ y h)]]
        xpts (mapv #(rotate-pt-around-center deg [mx my] %) pts)]
    (pts->bounds xpts)))

(defmethod bounds-element :image
  [[_ props]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        x (:x props)
        y (:y props)
        w (:width props)
        h (:height props)
        pts [[x y]
             [(+ x w) y]
             [(+ x w) (+ y h)]
             [x (+ y h)]]
        xpts (mapv #(rotate-pt-around-center deg [mx my] %) pts)]
    (pts->bounds xpts)))

;; this is not done yet. Text in general needs a redo.
(defmethod bounds-element :text
  [[_ props text]]
  [[(:x props) (:y props)]])

#+END_SRC

*** bounds-element-path
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmethod bounds-element :path
  [[_ props]]
  (let [cmds (path/path-string->commands (:d props))
        pts (mapcat command->pts cmds)]
    (pts->bounds pts)))

#+END_SRC

*** group-bounds
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(declare bounds)
(defmethod bounds-element :g
  [[_ props & content]]
  (pts->bounds (apply concat (map bounds content))))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn bounds
  "Calculates the axis-aligned bounding box of `elems`.
  The returned bounding box is a list of four points:
  [Bottom Left, Bottom Right, Top Right, Top Left]."
  [& elems]
  (if (and (= 1 (count elems))
           (not (keyword? (first (first elems)))))
    ;; content is a list of a list of elements
    (recur (first elems))
    ;; content is a single element OR a list of elements
    (pts->bounds (mapcat bounds-element elems))))
#+END_SRC

**** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef bounds
  :args (s/cat :elems (s/coll-of ::svg-element))
  :ret ::bounds)
#+END_SRC
** translate
*** translate-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti translate-element 
  (fn [_ element]
    (first element)))

(defmethod translate-element :circle
  [[x y] [k props]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate-element :ellipse
  [[x y] [k props]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate-element :line
  [[x y] [k props]]
  (let [new-props (-> props
                      (update :x1 + x)
                      (update :y1 + y)
                      (update :x2 + x)
                      (update :y2 + y))]
    [k new-props]))

(defmethod translate-element :polygon
  [[x y] [k props]]
  (let [pts (mapv utils/s->v (st/split (:points props) #" "))
        xpts (->> pts 
                  (map (partial utils/v+ [x y]))
                  (map utils/v->s))]
    [k (assoc props :points (apply str (interpose " " xpts)))]))

(defmethod translate-element :polyline
  [[x y] [k props]]
  (let [pts (mapv utils/s->v (st/split (:points props) #" "))
        xpts (->> pts 
                  (map (partial utils/v+ [x y]))
                  (map utils/v->s))]
    [k (assoc props :points (apply str (interpose " " xpts)))]))

(defmethod translate-element :rect
  [[x y] [k props]]
  (let [[cx cy] (centroid [k props])
        xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ cx x))
                   (assoc-in [:rotate 2] (+ cy y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate-element :image
  [[x y] [k props]]
  (let [[cx cy] (centroid [k props])
        xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ cx x))
                   (assoc-in [:rotate 2] (+ cy y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate-element :text
  [[x y] [k props text]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 1] + x)
                   (update-in [:rotate 2] + y))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props text]))

#+END_SRC

*** translate-element-path
To complete the translate implementation, I have to make sure path elements can be propery handled.

To do this, I have a second multimethod to handle different commands that can show up in a path string. Command data structures are produced using the path-dsl functions defined earlier.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti translate-path-command
  (fn [_ m]
    (:command m)))

(defmethod translate-path-command "M"
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (utils/v+ [x y] input)))

(defmethod translate-path-command "L"
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (utils/v+ [x y] input)))

(defmethod translate-path-command "H"
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (utils/v+ [x] input)))

(defmethod translate-path-command "V"
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (utils/v+ [y] input)))

;; x y x y x y because input will ahve the form:
;; [x1 y1 x2 y2 x y] (first two pairs are control points)
(defmethod translate-path-command "C"
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (utils/v+ [x y x y x y] input)))

;; similar approach to above, but one control point is implicit
(defmethod translate-path-command "S"
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (utils/v+ [x y x y] input)))

(defmethod translate-path-command "Q"
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (utils/v+ [x y x y] input)))

(defmethod translate-path-command "T"
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (utils/v+ [x y] input)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod translate-path-command "A"
  [[x y] {:keys [:input] :as m}]
  (let [[rx ry xrot laf swf ox oy] input]
    (assoc m :input [rx ry xrot laf swf (+ x ox) (+ y oy)])))

(defmethod translate-path-command "Z"
  [_ cmd]
  cmd)

(defmethod translate-path-command :default
  [a cmd]
  [a cmd])

(defmethod translate-element :path
  [[x y] [k props]]
  (let [cmds (path/path-string->commands (:d props))
        xcmds (map #(translate-path-command [x y] %) cmds)]
    [k (assoc props :d (path/cmds->path-string xcmds))]))

#+END_SRC

*** group-translate
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(declare translate)
(defmethod translate-element :g
  [[x y] [k props & content]]
  (->> content
       (map (partial translate [x y]))
       (filter (complement nil?))
       (into [k props])))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn translate
  "Translates the `elems` by `x` and `y` relative to the element(s)'s current position(s).

  For example, a shape sitting at [10 10] being translated by [10 10] will be located at [20 20] after translation."
  [[x y] & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (specs/element? elem) (= 0 (count elems)))
        (translate-element [x y] elem)
        
        (and (specs/element? elem) (< 0 (count elems)))
        (concat
         [(translate-element [x y] elem)]
         [(translate [x y] elems)])
      
        :else
        (recur [x y] (concat elem elems))))))

#+END_SRC
** rotate
*** rotate-element
Rotate-element-by-transform leaves 'nil' for content. I filtered that out, but I suspect there's a cleaner way to do it.

Consider refactor at some point.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn rotate-element-by-transform
  [deg [k props content]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 0] + deg))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    (vec (filter (complement nil?) [k new-props (when content content)]))))

(defmulti rotate-element
  (fn [_ element]
    (first element)))

(defmethod rotate-element :circle
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defmethod rotate-element :ellipse
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defmethod rotate-element :line
  [deg [k props]] 
  (let [pts [[(:x1 props) (:y1 props)] [(:x2 props) (:y2 props)]]
        [[x1 y1] [x2 y2]]  (->> pts
                                (map #(utils/v- % (centroid-of-pts pts)))
                                (map #(rotate-pt deg %))
                                (map #(utils/v+ % (centroid-of-pts pts))))
        new-props (assoc props :x1 x1 :y1 y1 :x2 x2 :y2 y2)]
    [k new-props]))

(defmethod rotate-element :polygon
  [deg [k props]]
  (let [ctr (centroid [k props])
        pts (mapv utils/s->v (st/split (:points props) #" "))
        xpts (->> pts
                  (map #(utils/v- % ctr))
                  (map #(rotate-pt deg %))
                  (map #(utils/v+ % ctr))
                  (map utils/v->s))
        xprops (assoc props :points (apply str (interpose " " xpts)))]
    [k xprops]))

(defmethod rotate-element :polyline
  [deg [k props]]
  (let [ctr (centroid [k props])
        pts (mapv utils/s->v (st/split (:points props) #" "))
        xpts (->> pts
                  (map #(utils/v- % ctr))
                  (map #(rotate-pt deg %))
                  (map #(utils/v+ % ctr))
                  (map utils/v->s))
        xprops (assoc props :points (apply str (interpose " " xpts)))]
    [k xprops]))

(defmethod rotate-element :rect
  [deg [k props]]
  (let [[cx cy] (centroid [k props])
        xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 0] + deg)
                   (assoc-in  [:rotate 1] cx)
                   (assoc-in  [:rotate 2] cy))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props]))

(defmethod rotate-element :image
  [deg [k props]]
  (let [[cx cy] (centroid [k props])
        xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 0] + deg)
                   (assoc-in  [:rotate 1] cx)
                   (assoc-in  [:rotate 2] cy))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props]))

(defmethod rotate-element :text
  [deg [k props text]]
  (rotate-element-by-transform deg [k props text]))

#+END_SRC

*** rotate-element-path
To complete the translate implementation, I have to make sure path elements can be propery handled.

To do this, I have a second multimethod to handle different commands that can show up in a path string. Command data structures are produced using the path-dsl functions defined earlier.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti rotate-path-command
  (fn [_ _ m]
    (:command m)))

(defmethod rotate-path-command "M"
  [ctr deg {:keys [:input] :as m}]
  (let [xpt (->> input
                 (#(utils/v- % ctr))
                 (rotate-pt deg)
                 (utils/v+ ctr))]
    (assoc m :input xpt)))

(defmethod rotate-path-command "L"
  [ctr deg {:keys [:input] :as m}]
  (let [xpt (->> input
                 (#(utils/v- % ctr))
                 (rotate-pt deg)
                 (utils/v+ ctr))]
    (assoc m :input xpt)))

(defmethod rotate-path-command "C"
  [ctr deg {:keys [:input] :as m}]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(rotate-pt deg %))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "S"
  [ctr deg {:keys [:input] :as m}]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(rotate-pt deg %))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "Q"
  [ctr deg {:keys [:input] :as m}]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(rotate-pt deg %))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "T"
  [ctr deg {:keys [:input] :as m}]
  (let [xpt (->> input
                 (#(utils/v- % ctr))
                 (rotate-pt deg)
                 (utils/v+ ctr))]
    (assoc m :input xpt)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod rotate-path-command "A"
  [ctr deg {:keys [:input] :as m}]
  (let [[rx ry xrot laf swf ox oy] input
        [nx ny] (->> [ox oy]
                     (#(utils/v- % ctr))
                     (rotate-pt deg)
                     (utils/v+ ctr))]
    (assoc m :input [rx ry (+ xrot deg) laf swf nx ny])))

(defmethod rotate-path-command "Z"
  [_ _ cmd]
  cmd)

(defmethod rotate-path-command :default
  [a cmd]
  [a cmd])

(defmethod rotate-element :path
  [deg [k props]]
  (let [ctr (centroid [k props])
        cmds (path/path-string->commands (:d props))
        xcmds (map #(rotate-path-command ctr deg %) cmds)]
    [k (assoc props :d (path/cmds->path-string xcmds))]))

#+END_SRC

*** group-rotate
If I let the rotate 'pass through' a group, it rotates every child element locally. This has the effect of ignoring grouped elements that you do want to rotate about the group's center.

Each child of a group must be rotated around the group's midpoint.
So,
- find group midpoint
- apply rotation to children about group midpoint
  - rotate child by deg
  - translate child to new center (rotate its orig midpoint about group midpoint to find new position)

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(declare rotate)
(defmethod rotate-element :g
  [deg [k props & content]]
  (let [[gcx gcy] (centroid-of-pts (bounds (into [k props] content)))
        xfcontent (for [child content]
                    (let [ch (translate [(- gcx) (- gcy)] child)
                          ctr (if (= :g (first ch))
                                (centroid-of-pts (bounds ch))
                                (centroid ch))
                          xfm (->> ctr
                                   (rotate-pt deg)
                                   (utils/v+ [gcx gcy]))]
                      (->> ch
                           (translate (utils/v* [-1 -1] ctr))
                           (rotate deg)
                           (translate-element xfm))))]
    (into [k props] (filter (complement nil?) xfcontent))))
#+END_SRC

*** interface
I have to make sure rotate does not return elements with 'nil' content at the ends.


#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn rotate
  "Rotates the `elems` by `deg` around the centroid of the element(s).

  Applied rotations are local."
  [deg & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (specs/element? elem) (= 0 (count elems)))
        (rotate-element deg elem)
        
        (and (specs/element? elem) (< 0 (count elems)))
        (concat
         [(rotate-element deg elem)]
         [(rotate deg elems)])
        
        :else
        (recur deg (concat elem elems))))))

#+END_SRC

** scale
Scale implementation doesn't seem to work correctly in all cases. For example, scaling something down and translating a group containing it will shift it, which is undesired behaviour.

Scale should be 'baked into' all dimensions just like other transforms, where possible.

*** scale-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn scale-element-by-transform
  [[sx sy] [k props & content]]
  (let [xf (utils/str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props] content))

(defmulti scale-element 
  (fn [_ element]
    (first element)))

;; transforms are applied directly to the properties of shapes.
;; I have scale working the same way. One issue is that scaling a circle
;; turns it into an ellipse. This impl WILL change the shape to ellipse if non-uniform scaling is applied.

(defmethod scale-element :circle
  [[sx sy] [k props]]
  (let [circle? (= sx sy)
        r (:r props)
        new-props (if circle?
                    (assoc props :r (* r sx))
                    (-> props
                        (dissoc :r)
                        (assoc :rx (* sx r))
                        (assoc :ry (* sy r))))
        k (if circle? :circle :ellipse)]
    [k new-props]))

(defmethod scale-element :ellipse
  [[sx sy] [k props]]
  (let [new-props (-> props
                      (update :rx #(* sx %))
                      (update :ry #(* sy %)))]
    [k new-props]))

;; find bounding box center
;; translate bb-center to 0 0
;; scale all x y values by * [sx sy]
;; translate back to original bb-center

(defmethod scale-element :line
  [[sx sy] [k props]]
  (let [[cx cy] (centroid [k props])
        new-props (-> props
                      (update :x1 #(+ (* (- % cx) sx) cx))
                      (update :y1 #(+ (* (- % cy) sy) cy))
                      (update :x2 #(+ (* (- % cx) sx) cx))
                      (update :y2 #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defn scale-pt-from-center
  [[cx cy] [sx sy] [x y]]
  [(+ (* (- x cx) sx) cx)
   (+ (* (- y cy) sy) cy)])

(defmethod scale-element :polygon
  [[sx sy] [k props]]
  (let [pts (mapv utils/s->v (st/split (:points props) #" "))
        ctr (centroid [k props])
        xpts (->> pts
                  (map (partial scale-pt-from-center ctr [sx sy]))
                  (map utils/v->s))]
    [k (assoc props :points (apply str (interpose " " xpts)))]))

(defmethod scale-element :polyline
  [[sx sy] [k props]]
  (let [pts (mapv utils/s->v (st/split (:points props) #" "))
        ctr (centroid [k props])
        xpts (->> pts
                  (map (partial scale-pt-from-center ctr [sx sy]))
                  (map utils/v->s))]
    [k (assoc props :points (apply str (interpose " " xpts)))]))

(defmethod scale-element :rect
  [[sx sy] [k props]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale-element :image
  [[sx sy] [k props]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale-element :text
  [[sx sy] [k props text]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (get-in xf [:rotate 1])
        cy (get-in xf [:rotate 2])
        x (+ (* (- (:x props) cx) sx) cx)
        y (+ (* (- (:y props) cy) sy) cy)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (- x))
                   (assoc-in [:rotate 2] (- y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (assoc :x x)
                      (assoc :y y)
                      (update-in [:style :font-size] #(* % sx)))]
    [k new-props text]))

(defmethod scale-element :g
  [[sx sy] [k props & content]]
  (let [xf (utils/str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    (into [k new-props] content)))

#+END_SRC

*** scale-element-path
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti scale-path-command
  (fn [_ _ m]
    (:command m)))

(defmethod scale-path-command :default
  [ctr [sx sy] {:keys [:input] :as m}]
  (let [pts (mapv vec (partition 2 input))
        xpts (->> pts
                  (mapcat (partial scale-pt-from-center ctr [sx sy])))]
    (assoc m :input (vec xpts))))

;; this is wrong. just a stub to get moving a bit
(defmethod scale-path-command "A"
  [ctr [sx sy] {:keys [:input] :as m}]
  (let [pts [(take-last 2 input)]
        xpts (->> pts
                  (mapcat (partial scale-pt-from-center ctr [sx sy])))]
    (assoc m :input (vec xpts))))

(defmethod scale-element :path
  [[sx sy] [k props]]
  (let [ctr (centroid [k props])
        cmds (path/path-string->commands (:d props))
        xcmds (map #(scale-path-command ctr [sx sy] %) cmds)]
    [k (assoc props :d (path/cmds->path-string xcmds))]))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn scale
  "Scales the `elems` by `sc` about the centroid of the element(s).

  NOTE: this function is still relatively untested and may not behave correctly with group elements."
  [sc & elems]
  (let [[sx sy] (if (coll? sc) sc [sc sc])
        elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (specs/element? elem) (= 0 (count elems)))
        (scale-element [sx sy] elem)
        
        (and (specs/element? elem) (< 0 (count elems)))
        (concat
         [(scale-element [sx sy] elem)]
         [(scale [sx sy] elems)])
        
        :else
        (recur [sx sy] (concat elem elems))))))

#+END_SRC
* sandbox
This is a namespace idea for 'first time users' or people who just want to quickly try the library without requiring any other namespaces.

This is just an idea for now. I am second-guessing the interning approach in svg-clj.main (largely due to cljs incompatibility).
** ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/sandbox.clj
(ns svg-clj.sandbox
  (:require [clojure.string :as st]
            [clojure.data.xml :as xml]
            [svg-clj.utils :as utils]
            [svg-clj.specs :as specs]
            [svg-clj.transforms :as transforms]
            [svg-clj.path :as path]))

;; thanks to help from walterl and seancorfield on Clojurians Slack
(defn intern-with-meta
  [q-sym]
  (let [sym (symbol (name q-sym))]
    (do (intern *ns* sym (resolve q-sym))
        (alter-meta! (resolve sym) 
                     #(merge % (meta (resolve q-sym)) 
                             {:ns *ns*})))))

(intern-with-meta 'transforms/centroid)
(intern-with-meta 'transforms/bounds)
(intern-with-meta 'transforms/translate)
(intern-with-meta 'transforms/rotate)
(intern-with-meta 'utils/rotate-pt)
(intern-with-meta 'transforms/scale)
(intern-with-meta 'path/path)
(intern-with-meta 'path/merge-paths)
(intern-with-meta 'path/polygon-path)
#+END_SRC

* main
** ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(ns svg-clj.main
  (:require [clojure.string :as st]
            #?(:clj [clojure.data.xml :as xml])
            [svg-clj.utils :as utils]
            [svg-clj.specs :as specs]))
#+END_SRC

** container-elements
Any elements that wrap content. Primary function is svg which is the ~container~ element for all other SVG elements.

*** svg
#+begin_src clojure :tangle ./src/svg_clj/main.cljc
(defn svg
   "This fn wraps `content` in an SVG container element.
   The SVG container is parameterized by width `w`, height `h`, and scale `sc`."
  [[w h sc] & content]
  [:svg {:width  w
         :height h
          :viewBox (str "0 0 " w " " h)
         :xmlns "http://www.w3.org/2000/svg"}
   (if sc
     [:g {:transform (str "scale(" sc ")")} content]
     content)])
#+end_src

** shapes
 A shape is a hiccup data structure that represents one of the valild SVG elements.

 All shape functions will return a vector of the following shape:

 ~[:tag {:props "value"} "content"]~

 The tag and props will always exist, but content may or may not exist. For most geometric shape elements, there is no content. Elements like ~text~ and ~g~ do have content.

 As a general term, I use 'element' to refer to the hiccup vector structure. So, ~[:circle {:r 2}]~ is an element as is ~[:p "some paragraph"]~. The vector ~[2 4]~ is not an element.

 The term 'properties' (sometimes written 'props') refers to the map in the index 1 of a hiccup vector.

 The term 'content' refers to the inner part of a hiccup data structure that is neither the key nor the properties. Content can be nil, length one, or many.

*** circle
#+begin_src clojure :tangle ./src/svg_clj/main.cljc
(defn circle
  [r]
  [:circle {:cx 0 :cy 0 :r r}])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef circle
   :args (s/cat :r number?)
   :ret ::svg-element)
 #+end_src

*** ellipse
 #+begin_src clojure :tangle ./src/svg_clj/main.cljc
 (defn ellipse
   [rx ry]
   [:ellipse {:cx 0 :cy 0 :rx rx :ry ry}])
 #+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef ellipse
   :args (s/cat :rx number? :ry number?)
   :ret ::svg-element)
 #+end_src

*** line
 #+begin_src clojure :tangle ./src/svg_clj/main.cljc
 (defn line
   [[ax ay] [bx by]]
   [:line {:x1 ax :y1 ay :x2 bx :y2 by}])
 #+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef line
   :args (s/cat :a ::pt2d :b ::pt2d)
   :ret ::svg-element)
 #+end_src

*** polygon
 #+begin_src clojure :tangle ./src/svg_clj/main.cljc
 (defn polygon
   [pts]
   [:polygon {:points (apply str (interpose " " (map utils/v->s pts)))}])
 #+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef polygon
   :args (s/cat :pts ::pts)
   :ret ::svg-element)
 #+end_src

*** polyline
 #+begin_src clojure :tangle ./src/svg_clj/main.cljc
 (defn polyline
   [pts]
   [:polyline {:points (apply str (interpose " " (map utils/v->s pts)))}])
 #+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef polyline
   :args (s/cat :pts ::pts)
   :ret ::svg-element)
 #+end_src

*** rect
 #+begin_src clojure :tangle ./src/svg_clj/main.cljc
 (defn rect
   [w h]
   [:rect {:width w :height h :x (/ w -2.0) :y (/ h -2.0)}])
 #+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef rect
   :args (s/cat :w number? :h number?)
   :ret ::svg-element)
 #+end_src

*** image
 #+begin_src clojure :tangle ./src/svg_clj/main.cljc
 (defn image
   [url w h]
   [:image {:href url :width w :height h :x (/ w -2.0) :y (/ h -2.0)}])
 #+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef image
   :args (s/cat :url string? :w number? :h number?)
   :ret ::svg-element)
 #+end_src

*** g
#+begin_src clojure :tangle ./src/svg_clj/main.cljc
(defn g
  [& content]
  (if (and (= 1 (count content))
           (not (keyword? (first (first content)))))
    ;; content is a list of a list of elements
    (into [:g {}] (first content))
    ;; content is a single element OR a list of elements
    (into [:g {}] (filter (complement nil?) content))))
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 #_(s/fdef g
   :args ::groupable
   :ret ::svg-element)
 #+end_src

*** text
 Text is a bit different. It is much more complicated to know text's centroid and thus local rotation/translation methods for all other shapes don't easily apply. 

 So, like path, text is treated as a very simple wrapper, but has (will have) its own functions for better control/manipulation of text elements.

 In particular, you cannot know the exact width and height of a text element without being able to fully render the glyphs of the font. This is currently beyond the scope of the existing function below.

 #+begin_src clojure :tangle ./src/svg_clj/main.cljc
 (defn text
   [text]
   [:text {:x 0 :y 0} text])
 #+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef text
   :args (s/cat :text string?)
   :ret ::svg-element)
 #+end_src

** svg-loader
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
#?(:clj
   (defn xml->hiccup
     [xml]
     (if-let [t (:tag xml)]
       (let [elem [t]
             elem (if-let [attrs (:attrs xml)]
                    (conj elem attrs)
                    elem)]
         (into elem (map xml->hiccup (:content xml))))
       xml)))

#?(:clj
   (defn ->edn
     [str]
     (->> (xml/parse-str str 
                         :skip-whitespace true
                         :namespace-aware false)
          xml->hiccup
          #_(tree-seq vector? rest)
          #_(filter vector?)
          #_(filter #(= :svg (first %)))
          #_first)))

#?(:clj
   (defn unwrap-elements
     [edn]
     (filter specs/element? edn)))
#+END_SRC

** style
 Style transforms allow the user to change any attributes of svg elements that affect appearance. For instance, stroke color, stroke width, and fill.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn style
  [style [k props & content]]
  (into [k (merge props style)] content))
#+END_SRC

* tests
** test-ns
#+BEGIN_SRC clojure :tangle ./test/svg_clj/main_test.cljc
(ns svg-clj.main-test
  (:require [svg-clj.main :as svg :refer :all]
            [clojure.test :refer [deftest is]]
            [clojure.spec.alpha :as s]
            [clojure.spec.test.alpha :as stest]))

#+END_SRC
** tests
#+begin_src clojure :tangle ./test/svg_clj/main_test.cljc
;; just starting with some basics. 
;; more complete tests coming soon
(stest/instrument)

(def test-circle (circle 5))
(def test-ellipse (ellipse 5 10))
(def test-line (line [0 0] [10 20]))
(def test-path (polygon-path [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-polygon (polygon [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-polyline (polyline [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-rect (rect 60 30))
(def test-image (image "https://www.fillmurray.com/g/200/300" 200 300))
(def test-g (g test-circle
               test-ellipse
               test-line
               test-path
               test-polygon
               test-polyline
               test-rect
               test-image))

(def test-shapes [test-circle
                  test-ellipse
                  test-line
                  test-path
                  test-polygon
                  test-polyline
                  test-rect
                  test-image])

(deftest basic-shapes-test
  (is (= test-circle [:circle {:cx 0 :cy 0 :r 5}]))
  (is (= test-ellipse [:ellipse {:cx 0 :cy 0 :rx 5 :ry 10}]))
  (is (= test-line [:line {:x1 0 :y1 0 :x2 10 :y2 20}]))
  (is (= test-path [:path {:d "M0 0 L10 20 L40 50 L20 10 Z"
                           :fill-rule "evenodd"}]))
  (is (= test-polygon [:polygon {:points "0,0 10,20 40,50 20,10"}]))
  (is (= test-polyline [:polyline {:points "0,0 10,20 40,50 20,10"}]))
  (is (= test-rect [:rect {:x -30.0 :y -15.0 :width 60 :height 30}]))
  (is (= test-image [:image 
                     {:href "https://www.fillmurray.com/g/200/300"
                      :x -100.0 :y -150.0 
                      :width 200 :height 300}])))

(deftest basic-translate-test
  (is (= (->> test-circle (translate [10 10]))
         [:circle {:r 5 :cx 10 :cy 10 :transform "rotate(0 10 10)"}]))
  (is (= (->> test-ellipse (translate [10 10]))
         [:ellipse {:rx 5 :ry 10 :cx 10 :cy 10 :transform "rotate(0 10 10)"}]))
  (is (= (->> test-line (translate [10 10]))
         [:line {:x1 10 :y1 10 :x2 20 :y2 30}]))
  (is (= (->> test-path (translate [10 10]))
         [:path {:d "M10 10 L20 30 L50 60 L30 20 Z"
                 :fill-rule "evenodd"}]))
  (is (= (->> test-polygon (translate [10 10]))
         [:polygon {:points "10,10 20,30 50,60 30,20"}]))
  (is (= (->> test-polyline (translate [10 10]))
         [:polyline {:points "10,10 20,30 50,60 30,20"}]))
  (is (= (->> test-rect (translate [10 10]))
         [:rect {:x -20.0 :y -5.0 :width 60 :height 30 :transform "rotate(0 10.0 10.0)"}]))
  (is (= (->> test-image (translate [10 10]))
         [:image {:href "https://www.fillmurray.com/g/200/300"
                  :x -90.0 :y -140.0
                  :width 200 :height 300
                  :transform "rotate(0 10.0 10.0)"}])))

#+end_src

* watcher
this can be run with clj -m svg-clj.watcher qblock.cljc in terminal.

#+begin_src clojure :tangle ./src/svg_clj/watcher.clj
(ns svg-clj.watcher
  (:require [clojure.string :as st]
            [svg-clj.main :refer :all]
            [hiccup.core :refer [html]]
            [hawk.core :as hawk]))
 
(defn design-watch
  [f]
  (hawk/watch!
   [{:paths [f]
     :handler
     (fn [ctx e]
       (require '[svg-clj.main :refer :all]
                '[hiccup.core :refer [html]])
       (->> (slurp f)
            (format "[%s]")
            load-string
            (filter (complement var?))
            html
            (spit "test.html"))
       ctx)}]))

(defn -main [& args] (design-watch (first args)))
#+end_src
* examples
This is a WIP file for a more complex drawing to be used in tests. This will use all transforms, all shapes, etc.

#+begin_src clojure :tangle ./examples/basics.cljc
(ns examples.basics
  (:require [clojure.string :as st]
            [clojure.java.shell :refer [sh]]
            [hiccup.core :refer [html]]
            [svg-clj.utils :as utils]
            [svg-clj.path :refer [path
                                  merge-paths
                                  circle-path
                                  line-path
                                  rect-path
                                  polyline-path
                                  polygon-path
                                  bezier
                                  arc]]
            [svg-clj.transforms :refer [centroid
                                        bounds
                                        translate
                                        rotate
                                        scale]]
            [svg-clj.main :refer [->edn
                                  svg
                                  circle
                                  ellipse
                                  rect
                                  line
                                  polygon
                                  polyline
                                  text
                                  g
                                  image
                                  style]]))

(defn show-debug-geom
  [elem]
  (let [ctr (centroid elem)
        bds (bounds elem)]
    (g elem
       (g (->> (polygon bds)
               (style {:fill "none"
                       :stroke "red"
                       :stroke-width "3px"}))
          (->> (circle 2)
               (translate ctr)
               (style {:fill "red"}))))))

(def a (g (->> (circle 50)
               (translate [100 100])
               (style {:fill "pink"
                       :stroke-width "5px"
                       :stroke "hotpink"}))
          (->> (circle 10)
               (translate [15 15])
               (style {:fill "pink"
                       :stroke-width "5px"
                       :stroke "hotpink"}))))

(def basic-group
  (g
   (rect 20 20)
   (->> (rect 20 20) (translate [20 0]))
   (->> (rect 20 20) (translate [0 20]))
   (->> (rect 20 20) (translate [20 20]))))

(def circles
  (svg 
   [200 200 1]
   (->>
    (apply g (for [a (range 0 12)]
         (->> (circle (+ 5 (* a 4)))
              (translate [(/ (+ 5 (* a 4)) 2) 0])
              (translate (utils/rotate-pt (* a -40) [20 0]))
              (style {:stroke 
                      (str "rgba(163,190,140," 
                           (/ (inc a) 10.0) ")")
                      :stroke-width "2px"
                      :fill "none"}))))
    (translate [100 100]))))
#+end_src


NOTE: suggestion from GreenCoder regarding bezier

fn that appends to existing bezier

(bezier-append pt)

#+begin_src clojure :tangle ./examples/basics.cljc
(def basics [(arc [0 0] [50 0] 90)
             (circle-path 40)
             (bezier [0 0] [30 20] [80 40] [120 180])
             (circle 80)
             (rect-path 70 120)
             (ellipse 40 80)
             (line [0 0] [100 100])
             (line-path [0 0] [100 100])
             (polygon [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (polyline [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (polygon-path [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (text "this is text")
             (image "https://www.fillmurray.com/300/200" 100 67)
             (merge-paths (rect-path 100 100) (rect-path 80 80))
             basic-group])

(def doc
  (->>
   (for [elem basics]
     (->> 
      (svg [200 200 1]
           (->> elem
                (translate [100 100])
                (rotate 90)
                (style {:fill "pink"
                        :stroke-width "2px"
                        :stroke "hotpink"})
                show-debug-geom))
      (style {:style {:outline "1px solid blue"
                      :margin "10px"}})))
   (partition-all 3)
   (interpose [:br])))

(spit 
 "examples/basics.html"
 (html 
  [:html 
   [:body
    [:h1 "Basic Geometry Examples"]
    doc
    #_circles]]))

#+end_src

