* ;;
#+Title: svg-clj
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: excl
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:deps 
 {org.clojure/clojure       {:mvn/version "1.10.1"}
  org.clojure/clojurescript {:mvn/version "1.10.597"}
  org.clojure/spec.alpha    {:mvn/version "0.2.187"}
  org.clojure/test.check    {:mvn/version "1.1.0"}
  org.clojure/data.xml      {:mvn/version "0.0.8"}
  hawk/hawk                 {:mvn/version "0.2.11"}
  batik-rasterize/batik-rasterize {:mvn/version "0.1.2"}
  hiccup/hiccup             {:mvn/version "2.0.0-alpha2"}}
 :aliases {:test {:extra-paths ["test"]
                 :extra-deps {com.cognitect/test-runner {:git/url "https://github.com/cognitect-labs/test-runner.git"
                                                         :sha "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
                 :main-opts ["-m" "cognitect.test-runner"]}}}

#+end_src

** readme
#+BEGIN_SRC markdown :tangle ./readme.md
# svg-clj

A helper library for creating SVGs in Clojure/Clojurescript.

You can play around with the library [here](https://adam-james-v.github.io/dev/svg-clj/)

This is currently a work in progress. Until a stable release is provided, this library is considered to be in a 'prototype' state. Breaking changes are possible until a proper release is achieved.

![An SVG Image of Circles Spiralling, shrinking, and fading towards the image center.](https://github.com/adam-james-v/svg-clj/blob/main/examples/circles.svg "Circles")

These circles are produced by the following code:

```clojure
(ns example
  (:require [svg-clj.elements :as svg]
            [svg-clj.transforms :as tf]
            [svg-clj.utils :as utils]
            [hiccup.core :refer [html]]))

(def circles
  (-> (svg/g 
       (for [a (range 0 12)]
         (-> (svg/circle (+ 5 (* a 4)))
             (tf/translate [(/ (+ 5 (* a 4)) 2) 0])
             (tf/translate (utils/rotate-pt [20 0] (* a -40)))
             (tf/style 
              {:stroke (str "rgba(163,190,140," (/ (inc a) 10.0) ")")
               :stroke-width "2px"
               :fill "none"}))))
      (tf/translate [100 100])
      (svg/svg 200 200)))

;; use hiccup or your favourite hiccup compiler.
;; the SVG library works with Reagent as well.
(html circles)
```

### Deps.edn

```clj
svg-clj/svg-clj {:git/url "https://github.com/adam-james-v/svg-clj"
                 :sha "grab-latest-sha"}
```


If you would like to understand my motivations, decisions, and reasoning for the choices I've made in this library, you can read the .org file in the top level of this repo.

[svg-clj.org](https://github.com/adam-james-v/svg-clj/blob/main/svg-clj.org). I attempt to do literate programming in my org files, but I have a scattered approach, so please be patient if you're reading the notes; they may not always make sense. Proper documentation is, naturally, a key element in bringing this project from prototype to release.

## Other Work

[Dali](https://github.com/stathissideris/dali) is a library by Stathis Sideris that also works with SVG. Since I have only recently heard about this library, I have not yet had time to do a detailed comparison but, at a glance, some differences I see are:

|                    svg-clj                   |                       dali                      |
|:--------------------------------------------:|:-----------------------------------------------:|
| users write functions which emit hiccup data | users write hiccup data directly                |
| no layout engine                             | layout engine                                   |
| no built-in rasterization                    | rasterize SVGs using Batik                      |
| Clojure and Clojurescript                    | Clojure only                                    |
| SVG primitives only (for now)                | SVG primitives + 'prefabs' (eg. markers/arrows) |

Stay tuned for updates!

#+END_SRC

* admin
** todo
Some tasks that need to be done on this project.
*** TODO Add rounding to reduce file sizes from points having too many decimal places
*** TODO build a mechanism for changing rotate behavior from local to global -> probably use *dynamic-var* 
*** TODO build a mechanism for changing transform 'baking' behavior
*** TODO for circle and ellipse, try to remove the transform rotate(0 x y) idea. Seems confusing and unnecessary anyway.

** roadmap
Some features that are planned for implementation.

*** candidate-features
Should I add these to the svg-clj library? Or should they be some different library?

I think these make more sense in separate libraries. Perhaps as ns inside a 2d-cad-drawing lib or something along those lines. 

- math helpers
  - to-deg
  - to-rad
  - vector arithemetic helpers v* v+ v-
- drawing features  
  - regular-polygon-pts  
  - offset
- 'composite' shapes and containers
  - arrows
  - dimensions
  - figure containers
  - 

** misc-notes
Remember in REPL you can't re-def the defmulti dispatch function with some ns magic.

https://clojuredocs.org/clojure.core/defmulti#example-55d9e498e4b0831e02cddf1b

#+begin_src clojure
(defmulti x (fn[_] :dec)) ;; Can't redefine
(x 0) ;; => 1 ;; STILL 
(ns-unmap *ns* 'x) ;; => unmap the var from the namespace

#+end_src


Maikerusan suggests:

A mechanism for setting up global defaults when a user has loaded the library.
Config would control:
 - all shapes centering behaviour (eg. center at centroid, corner, whatever)

 - whether translate/rotate are 'baked' or not.
   - 'baked' is the default and means you technically lose information when compiling to SVG (eg you cannot tell that a line was translated if the coords have the translate baked in)

* design
** intent
The purpose of this library is to allow users to create simple functional programs that compile to SVG elements. 

The expected kinds of input are .clj files with svg-clj code, STDIN with svg-clj code. The expected output is hiccup-style clojure data structures, and optionally a compiled SVG string to file or STDOUT.

Basically, this is just a library, but I will add a small CLI interface and create a binary distribution so that the library can stand alone as a small utility, perhaps as a useful tool in a bash scripting pipeline.

** structure
The library uses hiccup syntax to represent the SVG diagrams being created. The user writes functional code to define various elements of the SVG and has access to transformations via utility functions.

Since the library functions emit hiccup data structures, the user can extend and manipulate their data using other clojure libraries or their own approaches. 

The library has two main categories of functions:

- elements
  - container elements (svg, figure...)
  - composites (custom functions using shapes.. eg. arrow)
  - shapes
    - circle
    - ellipse
    - line
    - path
    - polygon
    - polyline
    - rect
  - text
  - g
  - animation (maybe in future)

- transforms
  - rotate
  - translate
  - scale
  - style

There are utility type functions as well
- geometric utilities (centroid, bounds)
- data manipulation utilities

** opinionated-approach
This is not quite a straight wrapper for SVG functionality. I have altered the default behavior of some functions.

For example, a rectangle is drawn centered around the orgin by default. Plain SVG rectangles draw with the first corner located at the origin by default.

All rotations are applied to shapes locally by default. This means that a circle at [10 0] rotated by 90 deg will not appear to move using svg-clj; the shape itself is being spun around it's center, but that center point is not moving. Default SVG behaviour rotates around the origin by default. So, any elements offset from the orgin will move large distances away from their starting positions. 

This choice was made because it feels more intuitive (to me, at least) to draw with local transformation operations in mind.

As much as possible, all transformation calculations are 'baked' into shape coordinates and points directly. This means that a [10 20] rectangle that gets translated by [100 100] will be rendered to SVG as follows:

#+begin_src clojure
(comment 
  (translate [100 100] (rect 10 20))
  ;; => [:rect {:width 10, :height 20, :x 95.0, :y 90.0, :transform "rotate(0 100.0 100.0)"}]
  (def a *1)
  (html a)
  ;; => "<rect height=\"20\" transform=\"rotate(0 100.0 100.0)\" width=\"10\" x=\"95.0\" y=\"90.0\"></rect>"
)
#+end_src

** feedback
*** GreenCoder
 Greencoder sent several twitter DMs with some criticisms/feedback.

 - translate function is doing 2 things at the same time: Map + translate
  - not good for composability. doesnt behave the same way as map does
  - with translate, the elems are inlined while with map they are not

 - translate keeps specs in the fn body, but spec has slow runtime so make it optional or replace somehow

   --- for 'playground' or quick and dirty REPL work, I still kinda think it's ok. weak argument, but... I'm lazy when I'm in the CLJ repl.

 - hiccup/html deprecated use hiccup2

 - ->> thread last macro should be kept for stream operations to compose better with other fns

 - I think that translate-element should take elem as first argument.


strictly speaking, translate and rotate are not operating on streams of data, but rather on objects
 - assoc and dissoc use thread first -> you do a thing to a single 'object'
 - map and filter use thread last    -> map and filter will work on lists... lazy, infinite, all possible. 

* utils
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(ns svg-clj.utils
  (:require [clojure.string :as str]
            #?(:cljs
               [cljs.reader :refer [read-string]])))

;; vector arithmetic helpers
(def v+ (partial mapv +))
(def v- (partial mapv -))
(def v* (partial mapv *))

;; simple calcs
(defn to-deg
  [rad]
  (* rad (/ 180 Math/PI)))

(defn to-rad
  [deg]
  (* deg (/ Math/PI 180)))

(defn round
  [num places]
  (let [d (Math/pow 10 places)]
    (/ (Math/round (* num d)) d)))

(defn average
  [& numbers]
  (let [n (count numbers)]
    (/ (apply + numbers) n)))
 
;; some string transformation tools
(defn v->s
  "Turns the vector `v` into a string formatted for use in SVG attributes."
  [v]
  (str/join "," v))

(defn s->v
  "Turns a string of comma or space separated numbers into a vector."
  [s]
  (-> s
      (str/trim)
      (str/split #"[, ]")
      (#(filter (complement empty?) %))
      (#(mapv read-string %))))

(defn xf-kv->str
  [[k v]]
  (str (symbol k) (apply list v)))

(defn str->xf-kv
  [s]
  (let [split (str/split s #"\(")
        key (keyword (first split))
        val (vec (read-string (str "(" (second split))))]
    [key val]))

(defn xf-map->str
  [m]
  (str/join "\n" (map xf-kv->str m)))

(defn str->xf-map
  [s]
  (if-let [s s]
    (into {} 
          (->> s
               (#(str/replace % #"\)" ")\n"))
               str/split-lines
               (map str/trim)
               (map str->xf-kv)))
    {}))

;; geom
(defn distance
  "compute distance between two points"
  [a b]
  (let [v (v- b a)
        v2 (reduce + (v* v v))]
    (Math/sqrt v2)))

(defn rotate-pt
  [[x y] deg]
  (let [c (Math/cos (to-rad deg))
        s (Math/sin (to-rad deg))]
    [(- (* x c) (* y s))
     (+ (* x s) (* y c))]))

(defn rotate-pt-around-center
  [pt deg center]
  (-> pt
      (v+ (map - center))
      (rotate-pt deg)
      (v+ center)))

(defn dot*
  "calculates the dot product of two vectors"
  [a b]
  (reduce + (map * a b)))
;; https://math.stackexchange.com/questions/361412/finding-the-angle-between-three-points
(defn angle-from-pts
  [p1 p2 p3]
  (let [v1 (v- p2 p1)
        v2 (v- p2 p3)
        l1 (distance p1 p2)
        l2 (distance p3 p2)
        n (dot* v1 v2)
        d (Math/abs (* l1 l2))]
    (when (not (= 0.0 (float d)))
      (to-deg (Math/acos (/ n d))))))
#+end_src

* elements
** ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/elements.cljc
(ns svg-clj.elements
  (:require [clojure.string :as str]
            #?(:clj [clojure.data.xml :as xml])
            [svg-clj.utils :as utils]
            [svg-clj.transforms :as tf]))

#+END_SRC

** containers
Any elements that wrap content. Primary function is svg which is the ~container~ element for all other SVG elements.

*** svg
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn svg
   "The svg fn wraps `content` in an SVG container element.
   The SVG container is parameterized by width `w`, height `h`, and scale `sc`."
  ([content]
   (let [[[xmin ymin] _ [xmax ymax] _] (tf/bounds content)
         w (- xmax xmin)
         h (- ymax ymin)]
     [:svg {:width  w
            :height h
            :viewBox (str/join " " [(/ w -2.0) (/ h -2.0) w h])
            :xmlns "http://www.w3.org/2000/svg"}
      content]))

  ([content w h]
   [:svg {:width  w
          :height h
          :viewBox (str "0 0 " w " " h)
          :xmlns "http://www.w3.org/2000/svg"}
    content])

  ([content w h sc]
   (svg [:g {:transform (str "scale(" sc ")")} content] w h)))

#+end_src

** shapes
A shape is a hiccup data structure that represents one of the valild SVG elements.

 All shape functions will return a vector of the following shape:

 ~[:tag {:props "value"} "content"]~

 The tag and props will always exist, but content may or may not exist. For most geometric shape elements, there is no content. Elements like ~text~ and ~g~ do have content.

 As a general term, I use 'element' to refer to the hiccup vector structure. So, ~[:circle {:r 2}]~ is an element as is ~[:p "some paragraph"]~. The vector ~[2 4]~ is not an element.

 The term 'properties' (sometimes written 'props') refers to the map in the index 1 of a hiccup vector.

 The term 'content' refers to the inner part of a hiccup data structure that is neither the key nor the properties. Content can be nil, length one, or many.

*** circle
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn circle
  [r]
  [:circle {:cx 0 :cy 0 :r r}])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef circle
   :args (s/cat :r number?)
   :ret ::svg-element)
 #+end_src

*** ellipse
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn ellipse
  [rx ry]
  [:ellipse {:cx 0 :cy 0 :rx rx :ry ry}])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef ellipse
   :args (s/cat :rx number? :ry number?)
   :ret ::svg-element)
 #+end_src

*** line
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn line
  [[ax ay] [bx by]]
  [:line {:x1 ax :y1 ay :x2 bx :y2 by}])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef line
   :args (s/cat :a ::pt2d :b ::pt2d)
   :ret ::svg-element)
 #+end_src

*** polygon
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn polygon
  [pts]
  [:polygon {:points (str/join " " (map utils/v->s pts))}])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef polygon
   :args (s/cat :pts ::pts)
   :ret ::svg-element)
 #+end_src

*** polyline
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn polyline
  [pts]
  [:polyline {:points (str/join " " (map utils/v->s pts))}])

#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef polyline
   :args (s/cat :pts ::pts)
   :ret ::svg-element)
 #+end_src

*** rect
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn rect
  [w h]
  [:rect {:width w :height h :x (/ w -2.0) :y (/ h -2.0)}])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef rect
   :args (s/cat :w number? :h number?)
   :ret ::svg-element)
 #+end_src

** other
*** image
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn image
  [url w h]
  [:image {:href url :width w :height h :x (/ w -2.0) :y (/ h -2.0)}])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef image
   :args (s/cat :url string? :w number? :h number?)
   :ret ::svg-element)
 #+end_src

*** g
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn g
  [& content]
  (if (and (= 1 (count content))
           (not (keyword? (first (first content)))))
    ;; content is a list of a list of elements
    (into [:g {}] (first content))
    ;; content is a single element OR a list of elements
    (into [:g {}] (filter (complement nil?) content))))
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 #_(s/fdef g
   :args ::groupable
   :ret ::svg-element)
 #+end_src

*** text
Text is a bit different. It is much more complicated to know text's centroid and thus local rotation/translation methods for all other shapes don't easily apply. 

So, like path, text is treated as a very simple wrapper, but has (will have) its own functions for better control/manipulation of text elements.

In particular, you cannot know the exact width and height of a text element without being able to fully render the glyphs of the font. This is currently beyond the scope of the existing function below.

#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn text
  [text]
  [:text {:x 0 :y 0} text])
#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef text
   :args (s/cat :text string?)
   :ret ::svg-element)
 #+end_src

* path-dsl
The path element has a small DSL to create compound curves. This includes the following (taken from [[https://www.w3schools.com/graphics/svg_path.asp]]):

 M = moveto
 L = lineto
 H = horizontal lineto
 V = vertical lineto
 C = curveto
 S = smooth curveto
 Q = quadratic Bézier curve
 T = smooth quadratic Bézier curveto
 A = elliptical Arc
 Z = closepath

** ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(ns svg-clj.path
  (:require [clojure.string :as str]
            [svg-clj.utils :as utils]))

#+END_SRC

** path
*** path
This path function is usable by the user but provides no path generation assistance. There are several functions defined later that handle path generation.

#+begin_src clojure :tangle ./src/svg_clj/path.cljc
(defn path
  "Wraps a path string `d` in a hiccup-style data structure.
  The path string is minimally evaluated and is otherwise untouched. Users should consider the function `polygon-path` for constructing paths from points. More complex paths can be built by combining paths with the function `merge-paths`"
  [d]
  [:path {:d d
          :fill-rule "evenodd"}])

#+end_src

**** spec
 #+begin_src clojure :tangle ./src/svg_clj/specs.cljc
 (s/fdef path
   :args (s/cat :d ::path-string)
   :ret ::path-element)
 #+end_src

** commands
Path strings are a sequence of commands. These commands can be thought of as moving a pen along the canvas to draw shapes/lines according to the command's inputs.

The order of these commands must be maintained, otherwise the shape will be drawn differently.

I'm going to make a few functions to split paths into commands and put them in a clojure map.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- path-command-strings
  "Split the path string `ps` into a vector of path command strings."
  [ps]
  (-> ps
      (str/replace #"\n" " ")
      (str/split #"(?=[A-DF-Za-df-z])")
      (#(map str/trim %))
      (#(filter (complement empty?) %))))

(defn- relative?
  "True if the path command string `cs` has a relative coordinate command.
  Relative coordinate commands are lowercase.
  Absolute coordinate commands are uppercase."
  [cs]
  (let [csx (first (str/split cs #"[a-z]"))]
    (not (= cs csx))))

(defn- coord-sys-key
  "Returns the command string `cs`'s coord. system key.
  Key is either :rel or :abs."
  [cs]
  (if (relative? cs) :rel :abs))

(defn- command-input
  [cs]
  (let [i (str/split cs #"[A-DF-Za-df-z]")]
    (when (not (empty? (rest i)))
      (apply utils/s->v (rest i)))))

(defn- command
  "Transforms a command string `cs` into a map."
  [cs]
  {:command  (str/upper-case (re-find #"[A-DF-Za-df-z]" cs))
   :coordsys (coord-sys-key cs)
   :input (command-input cs)})

(defn- merge-cursor
  [[pcmd ccmd]]
  (let [cursor (vec (take-last 2 (:input pcmd)))]
    (assoc ccmd :cursor cursor)))

(defn path-string->commands
  "Turns path string `ps` into a list of its command maps."
  [ps]
  (->> ps
       path-command-strings
       (map command)
       (concat [{:command "M"
                 :coordsys :abs
                 :input [0 0]}])
       (partition 2 1)
       (map merge-cursor)))
#+END_SRC

*** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef path-command-strings
  :args (s/cat :path-string ::path-string)
  :ret (s/coll-of ::command-string))

(s/fdef command
  :args (s/cat :command-string ::command-string)
  :ret ::command-map)

(s/fdef path-string->commands
  :args (s/cat :path-string ::path-string)
  :ret (s/coll-of ::command-map))
#+END_SRC

** converting-vh
Given a list of commands, go until you find a V or H with a NON V NON H command preceding it.
Use the previous command to get the missing X or Y value
Create an equivalent L command using the recovered coord. and the V or H coord.
Recreate the sequence having swapped the V or H with the new L command.
Repeat this process over the whole sequence.
If the entire sequence has NO V or H, done.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- any-vh?
  [cmds]
  (not (empty? (filter #{:vline :hline} (map :command cmds)))))

(defn- convert-vh
  [[pcmd ccmd]]
  (if (and (not (any-vh? [pcmd])) ;;prev. cmd must NOT be VH
           (any-vh? [ccmd])) ;; curr. cmd must be VH
    (let [[px py] (take-last 2 (:input pcmd))
          vh (:command ccmd)
          xinput (cond (= vh :hline) [(first (:input ccmd)) py]
                       (= vh :vline) [px (first (:input ccmd))])
          ncmd (-> ccmd
                   (assoc :command :line)
                   (assoc :input xinput))]
      [pcmd ncmd])
    [pcmd ccmd]))

(defn- convert-first-vh-cmd
  [cmds]
  (let [icmd (first cmds)]
    (cons icmd 
          (->> cmds
               (partition 2 1)
               (map convert-vh)
               (map second)))))

(defn- vh->l
  [cmds]
  (let [iters (iterate convert-first-vh-cmd cmds)]
    (->> iters
         (partition 2 1)
         (take-while (fn [[a b]] (not= a b)))
         last
         last)))
#+END_SRC

*** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef vh->l
  :argrs (s/cat :commands (s/coll-of ::command-map))
  :ret (complement any-vh?))
#+END_SRC

** build-path-strings
Given a sequence of command maps, produce a path string.

Then, we can losely consider a sequence of command maps to be the internal data structure for path manipulation. This means you can create multi-path path strings by passing a sequence of sequences of command maps.

For each cmd seq., convert to path-string, then apply string to concatenate these path strings into the final string. You can alternatively treat each path string as the attribute for a new path element and draw them separately.

The requirement is that if a user puts a path string into the system but does not transform it in any way, they should expect an equivalent string to be emitted from the cmds->str fn.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- cmd->path-string
  [{:keys [:command :coordsys :input] :as cmd}]
  (let [c (if (= coordsys :abs)
            command
            (str/lower-case command))]
    (str c (str/join " " input))))

(defn cmds->path-string
  [cmds]
  (str/join " " (map cmd->path-string cmds)))
#+END_SRC

** merge-paths
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn merge-paths
  "Merges a list of path elements together, keeping props from last path in the list."
  [& paths]
  (let [props (second (last paths))
        d (str/join " " (map #(get-in % [1 :d]) paths))]
    [:path (assoc props :d d)]))
#+END_SRC

*** spec
#+begin_src clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef merge-paths
  :args (s/cat :paths (s/coll-of ::path-element))
  :ret ::path-element)
#+END_SRC

** partial-commands
The polygon-path function is a way to create valid path strings from a set of points. The idea is that any call to the polygon fn can be replaced with polygon-path and no visual difference would occur.

Then, paths can be further manipulated by combine and merge.

Convert list of pts into list of commands.
 - first command will be a MOVE command
 - last command will be a CLOSE command
   - can generalize this to polyline by having a close? flag

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- pt->l
  [pt]
  {:command "L"
   :coordsys :abs
   :input (vec pt)})

(defn- pt->m
  [pt]
  {:command "M"
   :coordsys :abs
   :input (vec pt)})
#+END_SRC

** polygons-polylines
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn line-path
  [a b]
  (-> [(pt->m a) (pt->l b)]
      cmds->path-string
      path))

(defn polygon-path
  [pts]
  (let [open (pt->m (first pts))
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> (map pt->l (rest pts))
        (conj open)
        vec
        (conj close)
        cmds->path-string
        path)))

(defn polyline-path
  [pts]
  (let [open (pt->m (first pts))]
    (-> (map pt->l (rest pts))
        (conj open)
        vec
        cmds->path-string
        path)))

(defn rect-path
  [w h]
  (let [w2 (/ w 2.0)
        h2 (/ h 2.0)]
    (polygon-path [ [(- w2) (- h2)] [w2 (- h2)] 
                    [w2 h2]         [(- w2) h2] ])))
#+END_SRC

** bezier
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- partial-bezier
  ([a]
   (-> {:command "T"
        :coordsys :abs
        :input (vec a)}
       cmd->path-string))

  ([a b]
   (-> {:command "S"
        :coordsys :abs
        :input (concat a b)}
       cmd->path-string)))

(defn bezier
  ([a b c]
   (let [open (pt->m a)]
     (-> {:command "Q"
          :coordsys :abs
          :input (concat b c)}
         list
         (conj open)
         vec
         cmds->path-string
         path)))

  ([a b c d]
   (let [open (pt->m a)]
     (-> {:command "C"
          :coordsys :abs
          :input (concat b c d)}
         list
         (conj open)
         vec
         cmds->path-string
         path))))
#+END_SRC

** arc
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- partial-arc
  [rx ry rot laf sw a]
  (let [open (pt->m a)]
    (-> {:command "A"
         :coordsys :abs
         :input (concat [rx ry rot laf sw] a)}
        cmd->path-string)))

(defn- build-arc
  [rx ry rot laf sw a b]
  (let [open (pt->m a)]
    (-> {:command "A"
         :coordsys :abs
         :input (concat [rx ry rot laf sw] b)}
        list
        (conj open)
        vec
        cmds->path-string
        path)))

(defn arc
  [a ctr deg]
  (let [r (utils/distance a ctr)
        angle 0
        b (utils/rotate-pt-around-center a deg ctr)
        laf (if (<= deg 180) 0 1)]
     (build-arc r r angle laf 1 a b)))

(defn circle-path
  [r]
  (let [open (pt->m [r 0])
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> [open
         {:command "A"
          :coordsys :abs
          :input [r r 0 1 0 (- r) 0]}
         {:command "A"
          :coordsys :abs
          :input [r r 0 1 0 r 0]}
         close]
        cmds->path-string
        path)))

(defn ellipse-path
  [rx ry]
  (let [open (pt->m [rx 0])
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> [open
         {:command "A"
          :coordsys :abs
          :input [rx ry 0 1 0 (- rx) 0]}
         {:command "A"
          :coordsys :abs
          :input [rx ry 0 1 0 rx 0]}
         close]
        cmds->path-string
        path)))

#+END_SRC

*** spec
#+begin_src clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef polygon-path
  :args (s/cat :pts ::pts)
  :ret ::path-element)
#+END_SRC
* transforms
Computations refer to calculatable properties of svg elements. They are bounds and centroid.

Transforms are translate, rotate, and scale. All transforms work well for most objects (:g and :text are exceptions). They all transform about the object's center point. This has the effect of 'local first' transformation.

This leads to challenges with groups. Groups must have their centroid calculated such that rotation and translation can correctly occur about the group's centroid. Internally, this means that the group's centroid is treated as the 'temporary global origin' and all objects are globally rotated about that temp. origin. This has the appearance of a group rotating locally, which is the intended outcome.

So, I either should fix the interface fn or eliminate it entirely.

** ns
#+begin_src clojure :tangle ./src/svg_clj/transforms.cljc
(ns svg-clj.transforms
   (:require [clojure.string :as str]
             [svg-clj.utils :as utils]
             [svg-clj.path :as path]))

#+end_src

** calcs
For transforms, it is necessary to extract basic point data from commands. In general, all commands have simple point data. The exception is arcs, which need some calculation.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti command->pts :command)

(defmethod command->pts :default
  [{:keys [input]}]
  (mapv vec (partition 2 input)))

;; this is not implemented correctly yet.
;; just a 'stub' returning the end point of the arc
(defmethod command->pts "A"
  [{:keys [input cursor]}]
  (let [[rx ry deg laf sw x y] input
        b [x y]
        #_ctr #_[(- x (* (Math/cos (utils/to-rad deg)) rx))
             (- y (* (Math/sin (utils/to-rad deg)) rx))]
        ctr (utils/v+ cursor [rx 0])
        sa (utils/angle-from-pts cursor ctr b)
        angle (if (= 1 laf) (- 360 sa) sa)
        mids (mapv #(utils/rotate-pt-around-center cursor % ctr) (rest (range 0 angle 90)))]
    (conj mids b)))

#+END_SRC

** style
Style transforms allow the user to change any attributes of svg elements that affect appearance. For instance, stroke color, stroke width, and fill.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn style
  [[k props & content] style-map]
  (into [k (merge props style-map)] content))

#+END_SRC

** centroid
*** centroid-elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn centroid-of-pts
  "Calculates the arithmetic mean position of the given `pts`."
  [pts]
  (let [ndim (count (first (sort-by count pts)))
        splits (for [axis (range 0 ndim)]
                 (map #(nth % axis) pts))]
    (mapv #(apply utils/average %) splits)))

(defmulti centroid
  (fn [element]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod centroid :list
  [elems]
  (centroid-of-pts (into #{} (map centroid elems))))

(defmethod centroid :circle
  [[_ props]]
  [(:cx props) (:cy props)])  

(defmethod centroid :ellipse
  [[_ props]]
  [(:cx props) (:cy props)])

(defmethod centroid :line
  [[_ props]]
  (let [a (mapv #(get props %) [:x1 :y1])
        b (mapv #(get props %) [:x2 :y2])]
    (centroid-of-pts [a b])))

(defmethod centroid :polygon
  [[_ props]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))]
    (centroid-of-pts pts)))

(defmethod centroid :polyline
  [[_ props]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))]
    (centroid-of-pts pts)))

(defmethod centroid :rect
  [[_ props]]
  [(+ (:x props) (/ (:width  props) 2.0))
   (+ (:y props) (/ (:height props) 2.0))])

(defmethod centroid :image
  [[_ props]]
  [(+ (:x props) (/ (:width  props) 2.0))
   (+ (:y props) (/ (:height props) 2.0))])

;; this is not done yet. Text in general needs a redo.
(defmethod centroid :text
  [[_ props text]]
  [(:x props) (:y props)])
#+END_SRC

**** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef centroid-of-pts
  :args (s/cat :pts ::pts)
  :ret ::pt2d)
#+END_SRC

*** centroid-path
The first idea for calculating path centroid is to get all point data from every command, mapcat them together, and just run centroid-of-pts on that list of points.

I don't know yet if the 'easy' method will be accurate for paths that contain curves and arcs. It is possible that the centroid calculated by pts/control points is not accurate.

Ideas to keep in mind:
- parametric bezier curve, sample t and regular interval to build a polyline approximating the curve, and calculate centroid from those pts
- tessellate the whole path and get centroids of every triangle, then centroid of centroids... should be ok

#+begin_src clojure :tangle ./src/svg_clj/transforms.cljc
(defmethod centroid :path
  [[_ props]]
  (let [cmds (path/path-string->commands (:d props))
        pts (mapcat command->pts cmds)]
    (centroid-of-pts (vec (into #{} pts)))))
#+end_src

*** centroid-group
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(declare centroid)
(defmethod centroid :g
  [[_ props & content]]
  (centroid-of-pts (into #{} (map centroid content))))

#+END_SRC

**** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef centroid
  :args (s/or :one (s/coll-of ::svg-element)
              :many (s/coll-of (s/+ ::svg-element)))
  :ret ::pt2d)
#+END_SRC
** bounds
*** bounds-elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn bounds-of-pts
  [pts]
  (let [xmax (apply max (map first pts))
        ymax (apply max (map second pts))
        xmin (apply min (map first pts))
        ymin (apply min (map second pts))]
    (vector [xmin ymin]
            [xmax ymin]
            [xmax ymax]
            [xmin ymax])))

(defmulti bounds
  (fn [element]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod bounds :list
  [elems]
  (bounds-of-pts (mapcat bounds elems)))

(defmethod bounds :circle
  [[_ props]]
  (let [c [(:cx props) (:cy props)]
        r (:r props)
        pts (mapv #(utils/v+ c %) [[r 0]
                             [0 r]
                             [(- r) 0]
                             [0 (- r)]])]
    (bounds-of-pts pts)))

(defmethod bounds :ellipse
  [[_ props]]
  (let [xf (utils/str->xf-map  (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        c [(:cx props) (:cy props)]
        rx (:rx props)
        ry (:ry props)
        pts (mapv #(utils/v+ c %) [[rx 0]
                                   [0 ry] 
                                   [(- rx) 0]
                                   [0 (- ry)]])
        bb (bounds-of-pts pts)
        obb (mapv #(utils/rotate-pt-around-center % deg [mx my]) bb)
        xpts (mapv #(utils/rotate-pt-around-center % deg [mx my]) pts)
        small-bb (bounds-of-pts xpts)
        large-bb (bounds-of-pts obb)]
    ;; not accurate, but good enough for now
    ;; take the bb to be the average between the small and large
    (bounds-of-pts (mapv #(centroid-of-pts [%1 %2]) small-bb large-bb))))

(defmethod bounds :line
  [[_ props]]
  (let [a (mapv #(get props %) [:x1 :y1])
        b (mapv #(get props %) [:x2 :y2])]
    (bounds-of-pts [a b])))

(defmethod bounds :polygon
  [[_ props]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))]
    (bounds-of-pts pts)))

(defmethod bounds :polyline
  [[_ props]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))]
    (bounds-of-pts pts)))

(defmethod bounds :rect
  [[_ props]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        x (:x props)
        y (:y props)
        w (:width props)
        h (:height props)
        pts [[x y]
             [(+ x w) y]
             [(+ x w) (+ y h)]
             [x (+ y h)]]
        xpts (mapv #(utils/rotate-pt-around-center % deg [mx my]) pts)]
    (bounds-of-pts xpts)))

(defmethod bounds :image
  [[_ props]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        x (:x props)
        y (:y props)
        w (:width props)
        h (:height props)
        pts [[x y]
             [(+ x w) y]
             [(+ x w) (+ y h)]
             [x (+ y h)]]
        xpts (mapv #(utils/rotate-pt-around-center % deg [mx my]) pts)]
    (bounds-of-pts xpts)))

;; this is not done yet. Text in general needs a redo.
(defmethod bounds :text
  [[_ props text]]
  [[(:x props) (:y props)]])

#+END_SRC

*** bounds-path
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmethod bounds :path
  [[_ props]]
  (let [cmds (path/path-string->commands (:d props))
        pts (mapcat command->pts cmds)]
    (bounds-of-pts pts)))

#+END_SRC

*** bounds-group
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(declare bounds)
(defmethod bounds :g
  [[_ props & content]]
  (bounds-of-pts (mapcat bounds content)))

#+END_SRC

**** spec
#+BEGIN_SRC clojure :tangle ./src/svg_clj/specs.cljc
(s/fdef bounds
  :args (s/cat :elems (s/coll-of ::svg-element))
  :ret ::bounds)
#+END_SRC
** translate
*** translate-elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn- get-props
  [props]
  (merge {:rotate [0 0 0]} (utils/str->xf-map (get props :transform))))

(defmulti translate
  (fn [element _]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod translate :list
  [elems [x y]]
  (map #(translate % [x y]) elems))

(defmethod translate :circle
  [[k props] [x y]]
  (let [xf (get-props props)
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate :ellipse
  [[k props] [x y]]
  (let [xf (get-props props)
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate :line
  [[k props] [x y]]
  (let [new-props (-> props
                      (update :x1 + x)
                      (update :y1 + y)
                      (update :x2 + x)
                      (update :y2 + y))]
    [k new-props]))

(defmethod translate :polygon
  [[k props] [x y]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))
        xpts (->> pts 
                  (map (partial utils/v+ [x y]))
                  (map utils/v->s))]
    [k (assoc props :points (str/join " " xpts))]))

(defmethod translate :polyline
  [[k props] [x y]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))
        xpts (->> pts 
                  (map (partial utils/v+ [x y]))
                  (map utils/v->s))]
    [k (assoc props :points (str/join " " xpts))]))

(defmethod translate :rect
  [[k props] [x y]]
  (let [[cx cy] (centroid [k props])
        xf (get-props props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ cx x))
                   (assoc-in [:rotate 2] (+ cy y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate :image
  [[k props] [x y]]
  (let [[cx cy] (centroid [k props])
        xf (get-props props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ cx x))
                   (assoc-in [:rotate 2] (+ cy y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate :text
  [[k props text] [x y]]
  (let [xf (get-props props)
        new-xf (-> xf
                   (update-in [:rotate 1] + x)
                   (update-in [:rotate 2] + y))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props text]))

#+END_SRC

*** translate-path
To complete the translate implementation, I have to make sure path elements can be propery handled.

To do this, I have a second multimethod to handle different commands that can show up in a path string. Command data structures are produced using the path-dsl functions defined earlier.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti translate-path-command
  (fn [cmd _]
    (:command cmd)))

(defmethod translate-path-command "M"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

(defmethod translate-path-command "L"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

(defmethod translate-path-command "H"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x] input)))

(defmethod translate-path-command "V"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [y] input)))

;; x y x y x y because input will ahve the form:
;; [x1 y1 x2 y2 x y] (first two pairs are control points)
(defmethod translate-path-command "C"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y x y] input)))

;; similar approach to above, but one control point is implicit
(defmethod translate-path-command "S"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y] input)))

(defmethod translate-path-command "Q"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y] input)))

(defmethod translate-path-command "T"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod translate-path-command "A"
  [{:keys [:input] :as m} [x y]]
  (let [[rx ry xrot laf swf ox oy] input]
    (assoc m :input [rx ry xrot laf swf (+ x ox) (+ y oy)])))

(defmethod translate-path-command "Z"
  [cmd _]
  cmd)

(defmethod translate-path-command :default
  [cmd a]
  [cmd a])

(defmethod translate :path
  [[k props] [x y]]
  (let [cmds (path/path-string->commands (:d props))
        xcmds (map #(translate-path-command % [x y]) cmds)]
    [k (assoc props :d (path/cmds->path-string xcmds))]))

#+END_SRC

*** translate-group
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
#_(declare translate)
(defmethod translate :g
  [[k props & content] [x y]]
  (->> content
       (map #(translate % [x y]))
       (filter (complement nil?))
       (into [k props])))

#+END_SRC

** rotate
*** rotate-elements
Rotate-element-by-transform leaves 'nil' for content. I filtered that out, but I suspect there's a cleaner way to do it.

Consider refactor at some point.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn rotate-element-by-transform
  [[k props content] deg]
  (let [xf (get-props props)
        new-xf (-> xf
                   (update-in [:rotate 0] + deg))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    (vec (filter (complement nil?) [k new-props (when content content)]))))

(defmulti rotate
  (fn [element _]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod rotate :list
  [elems deg]
  (map #(rotate % deg) elems))

(defmethod rotate :circle
  [[k props] deg]
  (rotate-element-by-transform [k props] deg))

(defmethod rotate :ellipse
  [[k props] deg]
  (rotate-element-by-transform [k props] deg))

(defmethod rotate :line
  [[k props] deg]
  (let [pts [[(:x1 props) (:y1 props)] [(:x2 props) (:y2 props)]]
        [[x1 y1] [x2 y2]]  (->> pts
                                (map #(utils/v- % (centroid-of-pts pts)))
                                (map #(utils/rotate-pt % deg))
                                (map #(utils/v+ % (centroid-of-pts pts))))
        new-props (assoc props :x1 x1 :y1 y1 :x2 x2 :y2 y2)]
    [k new-props]))

(defmethod rotate :polygon
  [[k props] deg]
  (let [ctr (centroid [k props])
        pts (mapv utils/s->v (str/split (:points props) #" "))
        xpts (->> pts
                  (map #(utils/v- % ctr))
                  (map #(utils/rotate-pt % deg))
                  (map #(utils/v+ % ctr))
                  (map utils/v->s))
        xprops (assoc props :points (str/join " " xpts))]
    [k xprops]))

(defmethod rotate :polyline
  [[k props] deg]
  (let [ctr (centroid [k props])
        pts (mapv utils/s->v (str/split (:points props) #" "))
        xpts (->> pts
                  (map #(utils/v- % ctr))
                  (map #(utils/rotate-pt % deg))
                  (map #(utils/v+ % ctr))
                  (map utils/v->s))
        xprops (assoc props :points (str/join " " xpts))]
    [k xprops]))

(defmethod rotate :rect
  [[k props] deg]
  (let [[cx cy] (centroid [k props])
        xf (get-props props)
        new-xf (-> xf
                   (update-in [:rotate 0] + deg)
                   (assoc-in  [:rotate 1] cx)
                   (assoc-in  [:rotate 2] cy))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props]))

(defmethod rotate :image
  [[k props] deg]
  (let [[cx cy] (centroid [k props])
        xf (get-props props)
        new-xf (-> xf
                   (update-in [:rotate 0] + deg)
                   (assoc-in  [:rotate 1] cx)
                   (assoc-in  [:rotate 2] cy))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props]))

(defmethod rotate :text
  [[k props text] deg]
  (rotate-element-by-transform [k props text] deg))

#+END_SRC

*** rotate-path
To complete the translate implementation, I have to make sure path elements can be propery handled.

To do this, I have a second multimethod to handle different commands that can show up in a path string. Command data structures are produced using the path-dsl functions defined earlier.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti rotate-path-command
  (fn [cmd _ _]
    (:command cmd)))

(defmethod rotate-path-command "M"
  [{:keys [:input] :as m} ctr deg]
  (let [xpt (-> input
                (utils/v- ctr)
                (utils/rotate-pt deg)
                (utils/v+ ctr))]
    (assoc m :input xpt)))

(defmethod rotate-path-command "L"
  [{:keys [:input] :as m} ctr deg]
  (let [xpt (-> input
                (utils/v- ctr)
                (utils/rotate-pt deg)
                (utils/v+ ctr))]
    (assoc m :input xpt)))

(defmethod rotate-path-command "C"
  [{:keys [:input] :as m} ctr deg]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(utils/rotate-pt % deg))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "S"
  [{:keys [:input] :as m} ctr deg]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(utils/rotate-pt % deg))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "Q"
  [{:keys [:input] :as m} ctr deg]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(utils/rotate-pt % deg))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "T"
  [{:keys [:input] :as m} ctr deg]
  (let [xpt (-> input
                (utils/v- ctr)
                (utils/rotate-pt deg)
                (utils/v+ ctr))]
    (assoc m :input xpt)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod rotate-path-command "A"
  [{:keys [:input] :as m} ctr deg]
  (let [[rx ry xrot laf swf ox oy] input
        [nx ny] (-> [ox oy]
                    (utils/v- ctr)
                    (utils/rotate-pt deg)
                    (utils/v+ ctr))]
    (assoc m :input [rx ry (+ xrot deg) laf swf nx ny])))

(defmethod rotate-path-command "Z"
  [cmd _ _]
  cmd)

(defmethod rotate :path
  [[k props] deg]
  (let [ctr (centroid [k props])
        cmds (path/path-string->commands (:d props))
        xcmds (map #(rotate-path-command % ctr deg) cmds)]
    [k (assoc props :d (path/cmds->path-string xcmds))]))

#+END_SRC

*** rotate-group
If I let the rotate 'pass through' a group, it rotates every child element locally. This has the effect of ignoring grouped elements that you do want to rotate about the group's center.

Each child of a group must be rotated around the group's midpoint.
So,
- find group midpoint
- apply rotation to children about group midpoint
  - rotate child by deg
  - translate child to new center (rotate its orig midpoint about group midpoint to find new position)

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmethod rotate :g
  [[k props & content] deg]
  (let [[gcx gcy] (centroid-of-pts (bounds (into [k props] content)))
        xfcontent (for [child content]
                    (let [ch (translate child [(- gcx) (- gcy)])
                          ctr (if (= :g (first ch))
                                (centroid-of-pts (bounds ch))
                                (centroid ch))
                          xfm (-> ctr
                                  (utils/rotate-pt deg)
                                  (utils/v+ [gcx gcy]))]
                      (-> ch
                          (translate (utils/v* [-1 -1] ctr))
                          (rotate deg)
                          (translate xfm))))]
    (into [k props] (filter (complement nil?) xfcontent))))

#+END_SRC

** scale
Scale implementation doesn't seem to work correctly in all cases. For example, scaling something down and translating a group containing it will shift it, which is undesired behaviour.

Scale should be 'baked into' all dimensions just like other transforms, where possible.

*** scale
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn scale-by-transform
  [[k props & content] [sx sy]]
  (let [xf (utils/str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props] content))

(defmulti scale
  (fn [element _]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod scale :list
  [elems [sx sy]]
  (map #(scale [sx sy] %) elems))

;; transforms are applied directly to the properties of shapes.
;; I have scale working the same way. One issue is that scaling a circle
;; turns it into an ellipse. This impl WILL change the shape to ellipse if non-uniform scaling is applied.

(defmethod scale :circle
  [[k props] [sx sy]]
  (let [circle? (= sx sy)
        r (:r props)
        new-props (if circle?
                    (assoc props :r (* r sx))
                    (-> props
                        (dissoc :r)
                        (assoc :rx (* sx r))
                        (assoc :ry (* sy r))))
        k (if circle? :circle :ellipse)]
    [k new-props]))

(defmethod scale :ellipse
  [[k props] [sx sy]]
  (let [new-props (-> props
                      (update :rx #(* sx %))
                      (update :ry #(* sy %)))]
    [k new-props]))

;; find bounding box center
;; translate bb-center to 0 0
;; scale all x y values by * [sx sy]
;; translate back to original bb-center

(defmethod scale :line
  [[k props] [sx sy]]
  (let [[cx cy] (centroid [k props])
        new-props (-> props
                      (update :x1 #(+ (* (- % cx) sx) cx))
                      (update :y1 #(+ (* (- % cy) sy) cy))
                      (update :x2 #(+ (* (- % cx) sx) cx))
                      (update :y2 #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defn scale-pt-from-center
  [[cx cy] [sx sy] [x y]]
  [(+ (* (- x cx) sx) cx)
   (+ (* (- y cy) sy) cy)])

(defmethod scale :polygon
  [[k props] [sx sy]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))
        ctr (centroid [k props])
        xpts (->> pts
                  (map (partial scale-pt-from-center ctr [sx sy]))
                  (map utils/v->s))]
    [k (assoc props :points (str/join " " xpts))]))

(defmethod scale :polyline
  [[k props] [sx sy]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))
        ctr (centroid [k props])
        xpts (->> pts
                  (map (partial scale-pt-from-center ctr [sx sy]))
                  (map utils/v->s))]
    [k (assoc props :points (str/join " " xpts))]))

(defmethod scale :rect
  [[k props] [sx sy]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale :image
  [[k props] [sx sy]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale :text
  [[k props text] [sx sy]]
  (let [xf (get-props props)
        cx (get-in xf [:rotate 1])
        cy (get-in xf [:rotate 2])
        x (+ (* (- (:x props) cx) sx) cx)
        y (+ (* (- (:y props) cy) sy) cy)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (- x))
                   (assoc-in [:rotate 2] (- y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (assoc :x x)
                      (assoc :y y)
                      (update-in [:style :font-size] #(* % sx)))]
    [k new-props text]))

(defmethod scale :g
  [[k props & content] [sx sy]]
  (let [xf (utils/str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    (into [k new-props] content)))

#+END_SRC

*** scale-path
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti scale-path-command
  (fn [cmd _ _]
    (:command cmd)))

(defmethod scale-path-command :default
  [{:keys [:input] :as m} ctr [sx sy]]
  (let [pts (mapv vec (partition 2 input))
        xpts (->> pts
                  (mapcat (partial scale-pt-from-center ctr [sx sy])))]
    (assoc m :input (vec xpts))))

;; this is wrong. just a stub to get moving a bit
(defmethod scale-path-command "A"
  [{:keys [:input] :as m} ctr [sx sy]]
  (let [pts [(take-last 2 input)]
        xpts (->> pts
                  (mapcat (partial scale-pt-from-center ctr [sx sy])))]
    (assoc m :input (vec xpts))))

(defmethod scale :path
  [[k props] [sx sy]]
  (let [ctr (centroid [k props])
        cmds (path/path-string->commands (:d props))
        xcmds (map #(scale-path-command ctr % [sx sy]) cmds)]
    [k (assoc props :d (path/cmds->path-string xcmds))]))

#+END_SRC

* tools
** ns
#+begin_src clojure :tangle ./src/svg_clj/tools.clj
(ns svg-clj.tools
  (:require [clojure.string :as str]
            [clojure.java.shell :refer [sh]]
            [clojure.data.xml :as xml]
            [hiccup.core :refer [html]]
            [hawk.core :as hawk]
            [svg-clj.elements :as svg]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [batik.rasterize :as b]
            [svg-clj.utils :as utils]))

#+end_src

** png!
#+begin_src clojure :tangle ./src/svg_clj/tools.clj
(defn sh-png! [svg-data fname]
  (sh "convert" "-background" "none" "/dev/stdin" fname
      :in (html svg-data)))

(defn png! [svg-data fname]
  (b/render-svg-string (html svg-data) fname))

#+end_src

** show
The cider-show fn works with Batik. It lets you quickly view SVG elements in a CIDER REPL.

To get similar results from a clojurescript context, it might be possible to use a serialize->rasterize approach as shown here:

[[https://observablehq.com/@mbostock/saving-svg]]

To get it working in CIDER, you have to enable content types.

~M-x cider-repl-toggle-content-types~

#+begin_src clojure :tangle ./src/svg_clj/tools.clj
(defn cider-show
  [svg-data]
  (let [fname "_imgtmp.png"
        data (if (= (first svg-data) :svg)
               svg-data
               (svg/svg svg-data))]
    (do (png! data fname)
        (clojure.java.io/file fname))))

#+end_src

** watcher
Build tests to make sure the design watcher works. It may be wise to build a nicer interface with clojure/tools.cli

#+begin_src clojure :tangle ./src/svg_clj/tools.clj
(defn watch!
  [fname]
  (let [ [name ext] (str/split fname #"\.")]
    (hawk/watch!
     [{:paths [fname]
       :handler
       (fn [ctx e]
         (require '[svg-clj.elements :refer :all]
                  '[svg-clj.transforms :refer :all]
                  '[svg-clj.path :refer :all]
                  '[hiccup.core :refer [html]])
         (->> (slurp fname)
              (format "[%s]")
              load-string
              (filter (complement var?))
              html
              (spit (str name ".html")))
         ctx)}])))

#+end_src

** loader
The xml parse/transform technique comes from:

[[https://github.com/babashka/babashka/blob/master/examples/portal.clj]]

#+BEGIN_SRC clojure :tangle ./src/svg_clj/tools.clj
(defn xml->hiccup [xml]
  (if-let [t (:tag xml)]
    (let [elt [t]
          elt (if-let [attrs (:attrs xml)]
                (conj elt attrs)
                elt)]
      (into elt (map xml->hiccup (:content xml))))
    xml))

(defn svg-str->elements
  [svg-str]
  (-> svg-str
      (xml/parse-str :namespace-aware false)
      xml->hiccup))

(defn save-svg
  [svg-data fname]
  (let [data (if (= (first svg-data) :svg)
               svg-data
               (svg/svg svg-data))]
    (spit fname (html data))))

(defn load-svg
  [fname]
  (-> fname
      slurp
      svg-str->elements))

#+END_SRC

* tests
Create more tests. Try to use a bit of TDD to help improve implementations, starting with better transform functions.

** test-ns
#+BEGIN_SRC clojure :tangle ./test/svg_clj/main_test.cljc
(ns svg-clj.main-test
  (:require 
   [svg-clj.elements :as svg
    :refer [circle
            ellipse
            g
            image
            line
            polygon
            polyline
            rect
            svg
            text]]
   [svg-clj.transforms :as tf
    :refer [translate
            rotate
            centroid
            bounds
            scale
            style]]
   [svg-clj.path :as p
    :refer [polygon-path]]
   [clojure.test
    :refer [deftest is]]))

#+END_SRC

** shapes
#+begin_src clojure :tangle ./test/svg_clj/main_test.cljc
;; just starting with some basics. 
;; more complete tests coming soon

(def test-circle (circle 5))
(def test-ellipse (ellipse 5 10))
(def test-line (line [0 0] [10 20]))
(def test-path (polygon-path [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-polygon (polygon [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-polyline (polyline [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-rect (rect 60 30))
(def test-image (image "https://www.fillmurray.com/g/200/300" 200 300))
(def test-g (g test-circle
               test-ellipse
               test-line
               test-path
               test-polygon
               test-polyline
               test-rect
               test-image))

(def test-shapes [test-circle
                  test-ellipse
                  test-line
                  test-path
                  test-polygon
                  test-polyline
                  test-rect
                  test-image])

(deftest basic-shapes-test
  (is (= test-circle [:circle {:cx 0 :cy 0 :r 5}]))
  (is (= test-ellipse [:ellipse {:cx 0 :cy 0 :rx 5 :ry 10}]))
  (is (= test-line [:line {:x1 0 :y1 0 :x2 10 :y2 20}]))
  (is (= test-path [:path {:d "M0 0 L10 20 L40 50 L20 10 Z"
                           :fill-rule "evenodd"}]))
  (is (= test-polygon [:polygon {:points "0,0 10,20 40,50 20,10"}]))
  (is (= test-polyline [:polyline {:points "0,0 10,20 40,50 20,10"}]))
  (is (= test-rect [:rect {:x -30.0 :y -15.0 :width 60 :height 30}]))
  (is (= test-image [:image 
                     {:href "https://www.fillmurray.com/g/200/300"
                      :x -100.0 :y -150.0 
                      :width 200 :height 300}])))
#+end_src

** translate
#+begin_src clojure :tangle ./test/svg_clj/main_test.cljc
(deftest basic-translate-test
  (is (= (-> test-circle (translate [10 10]))
         [:circle {:r 5 :cx 10 :cy 10 :transform "rotate(0 10 10)"}]))
  (is (= (-> test-ellipse (translate [10 10]))
         [:ellipse {:rx 5 :ry 10 :cx 10 :cy 10 :transform "rotate(0 10 10)"}]))
  (is (= (-> test-line (translate [10 10]))
         [:line {:x1 10 :y1 10 :x2 20 :y2 30}]))
  (is (= (-> test-path (translate [10 10]))
         [:path {:d "M10 10 L20 30 L50 60 L30 20 Z"
                 :fill-rule "evenodd"}]))
  (is (= (-> test-polygon (translate [10 10]))
         [:polygon {:points "10,10 20,30 50,60 30,20"}]))
  (is (= (-> test-polyline (translate [10 10]))
         [:polyline {:points "10,10 20,30 50,60 30,20"}]))
  (is (= (-> test-rect (translate [10 10]))
         [:rect {:x -20.0 :y -5.0 :width 60 :height 30 :transform "rotate(0 10.0 10.0)"}]))
  (is (= (-> test-image (translate [10 10]))
         [:image {:href "https://www.fillmurray.com/g/200/300"
                  :x -90.0 :y -140.0
                  :width 200 :height 300
                  :transform "rotate(0 10.0 10.0)"}])))

(deftest translate-group-test
  (is (= (drop 2 (translate test-g [5 10]))
         (map #(translate % [5 10]) (drop 2 test-g)))))

(deftest translate-list-test
  (let [a (repeat 10 (rect 10 20))]
    (is (= (translate a [5 10])
           (map #(translate % [5 10]) a)))))
#+end_src

** rotate
#+begin_src clojure :tangle ./test/svg_clj/main_test.cljc
(deftest basic-rotate-test
  (is (= (-> test-circle (rotate 45))
         [:circle {:r 5 :cx 0 :cy 0 :transform "rotate(45 0 0)"}]))
  (is (= (-> test-ellipse (rotate 45))
         [:ellipse {:rx 5 :ry 10 :cx 0 :cy 0 :transform "rotate(45 0 0)"}]))
  (is (= (-> test-line (rotate 90))
         [:line {:x1 15.0 :y1 4.999999999999999 :x2 -5.0 :y2 15.0}]))
  (is (= (-> test-path (rotate 90))
         [:path {:d "M37.5 2.5 L17.5 12.5 L-12.5 42.5 L27.5 22.5 Z"
                 :fill-rule "evenodd"}]))
  (is (= (-> test-polygon (rotate 90))
         [:polygon {:points "37.5,2.5 17.5,12.5 -12.5,42.5 27.5,22.5"}]))
  (is (= (-> test-polyline (rotate 90))
         [:polyline {:points "37.5,2.5 17.5,12.5 -12.5,42.5 27.5,22.5"}]))
  (is (= (-> test-rect (rotate 45))
         [:rect {:x -30.0 :y -15.0 :width 60 :height 30 :transform "rotate(45 0.0 0.0)"}]))
  (is (= (-> test-image (rotate 45))
         [:image {:href "https://www.fillmurray.com/g/200/300"
                  :x -100.0 :y -150.0
                  :width 200 :height 300
                  :transform "rotate(45 0.0 0.0)"}])))

(def rotated-test-g-data-structure
  [:g
   {}
   [:circle {:cx 0.0 :cy 0.0 :r 5 :transform "rotate(90 0.0 0.0)"}]
   [:ellipse {:cx 0.0 :cy 0.0 :rx 5 :ry 10 :transform "rotate(90 0.0 0.0)"}]
   [:line {:x1 0.0 :y1 0.0 :x2 -20.0 :y2 10.000000000000002}]
   [:path
    {:d "M0.0 0.0 L-20.0 10.0 L-50.0 40.0 L-10.0 20.0 Z" :fill-rule "evenodd"}]
   [:polygon {:points "0.0,0.0 -20.0,10.0 -50.0,40.0 -10.0,20.0"}]
   [:polyline {:points "0.0,0.0 -20.0,10.0 -50.0,40.0 -10.0,20.0"}]
   [:rect
    {:width 60 :height 30 :x -30.0 :y -15.0 :transform "rotate(90 0.0 0.0)"}]
   [:image
    {:href "https://www.fillmurray.com/g/200/300"
     :width 200
     :height 300
     :x -100.0
     :y -150.0
     :transform "rotate(90 0.0 0.0)"}]])


(deftest rotate-group-test
  (is (not= (drop 2 (rotate test-g 45))
            (map #(rotate % 45) (drop 2 test-g))))
  (is (= (rotate test-g 90)
         rotated-test-g-data-structure)))

(deftest rotate-list-test
  (let [a (repeat 10 (rect 10 20))]
    (is (= (rotate a 45)
           (map #(rotate % 45) a)))))

#+end_src
* examples
This is a WIP file for a more complex drawing to be used in tests. This will use all transforms, all shapes, etc.

#+begin_src clojure :tangle ./examples/basics.cljc
(ns examples.basics
  (:require [clojure.string :as str]
            [clojure.java.shell :refer [sh]]
            [hiccup.core :refer [html]]
            [svg-clj.utils :as utils]
            [svg-clj.path :as path
             :refer [path
                     merge-paths
                     circle-path
                     line-path
                     rect-path
                     polyline-path
                     polygon-path
                     bezier
                     arc]]
            [svg-clj.transforms
             :refer [centroid
                     bounds
                     translate
                     rotate
                     scale
                     style]]
            [svg-clj.elements
             :refer [svg
                     circle
                     ellipse
                     rect
                     line
                     polygon
                     polyline
                     text
                     g
                     image]]))

(defn show-debug-geom
  [elem]
  (let [ctr (centroid elem)
        bds (bounds elem)]
    (g elem
       (g (-> (polygon bds)
               (style {:fill "none"
                       :stroke "red"
                       :stroke-width "3px"}))
          (-> (circle 2)
               (translate ctr)
               (style {:fill "red"}))))))

(def a (g (-> (circle 50)
              (translate [100 100])
              (style {:fill "pink"
                      :stroke-width "5px"
                      :stroke "hotpink"}))
          (-> (circle 10)
              (translate [15 15])
              (style {:fill "pink"
                      :stroke-width "5px"
                      :stroke "hotpink"}))))

(def basic-group
  (g
   (rect 20 20)
   (-> (rect 20 20) (translate [20 0]))
   (-> (rect 20 20) (translate [0 20]))
   (-> (rect 20 20) (translate [20 20]))))

(def circles
  (-> (g (for [a (range 0 12)]
           (-> (circle (+ 5 (* a 4)))
               (translate [(/ (+ 5 (* a 4)) 2) 0])
               (translate (utils/rotate-pt [20 0] (* a -40)))
               (style {:stroke 
                       (str "rgba(163,190,140," 
                            (/ (inc a) 10.0) ")")
                       :stroke-width "2px"
                       :fill "none"}))))
      (translate [100 100])
      (svg 200 200)))

#+end_src


NOTE: suggestion from GreenCoder regarding bezier

fn that appends to existing bezier

(bezier-append pt)

#+begin_src clojure :tangle ./examples/basics.cljc
(def basics [(arc [0 0] [50 0] 90)
             (circle-path 40)
             (bezier [0 0] [30 20] [80 40] [120 180])
             (circle 80)
             (rect-path 70 120)
             (ellipse 40 80)
             (line [0 0] [100 100])
             (line-path [0 0] [100 100])
             (polygon [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (polyline [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (polygon-path [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (text "this is text")
             (image "https://www.fillmurray.com/300/200" 100 67)
             (merge-paths (rect-path 100 100) (rect-path 80 80))
             basic-group])

(def doc
  (->>
   (for [elem basics]
     (-> elem
         (translate [80 80])
         (rotate 20)
         (style {:fill "pink"
                 :stroke-width "2px"
                 :stroke "hotpink"})
         show-debug-geom
         (svg 200 200)
         (style {:style {:outline "1px solid blue"
                         :margin "10px"}})))
   (partition-all 3)
   (interpose [:br])))

(spit 
 "examples/basics.html"
 (html 
  [:html 
   [:body
    [:h1 "Basic Geometry Examples"]
    doc
    #_circles]]))

#+end_src
