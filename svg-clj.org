* ;;
#+Title: svg-clj
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: excl
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:deps 
 {org.clojure/clojure       {:mvn/version "1.10.1"}
  org.clojure/clojurescript {:mvn/version "1.10.597"}
  org.clojure/spec.alpha    {:mvn/version "0.2.187"}
  org.clojure/test.check    {:mvn/version "1.1.0"}
  hiccup                    {:mvn/version "2.0.0-alpha2"}}}

#+end_src

** readme
#+BEGIN_SRC markdown :tangle ./readme.md
# svg-clj

A simple DSL for SVG in Clojure/clojurescript.

This is currently a work in progress. Until a stable release is provided, this library is considered to be in a 'prototype' state. Breaking changes are possible until a proper release is acheived.

If you would like to understand my motivations, decisions, and reasoning for the choices I've made in this library, you can read the .org file in the top level of this repo.

[svg-clj.org](https://github.com/adam-james-v/svg-clj/blob/main/svg-clj.org).

#+END_SRC

* admin
** todo
Some tasks that need to be done on this project.
*** TODO [] fix svg fn to properly handle incorrect args (eg. missing [w h sc]
*** TODO [] build a mechanism for changing rotate behavior from local to global -> probably use *dynamic-var* 
*** TODO [] build a mechanism for changing transform 'baking' behavior
*** TODO [] remove forge dependency
*** TODO [] create an aliases namespace for short-form re-defs eg. (def tr svg/translate)
*** TODO [] make centroid only work on sets of pts of same dimension
*** TODO [] make centroid more readable. Maybe juxt?s


** roadmap
Some features that are planned for implementation.

* design
** intent
The purpose of this library is to allow users to create simple functional programs that compile to SVG elements. 

The expected kinds of input are .clj files with svg-clj code, STDIN with svg-clj code. The expected output is hiccup-style clojure data structures, and optionally a compiled SVG string to file or STDOUT.

Basically, this is just a library, but I will add a small CLI interface and create a binary distribution so that the library can stand alone as a small utility, perhaps as a useful tool in a bash scripting pipeline.

** structure
The library uses hiccup syntax to represent the SVG diagrams being created. The user writes functional code to define various elements of the SVG and has access to transformations via utility functions.

Since the library functions emit hiccup data structures, the user can extend and manipulate their data using other clojure libraries or their own approaches. 

The library has two 'groups' of functions:

- elements
  - container elements (svg, figure...)
  - composites (custom functions using shapes.. eg. arrow)
  - shapes
    - circle
    - ellipse
    - line
    - path
    - polygon
    - polyline
    - rect
  - text
  - g
  - animation (maybe in future)

- transforms
  - rotate
  - translate
  - scale
  - style

There are utility type functions as well
- geometric utilities (midpoint, bounds)
- data manipulation utilities

** opinionated-approach
This is not quite a straight wrapper for SVG functionality. I have altered the default behavior of some functions.

For example, a rectangle is drawn centered around the orgin by default. Plain SVG rectangles draw with the first corner located at the origin by default.

All rotations are applied to shapes locally by default. This means that a circle at [10 0] rotated by 90 deg will not appear to move using svg-clj; the shape itself is being spun around it's center, but that center point is not moving. Default SVG behaviour rotates around the origin by default. So, any elements offset from the orgin will move large distances away from their starting positions. This choice was made because it feels more intuitive to draw with local transformation operations in mind.

As much as possible, all transformation calculations are 'baked' into shape coordinates and points directly. This means that a [10 20] rectangle that gets translated by [100 100] will be rendered to SVG as follows:

#+begin_src clojure
(comment 
  (translate [100 100] (rect 10 20))
  ;; => [:rect {:width 10, :height 20, :x 95.0, :y 90.0, :transform "rotate(0 100.0 100.0)"}]
  (def a *1)
  (html a)
  ;; => "<rect height=\"20\" transform=\"rotate(0 100.0 100.0)\" width=\"10\" x=\"95.0\" y=\"90.0\"></rect>"
)
#+end_src

* test
#+BEGIN_SRC clojure :tangle ./test/svg_clj/main_test.cljc
(ns svg-clj.main-test
  (:require [svg-clj.main :as svg]
            [clojure.test :refer [deftest is]]))

#+END_SRC

* ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(ns svg-clj.main
  (:require [clojure.string :as st]
            [hiccup.core :refer [html]]
            [clojure.test :as test :refer [deftest is]]
            #?(:cljs 
               [cljs.reader :refer [read-string]])))

#+END_SRC

* container-elements
Any elements that wrap content. Primary function is svg which is the ~container~ element for all other SVG elements.

** svg
#+begin_src clojure :tangle ./src/svg_clj/main.cljc
(defn svg
  "This function wraps `content` in an SVG container element.
  The SVG container is parameterized by width `w`, height `h`, and scale `sc`."
  [[w h sc] & content]
  [:svg {:width  w
         :height h
         :viewBox (str "0 0 " w " " h)
         :xmlns "http://www.w3.org/2000/svg"}
   [:g {:transform (str "scale(" sc ")")} content]])

#+end_src

* utils
#+begin_src clojure :tangle ./src/svg_clj/main.cljc
(defn average
  [& numbers]
  (let [n (count numbers)]
    (/ (apply + numbers) n)))

;; what I used to call 'midpoint' is more accurately called centroid
(defn centroid
  "Calculates the arithmetic mean position of all the given `pts`."
  [pts]
  (let [ndim (count (first (sort-by count pts)))
        splits (for [axis (range 0 ndim)]
                 (map #(nth % axis) pts))]
    (mapv #(apply average %) splits)))

(defn v->s
  "Turns the vector `v` into a string formatted for use in SVG attributes."
  [pt]
  (apply str (interpose "," pt)))

(defn s->v
  "Turns a string of comma or space separated numbers into a vector."
  [s]
  (-> s
      (st/trim)
      (st/split #"[, ]")
      (#(mapv read-string %))))

(def v+ (partial mapv +))
(def v- (partial mapv -))
(def v* (partial mapv *))

#+end_src

* shapes
A shape is a hiccup data structure that represents one of the valild SVG elements.

All shape functions will return a vector of the following shape:

~[:tag {:props "value"} "content"]~

The tag and props will always exist, but content may or may not exist. For most geometric shape elements, there is no content. Elements like ~text~ and ~g~ do have content.

As a general term, I use 'element' to refer to the hiccup vector structure. So, ~[:circle {:r 2}]~ is an element as is ~[:p "some paragraph"]~. The vector ~[2 4]~ is not an element.

The term 'properties' (sometimes written 'props') refers to the map in the index 1 of a hiccup vector.

The term 'content' refers to the inner part of a hiccup data structure that is neither the key nor the properties. Content can be nil, length one, or many.

** shapes
#+begin_src clojure :tangle ./src/svg_clj/main.cljc
(def svg-elements
  "The elements provided by the library."
  #{:circle
    :ellipse
    :line
    :path
    :polygon
    :polyline
    :rect
    :text
    :g})

(defn element? 
  "Checks the key in an element to see if it is an SVG element."
  [[k props content]]
  (svg-elements k))

(defn circle
  [r]
  [:circle {:cx 0 :cy 0 :r r}])

(defn ellipse
  [rx ry]
  [:ellipse {:cx 0 :cy 0 :rx rx :ry ry}])

(defn line
  [[ax ay] [bx by]]
  [:line {:x1 ax :y1 ay :x2 bx :y2 by}])

(defn polygon
  [pts]
  [:polygon {:points (apply str (interpose " " (map v->s pts)))}])

(defn polyline
  [pts]
  [:polyline {:points (apply str (interpose " " (map v->s pts)))}])

(defn rect
  [w h]
  [:rect {:width w :height h :x (/ w -2.0) :y (/ h -2.0)}])

(defn g
  [& content]
  (if (and (= 1 (count content))
           (not (keyword? (first (first content)))))
    ;; content is a list of a list of elements
    (into [:g {}] (first content))
    ;; content is a single element OR a list of elements
    (into [:g {}] (filter (complement nil?) content))))

#+end_src

** text
Text is a bit different. It is much more complicated to know text's centroid and thus local rotation/translation methods for all other shapes don't easily apply. 

So, like path, text is treated as a very simple wrapper, but has (will have) its own functions for better control/manipulation of text elements.

In particular, you cannot know the exact width and height of a text element without being able to fully render the glyphs of the font. This is currently beyond the scope of the existing function below.

#+begin_src clojure :tangle ./src/svg_clj/main.cljc
(defn text
  [text]
  [:text {} text])

#+end_src

** path
The path element is more complicated as there is essentially a DSL for creating valid 'd' property strings. The 'd' property is a string that defines many different renderable paths using a tiny instruction set that works kind of like g-code or the turtle drawing program.

This path function is usable by the user but provides no path generation assistance. There are several functions defined later that handle path generation.

#+begin_src clojure :tangle ./src/svg_clj/main.cljc
(defn path
  [d]
  [:path {:d d
          :fill-rule "evenodd"}])

#+end_src
* path-dsl
The path element has a small DSL to create compound curves. This includes the following (taken from [[https://www.w3schools.com/graphics/svg_path.asp]]):

  M = moveto
  L = lineto
  H = horizontal lineto
  V = vertical lineto
  C = curveto
  S = smooth curveto
  Q = quadratic Bézier curve
  T = smooth quadratic Bézier curveto
  A = elliptical Arc
  Z = closepath

** path-impl
*** commands
Path strings are a sequence of commands. These commands can be thought of as moving a pen along the canvas to draw shapes/lines according to the command's inputs.

The order of these commands must be maintained, otherwise the shape will be drawn differently.

I'm going to make a few functions to split paths into commands and put them in a clojure map.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn path-command-strings
  "Split the path string `ps` into a vector of path command strings."
  [ps]
  (-> ps
      (st/replace #"\n" " ")
      (st/split #"(?=[A-Za-z])")
      (#(map st/trim %))))

(defn relative?
  "True if the path segment string `pss` has a relative coordinate command.
  Relative coordinate commands are lowercase.
  Absolute coordinate commands are uppercase."
  [cs]
  (let [csx (first (st/split cs #"[a-z]"))]
    (not (= cs csx))))

(defn coord-sys-key
  "Returns the command string `cs`'s coord. system key.
  Key is either :rel or :abs."
  [cs]
  (if (relative? cs) :rel :abs))

;; Probably want to revisit this approach.
;; the cond seems replaceable with just a simple MAP
;; OR consider not using this at all... jsut use the 
;; strings as their own keys directly.

(defn command-key
  "Returns the command string `cs`'s key."
  [cs]
  (let [s (st/upper-case cs)]
    (cond
      (st/includes? s "M") :move
      (st/includes? s "L") :line
      (st/includes? s "H") :hline
      (st/includes? s "V") :vline 
      (st/includes? s "C") :curve 
      (st/includes? s "S") :scurve
      (st/includes? s "Q") :quadratic
      (st/includes? s "T") :squadratic
      (st/includes? s "A") :arc
      (st/includes? s "Z") :close)))

(defn command-input
  [cs]
  (let [i (st/split cs #"[A-Za-z]")]
    (when (not (empty? (rest i)))
      (apply s->v (rest i)))))

(defn command
  "Transforms a command string `cs` into a map."
  [cs]
  {:command  (command-key cs)
   :coordsys (coord-sys-key cs)
   :input (command-input cs)})

(defn path-string->commands
  "Turns path string `ps` into a list of its command maps."
  [ps]
  (->> ps
       (path-command-strings)
       (map command)))

#+END_SRC

*** converting-vh
Given a list of commands, go until you find a V or H with a NON V NON H command preceding it.

Use the previous command to get the missing X or Y value

Create an equivalent L command using the recovered coord. and the V or H coord.

Recreate the sequence having swapped the V or H with the new L command.

Repeat this process over the whole sequence.

If the entire sequence has NO V or H, done.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn any-vh?
  [cmds]
  (not (empty? (filter #{:vline :hline} (map :command cmds)))))

;; previous commmand is NOT V or H
;; therefore, you can get the 'cursor position' 
;; by taking the last 2 args in the input to the command
;; this is true for every command except v h which only have an X or Y
(defn convert-vh
  [[pcmd ccmd]]
  (if (and (not (any-vh? [pcmd])) ;;prev. cmd must NOT be VH
           (any-vh? [ccmd])) ;; curr. cmd must be VH
    (let [[px py] (take-last 2 (:input pcmd))
          vh (:command ccmd)
          xinput (cond (= vh :hline) [(first (:input ccmd)) py]
                       (= vh :vline) [px (first (:input ccmd))])
          ncmd (-> ccmd
                   (assoc :command :line)
                   (assoc :input xinput))]
      [pcmd ncmd])
    [pcmd ccmd]))

(defn convert-first-vh-cmd
  [cmds]
  (let [icmd (first cmds)]
  (cons icmd 
        (->> cmds
             (partition 2 1)
             (map convert-vh)
             (map second)))))

(defn vh->l
  [cmds]
  (let [iters (iterate convert-first-vh-cmd cmds)]
    (->> iters
         (partition 2 1)
         (take-while (fn [[a b]] (not= a b)))
         (last)
         (last))))

#+END_SRC

*** building-path-strings
Given a sequence of command maps, produce a path string.

Then, we can losely consider a sequence of command maps to be the internal data structure for path manipulation. This means you can create multi-path path strings by passing a sequence of sequences of command maps.

For each cmd seq., convert to path-string, then apply string to concatenate these path strings into the final string. You can alternatively treat each path string as the attribute for a new path element and draw them separately.

The requirement is that if a user puts a path string into the system but does not transform it in any way, they should expect an equivalent string to be emitted from the cmds->str fn.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(def command-map
  {:move "M"
   :line "L"
   :hline "H"
   :vline "V"
   :curve "C"
   :scurve "S"
   :quadratic "Q"
   :squadratic "T"
   :arc "A"
   :close "Z"})

(defn cmd->path-string
  [{:keys [:command :coordsys :input]}]
  (let [c (if (= coordsys :abs) 
            (get command-map command)
            (st/lower-case (get command-map command)))]
    (str c (apply str (interpose " " input)))))

(defn cmds->path-string
  [cs]
  (apply str (interpose " " (map cmd->path-string cs))))

#+END_SRC

** old-path-impl
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn path->pts
  [s]
  (as-> s s
    (s/replace s #"Z" "") ;; removes Z at end of path
    (s/split s #"\s") ;; split string at spaces
    (mapcat #(s/split % #"[A-Za-z]") s) ;;splits on alpha chars
    (filter #(not (= % "")) s)
    (map read-string s)
    (vec (map vec (partition 2 s)))))

(defn path-type
  [s]
  (cond 
    (s/includes? s "L") :line
    (s/includes? s "l") :line
    (s/includes? s "C") :cubic
    (s/includes? s "c") :relative-cubic
    (s/includes? s "Q") :quadratic
    (s/includes? s "A") :arc))

(defn closed?
  [s]
  (= \Z (last s)))

(defmulti path-string->path
  (fn [s]
    (path-type s)))

(defmethod path-string->path :default
  [s]
  {:type (path-type s)
   :closed (closed? s)
   :pts (path->pts s)})

(defmethod path-string->path :arc
  [s]
  (let [xs (-> s
               (s/replace #"[A-Za-z]" "")
               (s/split #"\s")
               (#(filter (complement s/blank?) %)))
        [p1x p1y rx ry x-deg lg sw p3x p3y] xs]
    {:type :arc
     :closed (closed? s)
     :p1 [p1x p1y]
     :p3 [p3x p3y]
     :rx rx
     :ry ry
     :x-deg x-deg
     :lg lg
     :sw sw}))

(defn -str
  [leader & pts]
  (apply str (interpose " " (concat [leader] (flatten pts)))))

(defmulti path->path-string
  (fn [p]
    (:type p)))

(defmethod path->path-string :line
  [{:keys [closed pts]}]
  (let [[m & pts] pts]
    (str 
     (-str "M" m) " "
     (apply str (interpose " " (map (partial -str "L") pts)))
     (when closed " Z"))))

(defmethod path->path-string :quadratic
  [{:keys [closed pts]}]
  (let [[p1 c p2 & pts] pts]
    (str
     (-str "M" p1) " "
     (-str "Q" c p2) " "
     (apply str (interpose " "
                       (map #(apply (partial -str "T") %) (partition 2 pts))))
     (when closed " Z"))))

(defmethod path->path-string :cubic
  [{:keys [closed pts]}]
  (let [[p1 c1 c2 p2  & pts] pts]
    (str
     (-str "M" p1) " "
     (-str "C" c1 c2 p2) " "
     (apply str (interpose 
                 " " 
                 (map #(apply (partial -str "S") %) (partition 2 pts))))
     (when closed " Z"))))

(defmethod path->path-string :relative-cubic
  [{:keys [closed pts]}]
  (let [[p1 c1 c2 p2  & pts] pts]
    (str
     (-str "M" p1) " "
     (-str "c" c1 c2 p2) " "
     (apply str (interpose 
                 " " 
                 (map #(apply (partial -str "") %) (partition 2 pts))))
     (when closed " Z"))))

(defmethod path->path-string :arc
  [{:keys [p1 p3 rx ry x-deg lg sw closed]}]
  (str
   (-str "M" p1) " "
   (-str "A" [rx ry] [x-deg lg sw] p3)
   (when closed " Z")))

#+END_SRC

** polygon-path
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn path-polygon-str
  [[m & pts]]
  (str 
   (-str "M" m) " "
   (apply str 
          (interpose " " (map (partial -str "L") pts)))
   " Z"))

(defn path-polyline-str
  [[m & pts]]
  (str 
   (-str "M" m) " "
   (apply str 
          (interpose " " (map (partial -str "L") pts)))))

(defn centered-path-polygon
  [& pts]
  (let [m (f/midpoint (apply concat pts))
        xpts (for [spts pts] (mapv #(f/v- % m) spts))
        paths (map path-polygon-str xpts)]
    (path (apply str (interpose "\n" paths)))))

(defn centered-path-polyline
  [& pts]
  (let [m (f/midpoint (apply concat pts))
        xpts (for [spts pts] (mapv #(f/v- % m) spts))
        paths (map path-polyline-str xpts)]
    (path (apply str (interpose "\n" paths)))))

(defn path-polygon
  [& pts]
  (let [paths (map path-polygon-str pts)]
    (path (apply str (interpose "\n" paths)))))

(defn path-polyline
  [& pts]
  (let [paths (map path-polyline-str pts)]
    (path (apply str (interpose "\n" paths)))))

#+END_SRC

** bezier
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(declare style-element)
(defn cubic-bezier-str
  [[x1 y1] [cx1 cy1] [cx2 cy2] [x y]]
  (let [m-str (str "M " x1 " " y1 " ")
        c-str (apply str (interpose " " ["C" cx1 cy1 cx2 cy2 x y]))]
    (str m-str c-str)))

(defn s-bezier-str
  [[cx1 cy1] [x y]]
  (apply str (interpose " " ["S" cx1 cy1 x y])))

(defn cubic-bezier
  [pts]
  (let [curve1 (apply cubic-bezier-str (take 4 pts))
        s-curves (map #(apply s-bezier-str %)
                      (partition 2 (drop 4 pts)))]
    (path 
     (apply str (interpose " " (cons curve1 s-curves))))))

#_(defn cubic-bezier-debug
  [pts]
  (let [curve1 (apply cubic-bezier-str (take 4 pts))
        s-curves (map #(apply s-bezier-str %)
                      (partition 2 (drop 4 pts)))]
    (g
     (style-element
      {:stroke "black"
       :stroke-width 1}
      (g
       (map #(translate % (circle 2)) pts)
       (polyline pts)))
     (path 
      (apply str (interpose " " (cons curve1 s-curves)))))))

#+END_SRC

** arc
The arc command 

A rx ry x-axis-rotation large-arc-flag sweep-flag x y
 
a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn arc-str
  [rx ry x-deg lg sw x y]
  (apply str (interpose " " ["a" rx ry x-deg lg sw x y])))

;; arc drawing can be done in a few ways.
;; could implement different drawing methods w/ defmethod,
;; dispatch on :key OR on 'shape' of the args?

(defn large-arc-flag
  [p1 p2 p3]
  (let [[p1b p2b p3b] (map #(conj % 0) [p1 p2 p3])
        c (drop-last (f/center-from-pts p1b p2b p3b))
        a1 (f/angle-from-pts p1 c p2)
        a2 (f/angle-from-pts p2 c p3)
        a (+ a1 a2)]
    (if (< 180 a) 1 0)))

;; figure out how to properly set sweep flag.
;; this breaks when p1 and p3 are swapped (even though 
;; the arc should be drawn the same.. it also breaks
;; when p2 is in Q4

(defn sweep-flag
  [p1 p2 p3]
  (let [[p1b p2b p3b] (map #(conj % 0) [p1 p2 p3])
        c (drop-last (f/center-from-pts p1b p2b p3b))]
    (if (or (> (second p2) (second c))
            (> (first p2) (first c))) 0 1)))

(declare circle-by-pts)
(declare translate)
(declare rotate)
(declare scale)
(defn arc
  [p1 p2 p3]
  (let [[p1b p2b p3b] (map #(conj % 0) [p1 p2 p3]) 
        r (f/radius-from-pts p1b p2b p3b)
        m-str (apply str (interpose " " (cons "M" p1)))
        a-str (apply str 
                     (interpose " " (concat ["A" r r 0 
                                             (large-arc-flag p1 p2 p3)
                                             (sweep-flag p1 p2 p3)] p3)))]
    (g
     (circle-by-pts p1 p2 p3)
     (path (apply str (interpose " " [m-str a-str]))))))

#+END_SRC

** combine-paths
These are prototype functions for now. They are used to build compound paths. That is, straight segments combined in various ways with curves. As well, it is necessary for faces with holes. Eg. a square with a smaller shape contained within.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn merge-paths
  "Merges svg <path> elements together, keeping props from last path in the list."
  [& paths]
  (let [props (second (last paths))
        d (apply str (interpose "\n" (map #(get-in % [1 :d]) paths)))]
    [:path (assoc props :d d)]))

(defn join-paths
  [& paths]
  (let [props (second (last paths))
        strings (concat [(get-in (first paths) [1 :d])] 
                        (mapv #(s/replace (get-in % [1 :d]) #"M" "L") (rest paths)))
        d (apply str (interpose "\n" strings))]
    [:path (assoc props :d d)]))

(defn close-path
  [[k props]]
  (let [path-string (:d props)]
    [k (assoc props :d (str path-string " Z"))]))

#+END_SRC

* geom-computation
** bounds
*** bounds-fn
#+begin_src clojure :results none :tangle ./src/svg_clj/main.cljc
(defn pts->bounds
  [pts]
  (let [xmax (apply max (map first pts))
        ymax (apply max (map second pts))
        xmin (apply min (map first pts))
        ymin (apply min (map second pts))]
    (vector [xmin ymin]
            [xmax ymin]
            [xmax ymax]
            [xmin ymax])))

#+end_src

*** bounds-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defmulti bounds-element
  (fn [element]
    (first element)))

(defmethod bounds-element :circle
  [[_ props]]
  (let [c [(:cx props) (:cy props)]
        r (:r props)
        pts (mapv #(f/v+ c %) [[r 0]
                               [0 r]
                               [(- r) 0]
                               [0 (- r)]])]
    (pts->bounds pts)))

(declare rotate-pt-around-center)
(defmethod bounds-element :ellipse
  [[_ props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        c [(:cx props) (:cy props)]
        rx (:rx props)
        ry (:ry props)
        pts (mapv #(f/v+ c %) [[rx 0]
                               [0 ry] 
                               [(- rx) 0]
                               [0 (- ry)]])
        bb (pts->bounds pts)
        obb (mapv #(rotate-pt-around-center deg [mx my] %) bb)
        xpts (mapv #(rotate-pt-around-center deg [mx my] %) pts)
        small-bb (pts->bounds xpts)
        large-bb (pts->bounds obb)]
    ;; not accurate, but good enough for now
    ;; take the bb to be the average between the small and large
    (pts->bounds (mapv #(f/midpoint [%1 %2]) small-bb large-bb))))

(defmethod bounds-element :line
  [[_ props]]
  (let [a (mapv #(get % props) [:x1 :y1])
        b (mapv #(get % props) [:x2 :y2])]
    (pts->bounds [a b])))

(defmethod bounds-element :path
  [[_ props]]
  (let [path-strings (s/split-lines (:d props))
        paths (map (comp :pts path-string->path) path-strings)]
    (pts->bounds (apply concat paths))))

(defmethod bounds-element :polygon
  [[_ props]]
  (let [pts (str->points (:points props))]
    (pts->bounds pts)))

(defmethod bounds-element :polyline
  [[_ props]]
  (let [pts (str->points (:points props))]
    (pts->bounds pts)))

(defmethod bounds-element :rect
  [[_ props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        x (:x props)
        y (:y props)
        w (:width props)
        h (:height props)
        pts [[x y]
             [(+ x w) y]
             [(+ x w) (+ y h)]
             [x (+ y h)]]
        xpts (mapv #(rotate-pt-around-center deg [mx my] %) pts)]
    (pts->bounds xpts)))

;; this is not done yet. Text in general needs a redo.
(defmethod bounds-element :text
  [[_ props text]]
  [[(:x props) (:y props)]])

#+END_SRC

*** group-bounds
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(declare bounds)
(defmethod bounds-element :g
  [[_ props & content]]
  (pts->bounds (apply concat (map bounds content))))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn bounds
  [& elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (bounds-element elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(bounds-element elem)]
         [(bounds elems)])
      
        :else
        (recur (concat elem elems))))))

#+END_SRC
** midpoint
*** midpoint-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defmulti midpoint-element
  (fn [element]
    (first element)))

(defmethod midpoint-element :circle
  [[_ props]]
  [(:cx props) (:cy props)])  

(defmethod midpoint-element :ellipse
  [[_ props]]
  [(:cx props) (:cy props)])

(defmethod midpoint-element :line
  [[_ props]]
  (let [a (mapv #(get props %) [:x1 :y1])
        b (mapv #(get props %) [:x2 :y2])]
    (f/midpoint [a b])))

(defmethod midpoint-element :path
  [[_ props]]
  (let [path-strings (s/split-lines (:d props))
        paths (map (comp :pts path-string->path) path-strings)]
    (f/midpoint (apply concat paths))))

(defmethod midpoint-element :polygon
  [[_ props]]
  (let [pts (str->points (:points props))]
    (f/midpoint pts)))

(defmethod midpoint-element :polyline
  [[_ props]]
  (let [pts (str->points (:points props))]
    (f/midpoint pts)))

(defmethod midpoint-element :rect
  [[_ props]]
  [(+ (:x props) (/ (:width  props) 2.0))
   (+ (:y props) (/ (:height props) 2.0))])

;; this is not done yet. Text in general needs a redo.
(defmethod midpoint-element :text
  [[_ props text]]
  [(:x props) (:y props)])

#+END_SRC

*** group-midpoint
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(declare midpoint)
(defmethod midpoint-element :g
  [[_ props & content]]
  (f/midpoint (into #{} (map midpoint content))))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn midpoint
  [& elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (midpoint-element elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(midpoint-element elem)]
         [(midpoint elems)])
      
        :else
        (recur (concat elem elems))))))

#+END_SRC

* transforms
Transforms are translate, rotate, and scale. All transforms work well for most objects (:g and :text are exceptions). They all transform about the object's center point. This has the effect of 'local first' transformation.

This leads to challenges with groups. Groups must have their midpoint calculated such that rotation and translation can correctly occur about the group's midpoint. Otherwise, a group will not follow the same behaviour as any other element.

** translate
*** translate-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defmulti translate-element 
  (fn [_ element]
    (first element)))

(defmethod translate-element :circle
  [[x y] [k props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate-element :ellipse
  [[x y] [k props]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate-element :line
  [[x y] [k props]]
  (let [new-props (-> props
                      (update :x1 + x)
                      (update :y1 + y)
                      (update :x2 + x)
                      (update :y2 + y))]
    [k new-props]))

(defmethod translate-element :polygon
  [[x y] [k props]]
  (let [points (str->points (:points props))
        new-points (points->str (map #(map + [x y] %) points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod translate-element :polyline
  [[x y] [k props]]
  (let [points (str->points (:points props))
        new-points (points->str (map #(map + [x y] %) points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod translate-element :rect
  [[x y] [k props]]
  (let [[mx my] (midpoint [k props])
        xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ mx x))
                   (assoc-in [:rotate 2] (+ my y)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate-element :text
  [[x y] [k props text]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 1] + x)
                   (update-in [:rotate 2] + y))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props text]))

#+END_SRC

*** translate-element-path
To complete the translate implementation, I have to make sure path elements can be propery handled.

To do this, I have a second multimethod to handle different commands that can show up in a path string. Command data structures are produced using the path-dsl functions defined earlier.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
#_(defmethod translate-element :path
  [[x y] [k props]]
  (let [path-strings (st/split-lines (:d props))
        paths (map path-string->path path-strings)
        new-paths (for [path paths]
                    (let [xpts (map #(f/v+ [x y] %) (:pts path))]
                      (path->path-string (assoc path :pts xpts))))
        new-props (assoc props :d (apply str (interpose "\n" new-paths)))]
    [k new-props]))

(defmulti translate-path-command
  (fn [_ m]
    (:command m)))

(defmethod translate-path-command :move
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (v+ [x y] input)))

(defmethod translate-path-command :line
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (v+ [x y] input)))

(defmethod translate-path-command :hline
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (v+ [x] input)))

(defmethod translate-path-command :vline
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (v+ [y] input)))

;; x y x y x y because input will ahve the form:
;; [x1 y1 x2 y2 x y] (first two pairs are control points)
(defmethod translate-path-command :curve
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (v+ [x y x y x y] input)))

;; similar approach to above, but one control point is implicit
(defmethod translate-path-command :scurve
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (v+ [x y x y] input)))

(defmethod translate-path-command :quadratic
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (v+ [x y x y] input)))

(defmethod translate-path-command :squadratic
  [[x y] {:keys [:input] :as m}]
  (assoc m :input (v+ [x y] input)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod translate-path-command :arc
  [[x y] {:keys [:input] :as m}]
  (let [[rx ry xrot laf swf ox oy] input]
    (assoc m :input [rx ry xrot laf swf (+ x ox) (+ y oy)])))

(defmethod translate-path-command :close
  [_ cmd]
  cmd)

(defmethod translate-path-command :default
  [a cmd]
  [a cmd])

(defmethod translate-element :path
  [[x y] [k props]]
  (let [cmds (path-string->commands (:d props))
        xcmds (map #(translate-path-command [x y] %) cmds)]
    [k (assoc props :d (cmds->path-string xcmds))]))

#+END_SRC

*** group-translate
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(declare translate)
(defmethod translate-element :g
  [[x y] [k props & content]]
  (->> content
       (map (partial translate [x y]))
       (filter (complement nil?))
       (into [k props])))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn translate
  [[x y] & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (translate-element [x y] elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(translate-element [x y] elem)]
         [(translate [x y] elems)])
      
        :else
        (recur [x y] (concat elem elems))))))

;; this is the 'old' way.
(defn translate-g
  [[x y] & elems]
  (into [:g {:transform (translate-str x y)}] elems))

#+END_SRC
** rotate
*** rotate-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn rotate-element-by-transform
  [deg [k props content]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 0] + deg))
        new-props (assoc props :transform (xf-map->str new-xf))]
    [k new-props content]))

(defn rotate-pt
  [deg [x y]]
  (let [c (Math/cos (f/to-rad deg))
        s (Math/sin (f/to-rad deg))]
    [(- (* x c) (* y s))
     (+ (* x s) (* y c))]))

(defmulti rotate-element
  (fn [_ element]
    (first element)))

(defmethod rotate-element :circle
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defmethod rotate-element :ellipse
  [deg [k props]]
  (rotate-element-by-transform deg [k props]))

(defn move-pt
  [mv pt]
  (mapv + pt mv))

(defn rotate-pt-around-center
  [deg center pt]
  (->> pt
       (move-pt (map - center))
       (rotate-pt deg)
       (move-pt center)))

(defmethod rotate-element :line
  [deg [k props]] 
  (let [pts [[(:x1 props) (:y1 props)] [(:x2 props) (:y2 props)]]
        [[x1 y1] [x2 y2]]  (->> pts
                                (map #(f/v- % (f/midpoint pts)))
                                (map #(rotate-pt deg %))
                                (map #(f/v+ % (f/midpoint pts))))
        new-props (-> props
                      (assoc :x1 x1)
                      (assoc :y1 y1)
                      (assoc :x2 x2)
                      (assoc :y2 y2))]
    [k new-props]))

#_(defmethod rotate-element :polygon
  [deg [k props]]
  (let [points (str->points (:points props))
        center (f/midpoint points)
        new-points (points->str
                    (map 
                     (partial rotate-pt-around-center deg center)
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod rotate-element :polygon
  [deg [k props]]
  (let [m (midpoint [k props])
        pts (str->points (:points props))
        xpts (->> pts
                  (map #(f/v- % m))
                  (map #(rotate-pt deg %))
                  (map #(f/v+ % m))
                  (points->str))
        xprops (assoc props :points xpts)]
    [k xprops]))

(defmethod rotate-element :polyline
  [deg [k props]]
  (let [points (str->points (:points props))
        center (f/bb-center-2d points)
        new-points (points->str
                    (map 
                     (partial rotate-pt-around-center deg center)
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod rotate-element :rect
  [deg [k props]]
  (let [[mx my] (midpoint [k props])
        xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        new-xf (-> xf
                   (update-in [:rotate 0] + deg)
                   (assoc-in  [:rotate 1] mx)
                   (assoc-in  [:rotate 2] my))
        new-props (assoc props :transform (xf-map->str new-xf))]
    [k new-props]))

(defmethod rotate-element :text
  [deg [k props text]]
  (rotate-element-by-transform deg [k props text]))

#+END_SRC

*** rotate-element-path
To complete the translate implementation, I have to make sure path elements can be propery handled.

To do this, I have a second multimethod to handle different commands that can show up in a path string. Command data structures are produced using the path-dsl functions defined earlier.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
#_(defmethod rotate-element :path
  [deg [k props]]
  (let [m (midpoint [k props])
        paths (map path-string->path (s/split-lines (:d props)))
        xpaths (for [path paths]
                    (let [xpts (->> (:pts path)
                                    (map #(f/v- % m))
                                    (map #(rotate-pt deg %))
                                    (map #(f/v+ % m)))]
                      (path->path-string (assoc path :pts xpts))))
        xprops (assoc props :d (apply str (interpose "\n" xpaths)))]
    [k xprops]))

(defmulti rotate-path-command
  (fn [_ m]
    (:command m)))

(defmethod rotate-path-command :move
  [ctr deg {:keys [:input] :as m}]
  (let [xpt (->> input
                 (#(v- % ctr))
                 (rotate-pt deg)
                 (v+ ctr))]
    (assoc m :input xpt)))

(defmethod rotate-path-command :line
  [ctr deg {:keys [:input] :as m}]
  (let [xpt (->> input
                 (#(v- % ctr))
                 (rotate-pt deg)
                 (v+ ctr))]
    (assoc m :input xpt)))

(defmethod rotate-path-command :curve
  [ctr deg {:keys [:input] :as m}]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(v- % ctr))
                    (map #(rotate-pt deg %))
                    (map #(v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command :scurve
  [ctr deg {:keys [:input] :as m}]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(v- % ctr))
                    (map #(rotate-pt deg %))
                    (map #(v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command :quadratic
  [ctr deg {:keys [:input] :as m}]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(v- % ctr))
                    (map #(rotate-pt deg %))
                    (map #(v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command :squadratic
  [ctr deg {:keys [:input] :as m}]
  (let [xpt (->> input
                 (#(v- % ctr))
                 (rotate-pt deg)
                 (v+ ctr))]
    (assoc m :input xpt)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod rotate-path-command :arc
  [ctr deg {:keys [:input] :as m}]
  (let [[rx ry xrot laf swf ox oy] input
        [nx ny] (->> [ox oy]
                     (#(v- % ctr))
                     (rotate-pt deg)
                     (v+ ctr))]
    (assoc m :input [rx ry (+ xrot deg) laf swf nx ny])))

(defmethod rotate-path-command :close
  [_ _ cmd]
  cmd)

(defmethod rotate-path-command :default
  [a cmd]
  [a cmd])

(defmethod rotate-element :path
  [deg [k props]]
  (let [ctr (midpoint [k props])
        cmds (path-string->commands (:d props))
        xcmds (map #(rotate-path-command ctr deg %) cmds)]
    [k (assoc props :d (cmds->path-string xcmds))]))

#+END_SRC

*** group-rotate
If I let the rotate 'pass through' a group, it rotates every child element locally. This has the effect of ignoring grouped elements that you do want to rotate about the group's center.

Each child of a group must be rotated around the group's midpoint.
So,
- find group midpoint
- apply rotation to children about group midpoint
  - rotate child by deg
  - translate child to new center (rotate its orig midpoint about group midpoint to find new position)



#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(declare rotate)
#_(defmethod rotate-element :g
  [deg [k props & content]]
  (let [[gmx gmy] (f/midpoint (bounds (into [k props] content)))
        xfcontent (for [child content]
                    (let [m (midpoint child)
                          xfm (->> m
                                   (f/v- [gmx gmy])
                                   (rotate-pt 180)
                                   (rotate-pt deg)
                                   (f/v+ [gmx gmy]))]
                      (->> child
                           (translate (f/v* [-1 -1] m))
                           (rotate deg)
                           (translate xfm))))]
    (into [k props] (filter (complement nil?) xfcontent))))

(defmethod rotate-element :g
  [deg [k props & content]]
  (let [[gmx gmy] (f/midpoint (bounds (into [k props] content)))
        xfcontent (for [child content]
                    (let [ch (translate [(- gmx) (- gmy)] child)
                          m (if (= :g (first ch))
                              (f/midpoint (bounds ch))
                              (midpoint ch))
                          xfm (->> m
                                   (rotate-pt deg)
                                   (f/v+ [gmx gmy]))]
                      (->> ch
                           (translate (f/v* [-1 -1] m))
                           (rotate deg)
                           (translate xfm))))]
    (into [k props] (filter (complement nil?) xfcontent))))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn rotate
  [deg & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (rotate-element deg elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(rotate-element deg elem)]
         [(rotate deg elems)])
        
        :else
        (recur deg (concat elem elems))))))

;; old approach
(defn rotate-g
  [r [x y] & elems]
  (into [:g {:transform (rotate-str r [x y])}] elems))

#+END_SRC

** scale
SVG items are assumed to be positioned and moved around from their bounding box centers. This means that scaling an element will NOT move it's center position.

*** scale-element
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn scale-element-by-transform
  [[sx sy] [k props & content]]
  (let [xf (str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (xf-map->str new-xf))]
    [k new-props] content))

(defmulti scale-element 
  (fn [_ element]
    (first element)))

;; transforms are applied directly to the properties of shapes.
;; I have scale working the same way. One issue is that scaling a circle
;; turns it into an ellipse. This impl WILL change the shape to ellipse if non-uniform scaling is applied.

(defmethod scale-element :circle
  [[sx sy] [k props]]
  (let [circle? (= sx sy)
        r (:r props)
        new-props (if circle?
                    (assoc props :r (* r sx))
                    (-> props
                        (dissoc :r)
                        (assoc :rx (* sx r))
                        (assoc :ry (* sy r))))
        k (if circle? :circle :ellipse)]
    [k new-props]))

(defmethod scale-element :ellipse
  [[sx sy] [k props]]
  (let [new-props (-> props
                      (update :rx #(* sx %))
                      (update :ry #(* sy %)))]
    [k new-props]))

;; find bounding box center
;; translate bb-center to 0 0
;; scale all x y values by * [sx sy]
;; translate back to original bb-center

(defmethod scale-element :line
  [[sx sy] [k props]]
  (let [[cx cy] (f/bb-center-2d [[(:x1 props) (:y1 props)]
                              [(:x2 props) (:y2 props)]])
        new-props (-> props
                      (update :x1 #(+ (* (- % cx) sx) cx))
                      (update :y1 #(+ (* (- % cy) sy) cy))
                      (update :x2 #(+ (* (- % cx) sx) cx))
                      (update :y2 #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defn scale-pt-from-center
  [[cx cy] [sx sy] [x y]]
  [(+ (* (- x cx) sx) cx)
   (+ (* (- y cy) sy) cy)])

(defmethod scale-element :path
  [[sx sy] [k props]]
  (let [path-strings (s/split-lines (:d props))
        paths (map path-string->path path-strings)
        center (f/bb-center-2d (apply concat (map :pts paths)))
        new-paths (for [path paths]
                    (let [xf (partial scale-pt-from-center center [sx sy])
                          xpts (map xf (:pts path))]
                      (path->path-string (assoc path :pts xpts))))
        new-props (assoc props :d (apply str (interpose "\n" new-paths)))]
    [k new-props]))

(defmethod scale-element :polygon
  [[sx sy] [k props]]
  (let [points (str->points (:points props))
        center (f/bb-center-2d points)
        new-points (points->str
                    (map 
                     (partial scale-pt-from-center center [sx sy])
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod scale-element :polyline
  [[sx sy] [k props]]
  (let [points (str->points (:points props))
        center (f/bb-center-2d points)
        new-points (points->str
                    (map 
                     (partial scale-pt-from-center center [sx sy])
                     points))
        new-props (assoc props :points new-points)]
    [k new-props]))

(defmethod scale-element :rect
  [[sx sy] [k props]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale-element :text
  [[sx sy] [k props text]]
  (let [xf (str->xf-map (get props :transform "rotate(0 0 0)"))
        cx (get-in xf [:rotate 1])
        cy (get-in xf [:rotate 2])
        x (+ (* (- (:x props) cx) sx) cx)
        y (+ (* (- (:y props) cy) sy) cy)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (- x))
                   (assoc-in [:rotate 2] (- y)))
        new-props (-> props
                      (assoc :transform (xf-map->str new-xf))
                      (assoc :x x)
                      (assoc :y y)
                      (update-in [:style :font-size] #(* % sx)))]
    [k new-props text]))

(defmethod scale-element :g
  [[sx sy] [k props & content]]
  (let [xf (str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (xf-map->str new-xf))]
    (into [k new-props] content)))
  
#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn scale
  [sc & elems]
  (let [[sx sy] (if (coll? sc) sc [sc sc])
        elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (scale-element [sx sy] elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(scale-element [sx sy] elem)]
         [(scale [sx sy] elems)])
        
        :else
        (recur [sx sy] (concat elem elems))))))

;; this is the old method
(defn scale-g
  [sc & elems]
  (into [:g {:transform (scale-str sc)}] elems))
#+END_SRC
** style
Style transforms allow the user to change any attributes of svg elements that affect appearance. For instance, stroke color, stroke width, and fill.

To consider:
- classes/ids with style in a CSS file, how can user attach class/id tags?
- what is proper precedence for style data? should merge always put the 'newest' or keep the existing?

#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
;; change this to just (style)
(defn style-element
  [style [k props & content]]
  (into [k (merge props style)] content))

;; probably delete this
(defn color-element
  [color [k props & content]]
  (let [color {:fill "none"
               :stroke color}]
    (into [k (merge props color)] content)))

#+END_SRC

*** interface
#+BEGIN_SRC clojure :tangle ./src/svg_clj/main.cljc
(defn color
  [style & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (element? elem) (= 0 (count elems)))
        (color-element style elem)
        
        (and (element? elem) (< 0 (count elems)))
        (concat
         [(color-element style elem)]
         [(color style elems)])
        
        :else
        (recur style (concat elem elems))))))

#+END_SRC
* misc-notes
Remember in REPL you can't re-def the defmulti dispatch function with some ns magic.

https://clojuredocs.org/clojure.core/defmulti#example-55d9e498e4b0831e02cddf1b

#+begin_src clojure
(defmulti x (fn[_] :dec)) ;; Can't redefine :(
(x 0) ;; => 1 ;; STILL :(
(ns-unmap *ns* 'x) ;; => unmap the var from the namespace

#+end_src



- change the name of the midpoint defmulti to centroid... or something along those lines

- have to update midpoint and bounds impls for paths to use the new command map structure.

- for transformations to work on paths, (rotate especially) it is necessary to have a fn that converts H and V commands into L commands.
