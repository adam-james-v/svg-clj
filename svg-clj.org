* ;;
#+Title: svg-clj
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: excl
#+PROPERTY: header-args :cache yes :noweb yes :results value :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** deps.edn
#+NAME: deps.edn
#+begin_src clojure :tangle ./deps.edn
{:deps 
 {org.clojure/clojure    {:mvn/version "1.10.3"}
  org.clojure/data.xml   {:mvn/version "0.2.0-alpha6"}
  same/ish               {:mvn/version "0.1.4"}
  hiccup/hiccup          {:mvn/version "2.0.0-alpha2"}}
 
 :aliases
 {:test
  {:extra-paths ["test"]
   :extra-deps {org.clojure/test.check {:mvn/version "1.1.0"}
                com.cognitect/test-runner
                {:git/url "https://github.com/cognitect-labs/test-runner.git"
                 :sha "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
   :main-opts ["-m" "cognitect.test-runner"]}
  
  :jar
  {:replace-deps {com.github.seancorfield/depstar {:mvn/version "2.1.245"}}
   :exec-fn hf.depstar/jar
   :exec-args {}}

  :release
  {:extra-deps {applied-science/deps-library {:mvn/version "0.4.0"}}
   :main-opts ["-m" "applied-science.deps-library"]}}}

#+end_src

** release.edn
For now, to make a release to clojars, do the following:

0. Git commit and push latest changes
1. rm pom.xml from project root dir
2. git tag (currently 0.0.10)
   - you can only re-use snapshot tags... so if you're making tiny changes, do it on snapshots. Then, when you feel it's appropriate, push a proper update by incrementing the Major.Minor.Patch (whichever makes sense).
3. clj -M:release will push to clojars

NOTE TO SELF: This seems like a good thing to wrap in a bb.edn task to make things a bit cleaner and clearer.

As well, be sure to write a note about where the deploy token secret is configured. And be careful not to show taht on stream. If you do, you must immediately revoke the token.


#+begin_src clojure :tangle ./release.edn
{:group-id "io.github.adam-james-v"
 :artifact-id "svg-clj"
 :scm-url "https://github.com/adam-james-v/svg-clj"}
#+end_src

** build-cmds
*** build-library-jar
#+begin_src shell
clojure -X:jar :jar svg-clj.jar
#+end_src

** bb.edn
#+begin_src clojure :tangle ./bb.edn
{:tasks
 {:requires ([babashka.fs :as fs]
             [clojure.string :as str])
  :init (def windows? (str/starts-with? (System/getProperty "os.name")
                                        "Windows"))
  run-main
  {:doc "Run main"
   :task (apply clojure "-M -m svg-clj.cli" *command-line-args*)}
  
  uberjar
  {:doc "Builds uberjar"
   :task (when (seq (fs/modified-since "svg_clj.jar" "src"))
           (clojure "-X:uberjar"))}

  run-uber
  {:doc "Run uberjar"
   :depends [uberjar]
   :task (apply shell "java -jar svg_clj.jar" *command-line-args*)}}}

#+end_src

** readme
#+BEGIN_SRC markdown :tangle ./readme.md
<img src="https://github.com/adam-james-v/svg-clj/blob/main/examples/quilt.png" alt="A colourful render of a quilt design" width="300">

# svg-clj

[![Clojars Project](https://img.shields.io/clojars/v/io.github.adam-james-v/svg-clj.svg)](https://clojars.org/io.github.adam-james-v/svg-clj)

svg-clj is a library for creating SVGs in Clojure/Clojurescript. This is done using functions which emit hiccup data structures. Since hiccup is quite common and well-known in the Clojure ecosystem, it is rather simple to use svg-clj alongside other libraries that emit and/or expect hiccup-style data structures.

You can try things out in the browser here:
[svg-clj-interactive](https://adam-james-v.github.io/svg-clj-interactive/index.html)

Here is an example using most of svg-clj's features:

![An SVG Image of a stylized flower blossom.](https://github.com/adam-james-v/svg-clj/blob/main/examples/blossom.svg "Blossom")

This blossom is produced with the following code:

```clojure
(ns examples.blossom
  (:require [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.transforms :as tf]
            [svg-clj.composites :as comp :refer [svg]]
            [svg-clj.path :as path]
            [svg-clj.parametric :as p]
            [svg-clj.layout :as lo]
            #?(:clj [svg-clj.tools :as tools])))
            
(defn flip-y
  [pts]
  (mapv #(utils/v* % [1 -1]) pts))

(defn petal
  [cpts]
  (let [beza (apply path/bezier cpts)
        bezb (apply path/bezier (flip-y cpts))
        shape (tf/merge-paths beza bezb)
        ctr (tf/centroid shape)]
    (-> shape
        (tf/rotate -90)
        (tf/translate (utils/v* ctr [-1 -1])))))

(defn petal-ring
  [petal r n]
  (el/g
   (lo/distribute-on-curve
    (repeat n petal)
    (p/circle r))))

(def petal-01
  (-> (petal [[0 0] [5 -50] [50 -20] [75 0]])
      (tf/style {:fill "#ff8b94"
                 :stroke "#ffaaa5"
                 :stroke-width "4px"
                 :stroke-linecap "round"})))

(def petal-02
  (-> (petal [[0 0] [1 -20] [20 -10] [40 0]])
      (tf/style {:fill "#ffaaa5"
                 :stroke "none"})))

(def petal-03
  (-> (path/merge-paths petal-01 petal-02)
      (tf/style {:fill "#a8e6cf"})))

(def petal-ring-01 (petal-ring petal-01 120 12))
(def petal-ring-02 (petal-ring petal-02 120 12))

(def petal-ring-03
  (-> (petal-ring petal-03 70 6)
      (tf/rotate (/ 360.0 24))))

(def petal-ring-04
  (let [petal (-> petal-03 (tf/style {:fill "#cc5963"}))]
    (-> (petal-ring petal 90 6)
        (tf/rotate (/ 360.0 24))
        (tf/rotate (/ 360.0 12)))))

(def petal-ring-05
  (let [petal (-> petal-02
                  (tf/rotate 180)
                  (tf/style {:fill "none"
                             :stroke "#f4f1d7"
                             :stroke-width "2px"}))]
    (-> (petal-ring petal 70 36)
        (tf/rotate (/ 360.0 24)))))

(def petal-ring-06
  (let [petal (-> petal-02
                  (tf/style {:fill "none"
                             :stroke "#f4f1d7"
                             :stroke-width "2px"}))]
    (-> (petal-ring petal 40 20)
        (tf/rotate (/ 360.0 24)))))

(def blossom (el/g
              (-> (el/circle 105) (tf/style {:fill "#69b599"}))
              petal-ring-01
              petal-ring-02
              petal-ring-06
              petal-ring-05
              petal-ring-04
              petal-ring-03))

;; when in a Clojure context, you can compile to SVG files
;; this uses the Hiccup html compiler
;; emitted hiccup works with Reagent as well.

(tools/save-svg blossom "examples/blossom.svg")
```

Other examples, also available in the examples directory of this project:

- [basics](https://adam-james-v.github.io/svg-clj/examples/basics)
- [layout](https://adam-james-v.github.io/svg-clj/examples/layout)
- [bezier](https://adam-james-v.github.io/svg-clj/examples/bezier)
- [offset](https://adam-james-v.github.io/svg-clj/examples/offset)

## Known Issues
There are several features I have yet to completely fix.

- scale transformation can have confusing behaviour when scaled elements are used in groups.
- Bounds and Centroid calculations can give incorrect results with paths containing arcs or bezier curves
- text elements have only basic support (translate, rotate, style work). Other transforms have buggy workarounds for the fact that text element dimensions are not known until rasterization
- offset works for all elements except paths, which is a WIP feature
- arc implementation is still buggy, particularly when rotating.

## Using svg-clj in your project

If you use lein or boot, place this in your project.clj:

```clj
[io.github.adam-james-v/svg-clj "0.0.1-SNAPSHOT"]
```

If you use Clojure's CLI, add this to your :deps in deps.edn:


```clj
io.github.adam-james-v/svg-clj {:mvn/version "0.0.1-SNAPSHOT"}
```

NOTE: check that you're grabbing the version you want.

## Design
The library uses hiccup syntax to represent the SVG diagrams being created. The user writes functional code to define various elements of the SVG and has access to transformations via utility functions.

Since the library functions emit hiccup data structures, the user can extend and manipulate their data using other clojure libraries or their own functions. 

The library has two main categories of functions:

- elements
  - container elements (svg, figure...)
  - shapes
    - circle
    - ellipse
    - line
    - path
    - polygon
    - polyline
    - rect
  - text
  - g
  - composites (custom functions using shapes.. eg. arrow)
  
- transforms and property calcs
  - centroid
  - bounds
  - rotate
  - translate
  - scale
  - style
  - offset
  - explode paths
  - merge paths

### Explaining the namespaces
I've annotated a ns declaration to help make sense of where you can find various functions.

```clj
(ns examples.blossom
  (:require
    ;; math helpers, simple data manip helpers
    [svg-clj.utils :as utils]
    
    ;; all of the shape functions like rect, circle, polygon, etc.
    [svg-clj.elements :as el]
    
    ;; all of the transforms, including path specific fns
    [svg-clj.transforms :as tf]
    
    ;; shapes built from other shapes, AND the svg container fn
    [svg-clj.composites :as comp :refer [svg]]
    
    ;; draw elements using path instead, and has the 'commands' path DSL
    ;; also has arc and bezier drawing fns
    [svg-clj.path :as path]

    ;; parametric curve fns and point list generators useful for layouts
    [svg-clj.parametric :as p]

    ;; layout functions like distribute-linear and distribute-along-curve
    [svg-clj.layout :as lo]

    ;; when in CLJ context, use cider-show, show, save-svg, load-svg
    ;; to help with the dev. process
    #?(:clj [svg-clj.tools :as tools])))
```

Every transform takes an element or list of elements, performs the appropriate actions, and returns an element or list of elements with the transform 'baked in' to the properties.

For example, a circle begins as follows:

```clj
(el/circle 50)
;; => [:circle {:cx 0, :cy 0, :r 50}]

(tf/translate (el/circle 50) [25 25])
;; => [:circle {:cx 25, :cy 25, :r 50, :transform "rotate(0 25 25)"}]
```

Notice how the circle's cx and cy properties have changed according to the transformation.

An important thing to consider with this approach is that it is 'lossy' in some sense. The user's design intent is clear when reading the source they provide, but is lost when compiled to SVG. The call to the translate function is not explicit in the output. This may not be the behaviour everyone expects, so just be aware of this if you need to pass the output to another program or perhaps to another person.

## Opinionated Approach
This is not quite a straight wrapper for SVG functionality. I have altered the default behavior of some functions.

For example, a rectangle is drawn centered around the orgin by default. Plain SVG rectangles draw with the first corner located at the origin by default.

All rotations are applied to shapes locally by default. This means that a circle at [10 0] rotated by 90 deg will not appear to move using svg-clj; the shape itself is being spun around it's center, but that center point is not moving. Default SVG behaviour rotates around the origin by default. So, any elements offset from the orgin will move large distances away from their starting positions. 

This choice was made because it feels more intuitive (to me, at least) to draw with local transformation operations in mind.

## Threading
Greencoder (one of my Twitch viewers) sent several twitter DMs with some criticisms/feedback. All have been appropriately addressed, but I wanted to highlight his thoughts regarding my use of threading macros. 

"thread last macro should be kept for stream operations to compose better with other fns. I think that translate-element should take elem as first argument."
- GreenCoder (Twitch handle)

strictly speaking, translate and rotate are not operating on streams of data, but rather on objects
 - assoc and dissoc use thread first. That is, you do a thing to a single 'object'
 - map and filter use thread last, and are expected to work on all types of seq-able things lists... lazy, infinite

So, to keep the mental model the same, I have designed my transform fns to always take the element being transformed as the first arg. I find threading to be a very readable and intuitive way to 'build up' transforms on some basic element. You can see this approach throughout my various examples.


## Further Reading

If you would like to understand my motivations, decisions, and reasoning for the choices I've made in this library, you can read the .org file in the top level of this repo.

[svg-clj.org](https://github.com/adam-james-v/svg-clj/blob/main/svg-clj.org).

I use a 'freehand' literate programming style in my org files. This just means that I have a scattered approach. Please be patient if you're reading the notes; they may not always make sense or have full context.

Proper documentation is, naturally, a key element in bringing this project from prototype to release.

## Other Work (That I've heard of so far)

[Dali](https://github.com/stathissideris/dali) is a library by Stathis Sideris that also works with SVG. Since I have only recently heard about this library, I have not yet had time to do a detailed comparison but, at a glance, some differences I see are:

| svg-clj                                | dali                                            |
|:--------------------------------------:|:-----------------------------------------------:|
| write functions which emit hiccup data | write hiccup data directly                      |
| very basic layout engine               | layout engine is a key feature                  |
| no built-in rasterization              | rasterize SVGs using Batik                      |
| Clojure and Clojurescript              | Clojure only                                    |
| SVG primitives only (for now)          | SVG primitives + 'prefabs' (eg. markers/arrows) |

#+END_SRC

* admin
** roadmap
Some features that are planned for implementation.

*** candidate-features
Some features that might be added. 
    
- drawing features  
  - regular-polygon-pts  
  - offset
- 'composite' shapes and containers
  - arrows
  - dimensions
  - figure containers

** misc-notes
Remember in REPL you can't re-def the defmulti dispatch function with some ns magic.

https://clojuredocs.org/clojure.core/defmulti#example-55d9e498e4b0831e02cddf1b

#+begin_src clojure
(defmulti x (fn[_] :dec)) ;; Can't redefine
(x 0) ;; => 1 ;; STILL 
(ns-unmap *ns* 'x) ;; => unmap the var from the namespace

#+end_src


Maikerusan suggests:

A mechanism for setting up global defaults when a user has loaded the library.
Config would control:
 - all shapes centering behaviour (eg. center at centroid, corner, whatever)

 - whether translate/rotate are 'baked' or not.
   - 'baked' is the default and means you technically lose information when compiling to SVG (eg you cannot tell that a line was translated if the coords have the translate baked in)

* design
** intent
The purpose of this library is to allow users to create simple functional programs that compile to SVG elements. 

The expected kinds of input are .clj files with svg-clj code, STDIN with svg-clj code. The expected output is hiccup-style clojure data structures, and optionally a compiled SVG string to file or STDOUT.

Basically, this is just a library, but I will add a small CLI interface and create a binary distribution so that the library can stand alone as a small utility, perhaps as a useful tool in a bash scripting pipeline.

** structure
The library uses hiccup syntax to represent the SVG diagrams being created. The user writes functional code to define various elements of the SVG and has access to transformations via utility functions.

Since the library functions emit hiccup data structures, the user can extend and manipulate their data using other clojure libraries or their own functions. 

The library has two main categories of functions:

- elements
  - container elements (svg, figure...)
  - shapes
    - circle
    - ellipse
    - line
    - path
    - polygon
    - polyline
    - rect
  - text
  - g
  - composites (custom functions using shapes.. eg. arrow)
  
- transforms/property calcs
  - centroid
  - bounds
  - rotate
  - translate
  - scale
  - style
  - offset
  - explode paths
  - merge paths

Every transform takes an element or list of elements, performs the appropriate actions, and returns an element or list of elements with the transform 'baked in' to the properties.

For example, a circle begins as follows:

#+begin_src clojure
(el/circle 50)
;; => [:circle {:cx 0, :cy 0, :r 50}]

(tf/translate (el/circle 50) [25 25])
;; => [:circle {:cx 25, :cy 25, :r 50, :transform "rotate(0 25 25)"}]

#+end_src

Notice how the circle's cx and cy properties have changed according to the transformation.

An important thing to consider with this approach is that it is 'lossy' in some sense. The user's design intent is clear when reading the source they provide, but is lost when compiled to SVG. The call to the translate function is not explicit in the output. This may not be the behaviour everyone expects, so just be aware of this if you need to pass the output to another program or perhaps to another person.

** opinionated-approach
This is not quite a straight wrapper for SVG functionality. I have altered the default behavior of some functions.

For example, a rectangle is drawn centered around the orgin by default. Plain SVG rectangles draw with the first corner located at the origin by default.

All rotations are applied to shapes locally by default. This means that a circle at [10 0] rotated by 90 deg will not appear to move using svg-clj; the shape itself is being spun around it's center, but that center point is not moving. Default SVG behaviour rotates around the origin by default. So, any elements offset from the orgin will move large distances away from their starting positions. 

This choice was made because it feels more intuitive (to me, at least) to draw with local transformation operations in mind.

As much as possible, all transformations are 'baked' into shape properties directly.

** Threading
Greencoder (one of my Twitch viewers) sent several twitter DMs with some criticisms/feedback. All have been appropriately addressed, but I wanted to highlight his thoughts regarding my use of threading macros. 

"thread last macro should be kept for stream operations to compose better with other fns. I think that translate-element should take elem as first argument."
- GreenCoder (Twitch handle)

strictly speaking, translate and rotate are not operating on streams of data, but rather on objects
 - assoc and dissoc use thread first. That is, you do a thing to a single 'object'
 - map and filter use thread last, and are expected to work on all types of seq-able things lists... lazy, infinite

So, to keep the mental model the same, I have designed my transform fns to always take the element being transformed as the first arg. I find threading to be a very readable and intuitive way to 'build up' transforms on some basic element. You can see this approach throughout my various examples.

* utils
** ns
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(ns svg-clj.utils
  (:require [clojure.string :as str]
            [clojure.data.xml :as xml]
            [clojure.walk :refer [postwalk]]
            [clojure.zip :as zip]
            [same :refer [zeroish?]]
            #?(:cljs
               [cljs.reader :refer [read-string]])))

#+end_src

** basic-helpers
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(def ^:dynamic *rounding* nil)

(def abs #?(:clj #(Math/abs %)  :cljs js/Math.abs))
(def pow #?(:clj #(Math/pow %1 %2) :cljs js/Math.pow))

(defn round
  "Rounds a non-integer number `num` to `places` decimal places."
  ([num]
   (round num *rounding*))
  ([num places]
   (if places
     (let [d #?(:clj (bigdec (Math/pow 10 places))
                :cljs (Math/pow 10 places))]
       (double (/ (Math/round (* num d)) d)))
     num)))

;; vector arithmetic helpers
(def v+ (partial mapv +))
(def v- (partial mapv -))
(def v* (partial mapv *))

;; simple calcs
(defn to-deg
  [rad]
  (round (* rad (/ 180 Math/PI))))

(defn to-rad
  [deg]
  (round (* deg (/ Math/PI 180))))

(defn average
  [& numbers]
  (let [n (count numbers)]
    (round (/ (apply + numbers) n))))
 
;; some string transformation tools
(defn v->s
  "Turns the vector `v` into a string with commas separating the values."
  [v]
  (str/join "," v))

(defn s->v
  "Turns a string of comma or space separated numbers into a vector."
  [s]
  (-> s
      (str/trim)
      (str/split #"[, ]")
      (#(filter (complement empty?) %))
      (#(mapv read-string %))))

(defn xf-kv->str
  [[k v]]
  (str (symbol k) (apply list v)))

(defn str->xf-kv
  [s]
  (let [split (str/split s #"\(")
        key (keyword (first split))
        val (vec (read-string (str "(" (second split))))]
    [key val]))

(defn xf-map->str
  "Turn transform maps from an element's properties into a string properly formatted for use inline in an svg element tag.

  Consider this an internal tool."
  [m]
  (str/join "\n" (map xf-kv->str m)))

(defn str->xf-map
  [s]
  (if-let [s s]
    (into {} 
          (->> s
               (#(str/replace % #"\)" ")\n"))
               str/split-lines
               (map str/trim)
               (map str->xf-kv)))
    {}))
#+end_src

** pt-rotation
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn rotate-pt
  "Rotates 2d point `pt` around the origin by `deg` in the counter-clockwise direction."
  [pt deg]
  (let [[x y] pt
        c (Math/cos (to-rad deg))
        s (Math/sin (to-rad deg))]
    [(round (- (* x c) (* y s)))
     (round (+ (* x s) (* y c)))]))

(defn rotate-pt-around-center
  "Rotates point `pt` around `center` by `deg` in the counter-clockwise direction."
  [pt deg center]
  (-> pt
      (v+ (map - center))
      (rotate-pt deg)
      (v+ center)))

#+end_src

** geometry
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn distance
  "Computes the distance between two points `a` and `b`."
  [a b]
  (let [v (v- b a)
        v2 (reduce + (v* v v))]
    (round (Math/sqrt ^double v2))))

(defn distance-squared
  [a b]
  (let [v (v- b a)]
    (reduce + (v* v v))))

(defn determinant
  [a b]
  (- (* (first a) (second b))
     (* (second a) (first b))))

;; this fn name doesn't make sense? It inverts y, which is not
;; the same as giving a perpendicular line
;; maybe call it 'invert-y' or 'vertical-flip'
(defn perpendicular
  [[x y]]
  [(- y) x])

(defn dot*
  "Calculates the dot product of two vectors."
  [a b]
  (reduce + (map * a b)))

(defn cross*
  "Calculates cross product of two 3d-vectors. If `a` and `b` are 2D, z is assumed to be 0."
  [a b]
  (let [[a1 a2 a3] a
        [b1 b2 b3] b
        a3 (if a3 a3 0)
        b3 (if b3 b3 0)
        i (- (* a2 b3) (* a3 b2))
        j (- (* a3 b1) (* a1 b3))
        k (- (* a1 b2) (* a2 b1))]
    [i j k]))

(defn cross*-k
  "Calculates the k component of the cross product of two 2D vectors, assuming Z=0 as the 3rd component."
  [[ax ay] [bx by]]
  (- (* ax by) (* ay bx)))

(defn normal
  "Calculates the normal vector of plane given 3 points or calculates the normal vector of a line given two (2D) points."
  ([a b]
   (let [[x1 y1] a
         [x2 y2] b
         dx (- x2 x1)
         dy (- y2 y1)]
     [(- dy) dx]))
  ([a b c]
   (let [eps 0.00001
         ab (v- a b)
         ac (v- a c)
         [x y z] (cross* ab ac)]
     (when (and (> x eps) (> y eps) (> z eps))
       [x y z]))))

(defn normalize
  "find the unit vector of a given vector"
  [v]
  (when v
    (let [m (Math/sqrt ^double (reduce + (v* v v)))]
      (mapv / v (repeat m)))))

#+end_src

** angle
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
;; https://math.stackexchange.com/questions/361412/finding-the-angle-between-three-points
(defn- check-quadrants
  "Using `p2` as the 'origin', return a string indicating positive, negative, or axis-aligned for p1 p2."
  [p1 p2 p3]
  (let [v1 (v- p1 p2)
        v2 (v- p3 p2)
        qf (fn [[x y]]
             (cond (and (pos? x) (pos? y)) "pp"
                   (and (pos? x) (neg? y)) "pn"
                   (and (neg? x) (neg? y)) "nn"
                   (and (neg? x) (pos? y)) "np"
                   (pos? x) "p_"
                   (neg? x) "n_"
                   (pos? y) "_p"
                   (neg? y) "_n"))]
    (apply str (map qf [v1 v2]))))

(defn angle-from-pts
  "Calculates the angle starting at line p3p2 going to line p1p2.
Put another way, the angle is measured following the 'right hand rule' around p2."
  [p1 p2 p3]
  (let [v1 (v- p1 p2)
        v2 (v- p3 p2)
        [v1nx v1ny] (normalize v1)
        [v2nx v2ny] (normalize v2)
        l1 (distance p1 p2)
        l2 (distance p3 p2)
        n (dot* v1 v2)
        d (* l1 l2)]
    (when-not (zeroish? (float d))
      (let [a (to-deg (Math/acos (/ n d)))
            quadrants (check-quadrants p1 p2 p3)]
        (cond
          ;; same quadrant, checking if V2 is before or after V1
          (and (= "pppp" quadrants) (> v2nx v1nx)) a
          (and (= "npnp" quadrants) (> v2nx v1nx)) a
          (and (= "nnnn" quadrants) (< v2nx v1nx)) a
          (and (= "pnpn" quadrants) (< v2nx v1nx)) a
          ;; within same quadrant
          (#{"p_p_" "ppp_" "_ppp" "p_pn"} quadrants) a 
          (#{"_p_p" "np_p" "n_np"} quadrants) a
          (#{"n_n_" "nnn_" "_nnn"} quadrants) a
          (#{"_n_n" "pn_n" "pnp_"} quadrants) a
          ;; one quadrant away
          (#{"npp_" "nn_p" "pnn_" "pp_n"} quadrants) a
          (#{"n_pp" "_nnp" "p_nn" "_ppn"} quadrants) a
          (#{"nppp" "nnnp" "pnnn" "pppn"} quadrants) a
          ;; 90 degrees away on axes
          (#{"_pp_" "n__p" "_nn_" "p__n"} quadrants) a
          ;; two quadrants away
          (and (= "ppnn" quadrants) (> (Math/abs v1nx) (Math/abs v2nx))) a
          (and (= "nnpp" quadrants) (> (Math/abs v1nx) (Math/abs v2nx))) a
          (and (= "pnnp" quadrants) (< (Math/abs v1nx) (Math/abs v2nx))) a
          (and (= "nppn" quadrants) (< (Math/abs v1nx) (Math/abs v2nx))) a
          ;; 180 degrees away on axes
          (#{"p_n_" "_p_n" "n_p_" "_n_p"} quadrants) a
          :else (- 360 a))))))

#+end_src

** intersection
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn line-intersection
  [[pt-a pt-b] [pt-c pt-d]]
  (let [[ax ay] pt-a
        [bx by] pt-b
        [cx cy] pt-c
        [dx dy] pt-d
        xdiff [(- ax bx) (- cx dx)]
        ydiff [(- ay by) (- cy dy)]
        div (determinant xdiff ydiff)]
    (when-not (zeroish? (abs div))
      (let [dets [(determinant pt-a pt-b) (determinant pt-c pt-d)]
            x (/ (determinant dets xdiff) div)
            y (/ (determinant dets ydiff) div)]
        [x y]))))

#+end_src

** corners-tris
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn colinear?
  [a b c]
  (let [ba (v- a b)
        bc (v- c b)
        eps 0.000001]
    (> eps (abs (cross*-k ba bc)))))

(defn corner-condition
  [a b c]
  (let [ba (v- a b)
        bc (v- c b)
        eps 0.000001
        k (cross*-k ba bc)]
    (cond
      (> eps (abs k)) :colinear
      (< eps k) :reflex
      (> (- eps) k) :convex)))

;; https://youtu.be/hTJFcHutls8?t=1473
;; use k component from cross product to quickly check if vector
;; is on right or left of another vector
;; check each triangle edge vector against corner to pt vectors
(defn pt-inside?
  [[a b c] pt]
  (let [ab (v- b a)
        bc (v- c b)
        ca (v- a c)
        apt (v- pt a)
        bpt (v- pt b)
        cpt (v- pt c)]
    (not
     (or (<= (cross*-k ab apt) 0)
         (<= (cross*-k bc bpt) 0)
         (<= (cross*-k ca cpt) 0)))))

#+end_src

** style
Keep the style impl in utils, as it's a super simple fn anyway. Just re-def the transforms version to use utils/style.

#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn style
  [[k props & content] style-map]
  (into [k (merge props style-map)] content))

#+end_src

** centroid
Centroid of a list of points is used in a few places. Having it here keeps it accessible in all namespaces.

#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn centroid-of-pts
  "Calculates the arithmetic mean position of the given `pts`."
  [pts]
  (let [ndim (count (first (sort-by count pts)))
        splits (for [axis (range 0 ndim)]
                 (map #(nth % axis) pts))]
    (mapv #(apply average %) splits)))

#+end_src

** bounds
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn bounds-of-pts
  "Calculates the axis-aligned-bounding-box of `pts`."
  [pts]
  (let [xmax (apply max (map first pts))
        ymax (apply max (map second pts))
        xmin (apply min (map first pts))
        ymin (apply min (map second pts))]
    (vector [xmin ymin]
            [xmax ymin]
            [xmax ymax]
            [xmin ymax])))

(defn bb-dims
  [pts]
  (let [[[xmin ymin] _ [xmax ymax] _] (bounds-of-pts pts)]
    [(- xmax xmin) (- ymax ymin)]))

#+end_src

** offset
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn offset-edge
  [[a b] d]
  (let [p (perpendicular (v- b a))
        pd (v* (normalize p) (repeat (- d)))
        xa (v+ a pd)
        xb (v+ b pd)]
    [xa xb]))

(defn- cycle-pairs
  [pts]
  (let [n (count pts)]
    (vec (take n (partition 2 1 (cycle pts))))))

(defn- wrap-list-once
  [s]
  (conj (drop-last s) (last s)))

(defn- every-other
  [v]
  (let [n (count v)]
    (map #(get v %) (filter even? (range n)))))

(defn offset-pts
  [pts d]
  (let [edges (cycle-pairs pts)
        opts (mapcat #(offset-edge % d) edges)
        oedges (every-other (cycle-pairs opts))
        edge-pairs (cycle-pairs oedges)]
    (wrap-list-once (map #(apply line-intersection %) edge-pairs))))

#+end_src

** scale
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn scale-pt-from-center
  [[x y] [sx sy] [cx cy]]
  [(+ (* (- x cx) sx) cx)
   (+ (* (- y cy) sy) cy)])

#+end_src

** easing-fns
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn ease-in-sin
  [t]
  (- 1 (Math/cos (/ (* Math/PI t) 2))))

(defn ease-out-sin
  [t]
  (Math/sin (/ (* Math/PI t) 2)))

(defn ease-in-out-sin
  [t]
  (/ (- (Math/cos (* Math/PI t)) 1) -2))

#+end_src

** xml->hiccup
The xml->hiccup function causes some issues down the line when it comes to properly displaying SVGs. It works fine if no namespaces are used in the SVG's definition, but will potentially break if they do exist. This becomes an issue when importing from third party sources, such as Inkscape.

It is considered in scope to be able to handle this appropriately, as many users are likely to use externally produced SVGs.

This is necessary for better import behaviour with the Forge library as well.

NOTES on possible solutions:

attributes from the xml parse may look like this:

~[:svg {:xmlns.http%3A%2F%2Fwww.w3.org%2F2000%2Fxmlns%2F/inkscape "http://www.inkscape.org/namespaces/inkscape"}]~

But that renders into html (from hiccup.core) as:

~<svg inkscape=\"http://www.inkscape.org/namespaces/inkscape\"></svg>~

Note the lack of xmlns: prefix. It should look like:

~<svg xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"></svg>~

What does create the proper attr is:

~[:svg {:xmlns:inkscape "http://www.inkscape.org/namespaces/inkscape"}]~

So I need to figure out how to get the proper output either by changing the xml parse-str options, changing the xml parser used (SAXParser ... whatever) and/or changing the hiccup settings. I could also see if it works to emit xml from clojure.data.xml without using hiccup at all.

The following snippet does create an XML string where the namespace prefixes are preserved in the attributes. But the emitted XML doesn't work in a browser unless there is ~xmlns="http://www.w3.org/2000/svg"~ in the svg tag's attributes.

#+begin_src clojure
(-> svg-hiccup
    xml/sexps-as-fragment
    xml/emit-str)
#+end_src


#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn str->number
  [s]
  (let [n (try (read-string s)
               (catch #?(:clj Exception
                         :cljs js/Object) e s))]
    (if (number? n) n s)))

(def numerical-attrs
  #{;; circle, ellipse
    :cx :cy :r :rx :ry
    ;; image, rect
    :width :height :x :y
    ;; line
    :x1 :y1 :x2 :y2})

(defn cast-numerical-attrs
  "Casts certain attribute values to numbers if they are strings.
Attributes to be cast are defined in `numerical-attrs` and include `:cx`, `:cy`, `:width`, etc."
  [attrs]
  (if (empty? attrs)
    {}
    (apply merge
           (map
            (fn [[k v]]
              (if (numerical-attrs k)
                {k (str->number v)}
                {k v}))
            attrs))))

(defn- fix-ns-tag
  [t]
  (let [namespace (namespace t)
        name (name t)]
    (if namespace
      (-> namespace
          (str/split #"\.")
          first
          (str ":" name)
          keyword)
      t)))

(defn xml->hiccup
  [xml]
  (if-let [t (:tag xml)]
    (let [elem [(fix-ns-tag t)]
          elem (conj elem (cast-numerical-attrs (:attrs xml)))]
      (into elem (map xml->hiccup (remove string? (:content xml)))))
    xml))

(defn svg-str->hiccup
  "Parses an SVG string into a Hiccup data structure, keeping all nodes."
  [svg-str]
  (-> svg-str
      (xml/parse-str :namespace-aware false)
      xml->hiccup))

#+end_src

** get-elems
#+begin_src clojure :tangle ./src/svg_clj/utils.cljc
(defn- get-nodes
  "Returns a list of nodes from `zipper` that return `true` from the `matcher` predicate fn.
  The `matcher` fn expects a zipper location, `loc`, and returns `true` (or some value) or `false` (or nil)."
  [zipper matcher]
  (loop [loc zipper
         acc []]
    (if (zip/end? loc)
      acc
      (if (matcher loc)
        (recur (zip/next loc) (conj acc (zip/node loc)))
        (recur (zip/next loc) acc)))))

(defn- elem-node?
  [loc key-set]
  (let [node (zip/node loc)]
    (if (keyword? (first node))
      (not (nil? (key-set (first node)))))))

(defn- hiccup-zip
  [tree]
  (let [branch? #(and (seqable? %) (not (map? %)) (not (string? %)))
        children (fn [x]
                   (let [c (remove map? (rest x))]
                     (when-not (empty? c) c)))
        make-node (fn [_ c] (when-not (empty? c) (vec c)))]
    (zip/zipper branch? children make-node tree)))

(def svg-element-keys #{:circle :ellipse
                        :line :rect
                        :polygon :polyline :path
                        :image :text :g})

(defn get-elems
  "Get SVG elements from `tree`, a Hiccup data structure.
Optionally, pass in a set of keys  as `key-set` to use when matching nodes from the tree."
  ([tree] (get-elems tree svg-element-keys))
  ([tree key-set]
   (let [zipper (hiccup-zip tree)]
    (apply list (get-nodes zipper #(elem-node? % key-set))))))

(defn svg-str->elems
  "Parses an SVG string into a sequence of SVG elements compatible with this library.
Elements are "
  ([svg-str] (svg-str->elems svg-str svg-element-keys))
  ([svg-str key-set]
   (-> svg-str
       (xml/parse-str :namespace-aware false)
       xml->hiccup
       (get-elems key-set))))

#+end_src

* elements
** ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/elements.cljc
(ns svg-clj.elements
  "Provides functions to generate the renderable SVG elements.
  Every function in this namespace emits hiccup style data structures, and have the following shape: `[:tag {:prop \"value\"}]`, except g (group) and text which emit: `[:tag {:prop \"value\"} \"content\"]`.

  All functions in this namespace emit the primitive elements of an SVG image. These primitives are the basis for further manipulation using transform functions from [[svg-clj.transforms]].

  One notable element which is not provided is `path`. Since path elements have a more complex property specification, the [[svg-clj.path]] namespace is dedicated to path element generation."
  (:require [clojure.string :as str]
            [svg-clj.utils :as utils]))

#+END_SRC

** element-keys
#+BEGIN_SRC clojure :tangle ./src/svg_clj/elements.cljc
(def svg-element-keys utils/svg-element-keys)

#+END_SRC

** shapes
A shape is a hiccup data structure that represents one of the valild SVG elements.

 All shape functions will return a vector of the following shape:

 ~[:tag {:props "value"} "content"]~

 The tag and props will always exist, but content may or may not exist. For most geometric shape elements, there is no content. Elements like ~text~ and ~g~ do have content.

 As a general term, I use 'element' to refer to the hiccup vector structure. So, ~[:circle {:r 2}]~ is an element as is ~[:p "some paragraph"]~. The vector ~[2 4]~ is not an element.

 The term 'properties' (sometimes written 'props') refers to the map in the index 1 of a hiccup vector.

 The term 'content' refers to the inner part of a hiccup data structure that is neither the key nor the properties. Content can be nil, length one, or many.

*** circle
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn circle
  "Emits a circle element with radius `r` centered at the origin."
  [r]
  [:circle {:cx 0 :cy 0 :r r}])
#+end_src

*** ellipse
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn ellipse
  "Emits an ellipse element with x-axis radius `rx` and y-axis radius `ry` centered at the origin."
  [rx ry]
  [:ellipse {:cx 0 :cy 0 :rx rx :ry ry}])
#+end_src

*** line
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn line
  "Emits a line element starting at 2d point `pt-a` and ending at 2d point `pt-b`."
  [pt-a pt-b]
  (let [[ax ay] pt-a
        [bx by] pt-b]
    [:line {:x1 ax :y1 ay :x2 bx :y2 by}]))
#+end_src

*** polygon
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn polygon
  "Emits a polygon element with 2d points from vector or list `pts`.
  Polygon elements have a closed path."
  [pts]
  [:polygon {:points (str/join " " (map utils/v->s pts))}])
#+end_src

*** polyline
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn polyline
  "Emits a polyline element with 2d points from vector or list `pts`.
  Polyline elements have an open path."
  [pts]
  [:polyline {:points (str/join " " (map utils/v->s pts))}])

#+end_src

*** rect
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn rect
  "Emits a rect element of width `w` and height `h` centered at the origin."
  [w h]
  [:rect {:width w :height h :x (/ w -2.0) :y (/ h -2.0)}])
#+end_src

** other
*** image
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn image
  "Emits an image element of the image specified at `url`, of width `w`, and height `h` centered at the origin."
  [url w h]
  [:image {:href url :width w :height h :x (/ w -2.0) :y (/ h -2.0)}])
#+end_src

*** text
Text is a bit different. It is much more complicated to know text's centroid and thus local rotation/translation methods for all other shapes don't easily apply. 

So, like path, text is treated as a very simple wrapper, but has (will have) its own functions for better control/manipulation of text elements.

In particular, you cannot know the exact width and height of a text element without being able to fully render the glyphs of the font. This is currently beyond the scope of the existing function below.

#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn text
  "Emits a text element containing `text` of font-size 12pt.
  By default, text is centered at the origin by setting text-anchor='middle' and dominant-baseline='middle'. These defaults can be changed using [[svg-clj.transforms/style]] to override any preset properties."
  [text]
  [:text {:x 0
          :y 0
          :font-size 12
          :text-anchor "middle"
          :dominant-baseline "middle"} text])

#+end_src

*** g
#+begin_src clojure :tangle ./src/svg_clj/elements.cljc
(defn g
  "Emits a g (group) element."
  [& content]
  (if (and (= 1 (count content))
           (not (keyword? (first (first content)))))
    ;; content is a list of a list of elements
    (into [:g {}] (first content))
    ;; content is a single element OR a list of elements
    (into [:g {}] (filter (complement nil?) content))))

#+end_src

* path
The path element has a small DSL to create compound curves. This includes the following (taken from [[https://www.w3schools.com/graphics/svg_path.asp]]):

 M = moveto
 L = lineto
 H = horizontal lineto
 V = vertical lineto
 C = curveto
 S = smooth curveto
 Q = quadratic Bézier curve
 T = smooth quadratic Bézier curveto
 A = elliptical Arc
 Z = closepath

** ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(ns svg-clj.path
  "Provides functions for generating and manipulating SVG path elements.

  Every element provided in [[svg-clj.elements]] has an equivalent function in this namespace that emits path elements with a properly formatted `:d` property.

  The path element has a small Domain Specific Language to create compound shapes and curves. This includes the following commands:

  M = moveto
  L = lineto
  H = horizontal lineto
  V = vertical lineto
  C = curveto
  S = smooth curveto
  Q = quadratic Bézier curve
  T = smooth quadratic Bézier curveto
  A = elliptical Arc
  Z = closepath

  This namespace handles paths by decomposing them into sequences of 'command' maps, which are considered an internal representation; users are not expected to construct paths using commands."
  (:require [clojure.string :as str]
            [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.parametric :as p]))

#+END_SRC

** path
This path function is usable by the user but provides no path generation assistance. There are several functions defined later that handle path generation.

#+begin_src clojure :tangle ./src/svg_clj/path.cljc
(defn path
  "Wraps a path string `d` in a hiccup-style data structure.

  The path string is assumed to already be a valid path string. Users should use path generating functions provided in this namespace for constructing paths in the same manor as the other renderable SVG elements.

  More complex paths can be built by combining paths with the function `merge-paths`"
  [d]
  [:path {:d d :fill-rule "evenodd"}])
#+end_src

** converting-vh
Given a list of commands, go until you find a V or H with a NON V NON H command preceding it.
Use the previous command to get the missing X or Y value
Create an equivalent L command using the recovered coord. and the V or H coord.
Recreate the sequence having swapped the V or H with the new L command.
Repeat this process over the whole sequence.
If the entire sequence has NO V or H, done.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- any-vh?
  [cmds]
  (seq (filter #{"H" "V"} (map :command cmds))))

(defn- convert-vh
  [[pcmd ccmd]]
  (if (and (not (any-vh? [pcmd])) ;;prev. cmd must NOT be VH
           (any-vh? [ccmd])) ;; curr. cmd must be VH
    (let [[px py] (take-last 2 (:input pcmd))
          {:keys [command input coordsys]} ccmd
          xinput (cond
                   (and (= command "H") (= coordsys :abs)) [(first input) py]
                   (and (= command "V") (= coordsys :abs)) [px (first input)]
                   (and (= command "H") (= coordsys :rel)) [(first input) 0]
                   (and (= command "V") (= coordsys :rel)) [0 (first input)])
          ncmd (-> ccmd
                   (assoc :command "L")
                   (assoc :input xinput))]
      [pcmd ncmd])
    [pcmd ccmd]))

(defn- convert-first-vh-cmd
  [cmds]
  (let [icmd (first cmds)]
    (cons icmd 
          (->> cmds
               (partition 2 1)
               (map convert-vh)
               (map second)))))

(defn vh->l
  "Converts any v (vertical) or h (horizontal) commands into l (line) commands.
  This is necessary to allow rotation of a path element, because rotating an axis-aligned line will move it off the axis, making it unrepresentable with v or h commands, as they do not encode the x or y position values respectively."
  [cmds]
  (let [iters (iterate convert-first-vh-cmd cmds)]
    (if (any-vh? cmds)
      (->> iters
           (partition 2 1)
           (take-while (fn [[a b]] (not= a b)))
           last
           last)
      cmds)))

#+END_SRC

** rel->abs
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- any-rel?
  [cmds]
  (seq (filter #{:rel} (map :coordsys cmds))))

(defn- convert-rel
  [[pcmd ccmd]]
  (if (and (= :abs (:coordsys pcmd))
           (= :rel (:coordsys ccmd)))
    (let [{:keys [command input]} ccmd
          abs-cursor (vec (take-last 2 (:input pcmd)))
          xinput (if (= command "A")
                   (vec (concat
                         (drop-last 2 input)
                         (utils/v+ (take-last 2 input) abs-cursor)))
                   (vec (mapcat #(utils/v+ % abs-cursor) (partition 2 input))))
          ncmd (-> ccmd
                   (assoc :coordsys :abs)
                   (assoc :input xinput)
                   (assoc :cursor abs-cursor))]
      [pcmd ncmd])
    [pcmd ccmd]))

(defn- convert-first-rel
  [cmds]
  (let [icmd (first cmds)]
    (cons icmd 
          (->> cmds
               (partition 2 1)
               (map convert-rel)
               (map second)))))

(defn rel->abs
  "Converts any relative coordinate commands into absoulte coordinate commands."
  [cmds]
  (let [iters (iterate convert-first-rel cmds)]
    (if (any-rel? cmds)
      (->> iters
           (partition 2 1)
           (take-while (fn [[a b]] (not= a b)))
           last
           last)
      cmds)))

#+END_SRC

** converting-t
Convert T curve 'shortcut' commands to their full Q command. Run this after rel->abs so that we can guarantee ABS coordinates.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- any-t?
  [cmds]
  (seq (filter #{"T"} (map :command cmds))))

(defn- convert-t
  [[pcmd ccmd]]
  (if (and (= "Q" (:command pcmd))
           (= "T" (:command ccmd)))
    (let [[cpt pt] (partition 2 (:input pcmd))
          ncpt (utils/rotate-pt-around-center cpt 180.0 pt)
          {:keys [command input coordsys]} ccmd
          xinput (vec (concat ncpt input))
          ncmd (-> ccmd
                   (assoc :command "Q")
                   (assoc :input xinput))]
      [pcmd ncmd])
    [pcmd ccmd]))

(defn- convert-first-t-cmd
  [cmds]
  (let [icmd (first cmds)]
    (cons icmd 
          (->> cmds
               (partition 2 1)
               (map convert-t)
               (map second)))))

(defn t->q
  "Converts any T curve commands into Q curve commands."
  [cmds]
  (let [iters (iterate convert-first-t-cmd cmds)]
    (if (any-t? cmds)
      (->> iters
           (partition 2 1)
           (take-while (fn [[a b]] (not= a b)))
           last
           last)
      cmds)))

#+END_SRC

** converting-s
Convert S curve 'shortcut' commands to their full C command. Run this after rel->abs so that we can guarantee ABS coordinates.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- any-s?
  [cmds]
  (seq (filter #{"S"} (map :command cmds))))

(defn- convert-s
  [[pcmd ccmd]]
  (if (and (= "C" (:command pcmd))
           (= "S" (:command ccmd)))
    (let [[_ cpt pt] (partition 2 (:input pcmd))
          ncpt (utils/rotate-pt-around-center cpt 180.0 pt)
          {:keys [command input coordsys]} ccmd
          xinput (vec (concat ncpt input))
          ncmd (-> ccmd
                   (assoc :command "C")
                   (assoc :input xinput))]
      [pcmd ncmd])
    [pcmd ccmd]))

(defn- convert-first-s-cmd
  [cmds]
  (let [icmd (first cmds)]
    (cons icmd 
          (->> cmds
               (partition 2 1)
               (map convert-s)
               (map second)))))

(defn s->c
  "Converts any S curve commands into C curve commands."
  [cmds]
  (let [iters (iterate convert-first-s-cmd cmds)]
    (if (any-s? cmds)
      (->> iters
           (partition 2 1)
           (take-while (fn [[a b]] (not= a b)))
           last
           last)
      cmds)))

#+END_SRC

** commands
Path strings are a sequence of commands. These commands can be thought of as moving a pen along the canvas to draw shapes/lines according to the command's inputs.

The order of these commands must be maintained, otherwise the shape will be drawn differently.

I'm going to make a few functions to split paths into commands and put them in a clojure map.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- path-cmd-strs
  "Split the path string `ps` into a vector of path command strings."
  [ps]
  (-> ps
      (str/replace #"\n" " ")
      (str/split #"(?=[A-DF-Za-df-z])")
      (#(map str/trim %))
      (#(filter (complement empty?) %))))

(defn- relative?
  "Returns true if the path command string `cs` has a relative coordinate command.
  Relative coordinate commands are lowercase in the `d` property string.
  Absolute coordinate commands are uppercase in the `d` property string."
  [cs]
  (let [csx (first (str/split cs #"[a-df-z]"))]
    (not (= cs csx))))

(defn- coord-sys-key
  "Returns the command string `cs`'s coord. system key.
  Key is either :rel or :abs."
  [cs]
  (if (relative? cs) :rel :abs))

(defn- cmd-input
  [cs]
  (let [i (str/split cs #"[A-DF-Za-df-z]")]
    (when (seq (rest i))
      (apply utils/s->v (rest i)))))

(defn- cmd-str->cmd
  "Transforms a command string `cs` into a map."
  [cs]
  {:command  (str/upper-case (re-find #"[A-DF-Za-df-z]" cs))
   :coordsys (coord-sys-key cs)
   :input (cmd-input cs)})

(defn- merge-cursor
  [[pcmd ccmd]]
  (let [cursor (vec (take-last 2 (:input pcmd)))]
    (assoc ccmd :cursor cursor)))

(defn path-str->cmds
  "Turns path string `ps` into a list of its command maps."
  [ps]
  (->> ps
       path-cmd-strs
       (map cmd-str->cmd)
       (concat [{:command "M"
                 :coordsys :abs
                 :input [0 0]}])
       (partition 2 1)
       (map merge-cursor)
       vh->l
       rel->abs
       t->q
       s->c))

#+END_SRC

** build-path-strings
Given a sequence of command maps, produce a path string.

Then, we can losely consider a sequence of command maps to be the internal data structure for path manipulation. This means you can create multi-path path strings by passing a sequence of sequences of command maps.

For each cmd seq., convert to path-string, then apply string to concatenate these path strings into the final string. You can alternatively treat each path string as the attribute for a new path element and draw them separately.

The requirement is that if a user puts a path string into the system but does not transform it in any way, they should expect an equivalent string to be emitted from the cmds->str fn.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- cmd->path-string
  [{:keys [:command :coordsys :input]}]
  (let [c (if (= coordsys :abs)
            command
            (str/lower-case command))]
    (str c (str/join " " input))))

(defn cmds->path-string
  "Generates a valid string for the path element `:d` property from a list of command maps `cmds`."
  [cmds]
  (let [start (first cmds)
        cmds (if (= "M" (:command start))
               cmds
               (let [new-start {:command "M"
                                :coordsys :abs
                                :input (:cursor start)
                                :cursor [0 0]}]
                 (concat [new-start] cmds)))]
    (when (> (count cmds) 1)
      (str/join " " (map cmd->path-string cmds)))))

#+END_SRC

** partial-commands
The polygon-path function is a way to create valid path strings from a set of points. The idea is that any call to the polygon fn can be replaced with polygon-path and no visual difference would occur.

Then, paths can be further manipulated by combine and merge.

Convert list of pts into list of commands.
 - first command will be a MOVE command
 - last command will be a CLOSE command
   - can generalize this to polyline by having a close? flag

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- pt->l
  [pt]
  {:command "L"
   :coordsys :abs
   :input (vec pt)})

(defn- pt->m
  [pt]
  {:command "M"
   :coordsys :abs
   :input (vec pt)})

#+END_SRC

** shapes
*** bezier
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn bezier
  "Emits a path element with a bezier curve defined by the control points `a`, `b`, `c`, and sometimes `d`.
   Quadratic curves use 3 control points, and cubic curves use 4 control points."
  ([a b c]
   (let [open (pt->m a)]
     (-> {:command "Q"
          :coordsys :abs
          :input (concat b c)}
         list
         (conj open)
         vec
         cmds->path-string
         path)))

  ([a b c d]
   (let [open (pt->m a)]
     (-> {:command "C"
          :coordsys :abs
          :input (concat b c d)}
         list
         (conj open)
         vec
         cmds->path-string
         path))))
 #+END_SRC

*** arc
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- build-arc
  [rx ry rot laf sw a b]
  (let [open (pt->m a)]
    (-> {:command "A"
         :coordsys :abs
         :input (concat [rx ry rot laf sw] b)}
        list
        (conj open)
        vec
        cmds->path-string
        path)))

(defn arc
  "Emits a path element with an arc starting at `pt-a` and ending at a point rotated by degrees, `deg`, around `ctr` in the counter-clockwise direction."
  [pt-a ctr deg]
  (let [r (utils/distance pt-a ctr)
        angle 0
        b (utils/rotate-pt-around-center pt-a deg ctr)
        laf (if (<= deg 180) 0 1)]
     (build-arc r r angle laf 1 pt-a b)))

#+END_SRC

*** circle
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn circle
  "Emits a circle using two arcs in a path element with radius `r` centered at the origin."
  [r]
  (let [open (pt->m [r 0])
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> [open
         {:command "A"
          :coordsys :abs
          :input [r r 0 1 0 0 r]}
         {:command "A"
          :coordsys :abs
          :input [r r 0 1 0 (- r) 0]}
         {:command "A"
          :coordsys :abs
          :input [r r 0 1 0 0 (- r)]}
         {:command "A"
          :coordsys :abs
          :input [r r 0 1 0 r 0]}
         close]
        cmds->path-string
        path)))

#+END_SRC

*** ellipse
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn ellipse
  "Emits an ellipse element with x-axis radius `rx` and y-axis radius `ry` centered at the origin."
  [rx ry]
  (let [open (pt->m [rx 0])
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> [open
         {:command "A"
          :coordsys :abs
          :input [rx ry 0 1 0 0 ry]}
         {:command "A"
          :coordsys :abs
          :input [rx ry 0 1 0 (- rx) 0]}
         {:command "A"
          :coordsys :abs
          :input [rx ry 0 1 0 0 (- ry)]}
         {:command "A"
          :coordsys :abs
          :input [rx ry 0 1 0 rx 0]}
         close]
        cmds->path-string
        path)))

#+END_SRC

*** line
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn line
  "Emits a line using a path element starting at 2d point `pt-a` and ending at 2d point `pt-b`."
  [pt-a pt-b]
  (-> [(pt->m pt-a) (pt->l pt-b)]
      cmds->path-string
      path))
#+END_SRC

*** polygon
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn polygon
  "Emits a polygon using a path element with 2d points from vector or list `pts`.
  Polygons use a closed path."
  [pts]
  (let [open (pt->m (first pts))
        close {:command "Z"
               :coordsys :abs
               :input nil}]
    (-> (map pt->l (rest pts))
        (conj open)
        vec
        (conj close)
        cmds->path-string
        path)))
#+END_SRC

*** polyline
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn polyline
  "Emits a polyline using a path element with 2d points from vector or list `pts`.
  Polylines use an open path."
  [pts]
  (let [open (pt->m (first pts))]
    (-> (map pt->l (rest pts))
        (conj open)
        vec
        cmds->path-string
        path)))
#+END_SRC

*** rect
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn rect
  "Emits a rectangle using a path element of width `w` and height `h` centered at the origin."
  [w h]
  (let [w2 (/ w 2.0)
        h2 (/ h 2.0)]
    (polygon [ [(- w2) (- h2)] [w2 (- h2)] 
               [w2 h2]          [(- w2) h2] ])))
#+END_SRC

** transforms
Path transforms have to be implemented here. They will be used in the transforms namespace through the multimethods to keep the interface consistent for users.

*** cmd->pts
For transforms, it is necessary to extract basic point data from commands. In general, all commands have simple point data. The exception is arcs, which need some calculation.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defmulti cmd->pts :command)

(defmethod cmd->pts :default
  [{:keys [input]}]
  (mapv vec (partition 2 input)))

;; this is not implemented correctly yet.
;; just a 'stub' returning the end point of the arc
(defmethod cmd->pts "A"
  [{:keys [input cursor]}]
  (let [[rx ry deg laf sw x y] input
        b [x y]
        ctr (utils/v+ cursor [rx 0])
        sa (utils/angle-from-pts cursor ctr b)
        angle (if (= 1 laf) (- 360 sa) sa)
        mids (mapv #(utils/rotate-pt-around-center cursor % ctr) (rest (range 0 angle 90)))]
    [cursor b] #_(conj mids b)))

#+END_SRC

*** centroid
The first idea for calculating path centroid is to get all point data from every command, mapcat them together, and just run centroid-of-pts on that list of points.

I don't know yet if the 'easy' method will be accurate for paths that contain curves and arcs. It is possible that the centroid calculated by pts/control points is not accurate.

Ideas to keep in mind:
- parametric bezier curve, sample t and regular interval to build a polyline approximating the curve, and calculate centroid from those pts
- tessellate the whole path and get centroids of every triangle, then centroid of centroids... should be ok

#+begin_src clojure :tangle ./src/svg_clj/path.cljc
(defn centroid
  [[_ props]]
  (let [cmds (path-str->cmds (:d props))
        pts (mapcat cmd->pts cmds)]
    (utils/centroid-of-pts (vec (into #{} pts)))))
#+end_src

*** bounds
#+begin_src clojure :tangle ./src/svg_clj/path.cljc
(defn bounds
  [[_ props]]
  (let [cmds (path-str->cmds (:d props))
        pts (mapcat cmd->pts cmds)]
    (utils/bounds-of-pts pts)))

#+end_src

*** translate
I have a multimethod to handle different commands that can show up in a path string. Command data structures are produced using the path-dsl functions defined earlier.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defmulti translate-path-command
  (fn [cmd _]
    (:command cmd)))

(defmethod translate-path-command "M"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

(defmethod translate-path-command "L"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

(defmethod translate-path-command "H"
  [{:keys [:input] :as m} [x _]]
  (assoc m :input (utils/v+ [x] input)))

(defmethod translate-path-command "V"
  [{:keys [:input] :as m} [_ y]]
  (assoc m :input (utils/v+ [y] input)))

;; x y x y x y because input will ahve the form:
;; [x1 y1 x2 y2 x y] (first two pairs are control points)
(defmethod translate-path-command "C"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y x y] input)))

;; similar approach to above, but one control point is implicit
(defmethod translate-path-command "S"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y] input)))

(defmethod translate-path-command "Q"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y] input)))

(defmethod translate-path-command "T"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod translate-path-command "A"
  [{:keys [:input] :as m} [x y]]
  (let [[rx ry xrot laf swf ox oy] input]
    (assoc m :input [rx ry xrot laf swf (+ x ox) (+ y oy)])))

(defmethod translate-path-command "Z"
  [cmd _]
  cmd)

(defmethod translate-path-command :default
  [cmd a]
  [cmd a])

(defn translate
  [[k props] [x y]]
  (let [cmds (path-str->cmds (:d props))
        xcmds (map #(translate-path-command % [x y]) cmds)]
    [k (assoc props :d (cmds->path-string xcmds))]))

#+END_SRC

*** rotate
To complete the translate implementation, I have to make sure path elements can be propery handled.

To do this, I have a second multimethod to handle different commands that can show up in a path string. Command data structures are produced using the path-dsl functions defined earlier.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defmulti rotate-path-command
  (fn [cmd _ _]
    (:command cmd)))

(defmethod rotate-path-command "M"
  [{:keys [:input] :as m} ctr deg]
  (let [xpt (-> input
                (utils/v- ctr)
                (utils/rotate-pt deg)
                (utils/v+ ctr))]
    (assoc m :input xpt)))

(defmethod rotate-path-command "L"
  [{:keys [:input] :as m} ctr deg]
  (let [xpt (-> input
                (utils/v- ctr)
                (utils/rotate-pt deg)
                (utils/v+ ctr))]
    (assoc m :input xpt)))

(defmethod rotate-path-command "C"
  [{:keys [:input] :as m} ctr deg]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(utils/rotate-pt % deg))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "S"
  [{:keys [:input] :as m} ctr deg]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(utils/rotate-pt % deg))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "Q"
  [{:keys [:input] :as m} ctr deg]
  (let [xinput (->> input
                    (partition 2)
                    (map vec)
                    (map #(utils/v- % ctr))
                    (map #(utils/rotate-pt % deg))
                    (map #(utils/v+ % ctr))
                    (apply concat))]
    (assoc m :input xinput)))

(defmethod rotate-path-command "T"
  [{:keys [:input] :as m} ctr deg]
  (let [xpt (-> input
                (utils/v- ctr)
                (utils/rotate-pt deg)
                (utils/v+ ctr))]
    (assoc m :input xpt)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod rotate-path-command "A"
  [{:keys [:input] :as m} ctr deg]
  (let [[rx ry xrot laf swf ox oy] input
        [nx ny] (-> [ox oy]
                    (utils/v- ctr)
                    (utils/rotate-pt deg)
                    (utils/v+ ctr))]
    (assoc m :input [rx ry (+ xrot deg) laf swf nx ny])))

(defmethod rotate-path-command "Z"
  [cmd _ _]
  cmd)

(defn rotate
  [[k props] deg]
  (let [ctr (centroid [k props])
        cmds (path-str->cmds (:d props))
        xcmds (map #(rotate-path-command % ctr deg) cmds)]
    [k (assoc props :d (cmds->path-string xcmds))]))

#+END_SRC

*** scale
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defmulti scale-path-command
  (fn [cmd _ _]
    (:command cmd)))

(defmethod scale-path-command :default
  [{:keys [:input] :as m} [sx sy] ctr]
  (let [pts (mapv vec (partition 2 input))
        xpts (->> pts
                  (mapcat #(utils/scale-pt-from-center % [sx sy] ctr)))]
    (assoc m :input (vec xpts))))

;; this is wrong. just a stub to get moving a bit
(defmethod scale-path-command "A"
  [{:keys [:input] :as m} [sx sy] ctr]
  (let [pts [(take-last 2 input)]
        xpts (->> pts
                  (mapcat #(utils/scale-pt-from-center % [sx sy] ctr)))]
    (assoc m :input (vec xpts))))

(defn scale
  [[k props] [sx sy]]
  (let [ctr (centroid [k props])
        cmds (path-str->cmds (:d props))
        xcmds (map #(scale-path-command % [sx sy] ctr) cmds)]
    [k (assoc props :d (cmds->path-string xcmds))]))

#+END_SRC

** path-manipulations
Path manipulations might be better in the path namespace.

*** split-explode
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn split-path
  "Splits a single path element containing multiple disjoint paths into a group of paths containing only one path."
  [[k props]]
  (let [ps (-> (:d props)
               (str/split #"(?=M)")
               (->> (map str/trim)))]
    (map #(assoc-in [k props] [1 :d] %) ps)))

(defn explode-path
  "Breaks a path element into its constituent curves.
  Optional arg `break-polys?` is `false` by default, which treats sequences of line segments as polylines.
  Setting `break-polys?` to `true` treats sequences of line segments as individual elements."
  [[_ {:keys [d]}] & {:keys [break-polys?]}]
  (let [break-fn (if break-polys?
                   (partial partition 1)
                   (partial partition-by :command))]
    (->> d
         path-str->cmds
         vh->l
         break-fn
         (map cmds->path-string)
         (filter some?)
         (map path))))

#+END_SRC

*** cmds->elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- bezier-cmd-pts
  [{:keys [input cursor]}]
  (let [control-pts (partition 2 (concat cursor input))
        c (p/bezier control-pts)]
    (map c (range 0 1.05 0.05))))

(defn- cmds->elements
  [cmds]
  (let [start (first cmds)
        cmds (if (= "M" (:command start))
               cmds
               (let [new-start {:command "M"
                                :coordsys :abs
                                :input (:cursor start)
                                :cursor [0 0]}]
                 (concat [new-start] cmds)))]
    (when (> (count cmds) 1)
      (let [cs (map :command (rest cmds))]
        (cond
          ;; empty
          (and (= (count cmds) 2)
               (empty? (remove #{"Z"} cs)))
          nil

          ;; circle or ellipse
          (and (= (count cmds) 6)
               (empty? (remove #{"A" "Z"} cs)))
          (let [eps 0.00001
                [rx ry] (take 2 (:input (second cmds)))
                [x y] (take-last 2 (:input (second cmds)))
                [cx cy] (utils/v* [1.0 1.0] (utils/centroid-of-pts (set (mapcat cmd->pts cmds))))]
            (if (< (Math/abs (- rx ry)) eps)
              [:circle {:cx cx :cy cy :r rx}]
              [:ellipse {:cx cx :cy cy :rx rx :ry ry}]))

          ;; line
          (and (= (count cmds) 2)
               (empty? (remove #{"L"} cs)))
          (apply el/line (map :input cmds))

          ;; polyline
          (and (> (count cmds) 2)
               (empty? (remove #{"L"} cs)))
          (el/polyline (map :input cmds))

          ;; polygon
          (and (> (count cmds) 2)
               (empty? (remove #{"L" "Z"} cs)))
          (el/polygon (map :input cmds))

          ;; Quadratic or Cubic Bezier Curve(s)
          (or (empty? (remove #{"Q"} cs))
              (empty? (remove #{"C"} cs)))
          (let [pts (mapcat bezier-cmd-pts (rest cmds))]
            (el/polyline pts))

          ;; Quadratic or Cubic Bezier Curve(s) closed path
          (or (empty? (remove #{"Q" "Z"} cs))
              (empty? (remove #{"C" "Z"} cs)))
          (let [pts (mapcat bezier-cmd-pts (drop-last (rest cmds)))]
            (el/polygon pts))
          
          :else
          (path (cmds->path-string cmds)))))))

#+END_SRC

*** merge-paths
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- clean-m-cmds-threshold
  "Remove cmdb if it is an M command with the same position as the last input of cmda."
  [[cmda cmdb]]
  (let [merge-dist 1.0
        [pa pb] (map (comp (partial take-last 2) :input) [cmda cmdb])
        [ca cb] (map :command [cmda cmdb])]
    (cond
      (= "M" ca) [] ;; discard M in first position always
      (and (< (utils/distance pa pb) merge-dist) (= "M" cb)) [cmda]
      :else [cmda cmdb])))

(defn- clean-m-cmds
  "Remove cmdb if it is an M command with the same position as the last input of cmda."
  [[cmda cmdb]]
  (let [[pa pb] (map (comp (partial take-last 2) :input) [cmda cmdb])
        [ca cb] (map :command [cmda cmdb])]
    (cond
      (= "M" ca) [] ;; discard M in first position always
      (and (= pa pb) (= "M" cb)) [cmda]
      :else [cmda cmdb])))

(defn merge-paths
  "Merges a list of path elements together, keeping props from last path in the list."
  [& paths]
  (let [[_ props] (last paths)
        cmds (mapcat #(path-str->cmds (get-in % [1 :d])) paths)
        xf-cmds
        (conj 
         (remove nil? (mapcat clean-m-cmds-threshold (partition 2 1 (rest cmds))))
         (first cmds))]
    [:path (assoc props :d (cmds->path-string xf-cmds))]))

#+END_SRC

*** path->elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- get-subpaths
  [cmds]
  (->> cmds
       (partition-by  #((complement #{"M"}) (:command %)))
       (partition 2)
       (map #(apply concat %))))

(defn- subpath->elements
  [cmds]
  (let [split-path (partition-by :command cmds)
        cmd-check (into #{} (map #(:command (first %)) split-path))]
    (if (or (= cmd-check #{"M" "L" "Z"})
            (= cmd-check #{"M" "A" "Z"})
            (= cmd-check #{"M" "L"}))
      (cmds->elements cmds)
      (let [subpath (->> cmds
                         (remove #(#{"M" "Z"} (:command %)))
                         (partition-by :command)
                         (map cmds->elements)
                         (remove nil?))]
        (apply el/g
         (conj
          (vec subpath)
          (when (= "Z" (:command (last cmds)))
            (let [[s e] (map #(take-last 2 (:input %))
                             [(first cmds) (last (drop-last cmds))])]
              (el/line s e)))))))))

(defn path->elements
  [[_ {:keys [d]}]]
  (->> d
       path-str->cmds
       get-subpaths
       (map subpath->elements)
       (remove nil?)))

#+END_SRC

*** element->path
#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defmulti element->path
  (fn [element]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod element->path :list
  [elems]
  (map element->path elems))

(defmethod element->path :circle
  [[_ {:keys [cx cy r] :as props}]]
  (-> (circle r)
      (translate [cx cy])
      (utils/style (dissoc props :cx :cy :r))))

(defmethod element->path :ellipse
  [[_ {:keys [cx cy rx ry] :as props}]]
  (-> (ellipse rx ry)
      (translate [cx cy])
      (utils/style (dissoc props :cx :cy :rx :ry))))

(defmethod element->path :rect
  [[_ {:keys [width height x y] :as props}]]
  (let [ctr (utils/v+ [x y] [(/ width 2.0) (/ height 2.0)])]
    (-> (rect width height)
        (translate ctr)
        (utils/style (dissoc props :width :height :x :y)))))

(defmethod element->path :line
  [[_ {:keys [x1 y1 x2 y2] :as props}]]
  (-> (line [x1 y1] [x2 y2])
      (utils/style (dissoc props :x1 :y1 :x2 :y2))))

(defmethod element->path :polyline
  [[_ {:keys [points] :as props}]]
  (let [pts (partition 2 (utils/s->v points))]
    (-> (polyline pts)
        (utils/style (dissoc props :points)))))

(defmethod element->path :polygon
  [[_ {:keys [points] :as props}]]
  (let [pts (partition 2 (utils/s->v points))]
    (-> (polygon pts)
        (utils/style (dissoc props :points)))))

(defmethod element->path :path
  [elem]
  elem)

#+END_SRC

*** element->path groups
Element to path for groups will map element->path on all elements within the group and then merge those paths into a single path.

This is done to properly 'group' connected sub-paths, and handle the case where different elements are 'chained' together to form a closed path. The check for a closed path assumes that if the first point and last point are equal, then the group of elements was originally meant to be closed, and so will close it.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn- needs-closing?
  [path]
  (let [cmds (path-str->cmds (get-in path [1 :d]))
        start (->> cmds first :input (take-last 2))
        end (->> cmds last :input (take-last 2))]
    (= start end)))

(defmethod element->path :g
  [[_ props & elems]]
  (let [p (apply merge-paths (map element->path elems))]
    (if (needs-closing? p)
      (->> elems
           drop-last
           (map element->path)
           (apply merge-paths)
           (#(utils/style % props)))
      (-> p
          (utils/style props)))))

(defn elements->path
  [elems]
  (apply merge-paths (map element->path elems)))

#+END_SRC

*** decurve
Turns any bezier or arc commands into approximated versions using straight segments.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/path.cljc
(defn decurve
  [path]
  (->> (path->elements path)
       (map element->path)
       (apply merge-paths)))

#+END_SRC

* transforms
Computations refer to calculatable properties of svg elements. They are bounds and centroid.

Transforms are translate, rotate, and scale. All transforms work well for most objects (:g and :text are exceptions). They all transform about the object's center point. This has the effect of 'local first' transformation.

This leads to challenges with groups. Groups must have their centroid calculated such that rotation and translation can correctly occur about the group's centroid. Internally, this means that the group's centroid is treated as the 'temporary global origin' and all objects are globally rotated about that temp. origin. This has the appearance of a group rotating locally, which is the intended outcome.

** ns
#+begin_src clojure :tangle ./src/svg_clj/transforms.cljc
(ns svg-clj.transforms
  "Provides functions for computing and transforming properties of the SVG elements created by the `elements`, `path`, and `composites` namespaces.

  The most common transformations include translate, rotate, style, and scale which all work on every element. Other transformations include merge, split, and explode and these only work on path elements.

  This namespace also provides `bounds`, and `centroid` functions which calculate the respective property for all elements provided by this library."
  (:require [clojure.string :as str]   
            [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.path :as path]
            #?(:cljs
               [cljs.reader :refer [read-string]])))

#+end_src

** style
Style transforms allow the user to change any attributes of svg elements that affect appearance. For instance, stroke color, stroke width, and fill.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn style
  [elem style-map]
  (utils/style elem style-map))

#+END_SRC

** centroid
*** centroid-elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti centroid
  (fn [element]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod centroid :list
  [elems]
  (utils/centroid-of-pts (into #{} (map centroid elems))))

(defmethod centroid :circle
  [[_ props]]
  [(:cx props) (:cy props)])  

(defmethod centroid :ellipse
  [[_ props]]
  [(:cx props) (:cy props)])

(defmethod centroid :line
  [[_ props]]
  (let [a (mapv #(get props %) [:x1 :y1])
        b (mapv #(get props %) [:x2 :y2])]
    (utils/centroid-of-pts [a b])))

(defmethod centroid :polygon
  [[_ props]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))]
    (utils/centroid-of-pts pts)))

(defmethod centroid :polyline
  [[_ props]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))]
    (utils/centroid-of-pts pts)))

(defmethod centroid :rect
  [[_ props]]
  [(+ (:x props) (/ (:width  props) 2.0))
   (+ (:y props) (/ (:height props) 2.0))])

(defmethod centroid :image
  [[_ props]]
  [(+ (:x props) (/ (:width  props) 2.0))
   (+ (:y props) (/ (:height props) 2.0))])

;; this is not done yet. Text in general needs a redo.
(defmethod centroid :text
  [[_ props _]]
  [(:x props) (:y props)])

(defmethod centroid :path
  [elem]
  (path/centroid elem))

#+end_src

*** centroid-group
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(declare centroid)
(defmethod centroid :g
  [[_ _ & content]]
  (utils/centroid-of-pts (into #{} (map centroid content))))

#+END_SRC

** bounds
*** bounds-elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti bounds
  "Calculates the axis-aligned-bounding-box of `element` or list of elements."
  (fn [element]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod bounds :default
  [_]
  [[-1 -1] [1 -1] [1 1] [-1 1]])

(defmethod bounds :list
  [elems]
  (utils/bounds-of-pts (mapcat bounds elems)))

(defmethod bounds :circle
  [[_ props]]
  (let [c [(:cx props) (:cy props)]
        r (:r props)
        pts (mapv #(utils/v+ c %) [[r 0]
                             [0 r]
                             [(- r) 0]
                             [0 (- r)]])]
    (utils/bounds-of-pts pts)))

(defmethod bounds :ellipse
  [[_ props]]
  (let [xf (utils/str->xf-map  (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        c [(:cx props) (:cy props)]
        rx (:rx props)
        ry (:ry props)
        pts (mapv #(utils/v+ c %) [[rx 0]
                                   [0 ry] 
                                   [(- rx) 0]
                                   [0 (- ry)]])
        bb (utils/bounds-of-pts pts)
        obb (mapv #(utils/rotate-pt-around-center % deg [mx my]) bb)
        xpts (mapv #(utils/rotate-pt-around-center % deg [mx my]) pts)
        small-bb (utils/bounds-of-pts xpts)
        large-bb (utils/bounds-of-pts obb)]
    ;; not accurate, but good enough for now
    ;; take the bb to be the average between the small and large
    (utils/bounds-of-pts (mapv #(utils/centroid-of-pts [%1 %2]) small-bb large-bb))))

(defmethod bounds :line
  [[_ props]]
  (let [a (mapv #(get props %) [:x1 :y1])
        b (mapv #(get props %) [:x2 :y2])]
    (utils/bounds-of-pts [a b])))

(defmethod bounds :polygon
  [[_ props]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))]
    (utils/bounds-of-pts pts)))

(defmethod bounds :polyline
  [[_ props]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))]
    (utils/bounds-of-pts pts)))

(defmethod bounds :rect
  [[_ props]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        x (:x props)
        y (:y props)
        w (:width props)
        h (:height props)
        pts [[x y]
             [(+ x w) y]
             [(+ x w) (+ y h)]
             [x (+ y h)]]
        xpts (mapv #(utils/rotate-pt-around-center % deg [mx my]) pts)]
    (utils/bounds-of-pts xpts)))

(defmethod bounds :image
  [[_ props]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        mx (get-in xf [:rotate 1])
        my (get-in xf [:rotate 2])
        x (:x props)
        y (:y props)
        w (:width props)
        h (:height props)
        pts [[x y]
             [(+ x w) y]
             [(+ x w) (+ y h)]
             [x (+ y h)]]
        xpts (mapv #(utils/rotate-pt-around-center % deg [mx my]) pts)]
    (utils/bounds-of-pts xpts)))

;; this is not done yet. Text in general needs a redo.
;; Austin is a headless browser that may help with .getBBox???
(defmethod bounds :text
  [[_ {:keys [x y font-size ] :as props} text]]
  (let [xf (utils/str->xf-map (get props :transform "rotate(0 0 0)"))
        deg (get-in xf [:rotate 0])
        ar 0.6
        h (read-string (str font-size))
        hh (/ h 2.0)
        hw (/ (* ar h (count text)) 2.0)
        pts [ [(- x hw) (- y hh)]
             [(+ x hw) (- y hh)]
             [(+ x hw) (+ y hh)]
             [(- x hw) (+ y hh)] ]
        xpts (mapv #(utils/rotate-pt-around-center % deg [x y]) pts)]
    (utils/bounds-of-pts xpts)))

(defmethod bounds :path
  [elem]
  (path/bounds elem))
  
#+END_SRC

*** bounds-group
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(declare bounds)
(defmethod bounds :g
  [[_ _ & content]]
  (utils/bounds-of-pts (mapcat bounds content)))

(defn bb-dims
  [element]
  (let [[[xmin ymin] _ [xmax ymax] _] (bounds element)]
    [(- xmax xmin) (- ymax ymin)]))

#+END_SRC

** translate
*** translate-elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn- get-props
  [props]
  (merge {:rotate [0 0 0]} (utils/str->xf-map (get props :transform))))

(defmulti translate
  (fn [element _]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod translate :list
  [elems [x y]]
  (map #(translate % [x y]) elems))

(defmethod translate :circle
  [[k props] [x y]]
  (let [xf (get-props props)
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate :ellipse
  [[k props] [x y]]
  (let [xf (get-props props)
        cx (:cx props)
        cy (:cy props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ x cx))
                   (assoc-in [:rotate 2] (+ y cy)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :cx + x)
                      (update :cy + y))]
    [k new-props]))

(defmethod translate :line
  [[k props] [x y]]
  (let [new-props (-> props
                      (update :x1 + x)
                      (update :y1 + y)
                      (update :x2 + x)
                      (update :y2 + y))]
    [k new-props]))

(defmethod translate :polygon
  [[k props] [x y]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))
        xpts (->> pts
                  (map (partial utils/v+ [x y]))
                  (map utils/v->s))]
    [k (assoc props :points (str/join " " xpts))]))

(defmethod translate :polyline
  [[k props] [x y]]
  (let [pts (mapv utils/s->v (str/split (:points props) #" "))
        xpts (->> pts 
                  (map (partial utils/v+ [x y]))
                  (map utils/v->s))]
    [k (assoc props :points (str/join " " xpts))]))

(defmethod translate :rect
  [[k props] [x y]]
  (let [[cx cy] (centroid [k props])
        xf (get-props props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ cx x))
                   (assoc-in [:rotate 2] (+ cy y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate :image
  [[k props] [x y]]
  (let [[cx cy] (centroid [k props])
        xf (get-props props)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (+ cx x))
                   (assoc-in [:rotate 2] (+ cy y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props]))

(defmethod translate :text
  [[k props text] [x y]]
  (let [xf (get-props props)
        new-xf (-> xf
                   (update-in [:rotate 1] + x)
                   (update-in [:rotate 2] + y))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (update :x + x)
                      (update :y + y))]
    [k new-props text]))

(defmethod translate :path
  [elem [x y]]
  (path/translate elem [x y]))

#+END_SRC

*** translate-group
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
#_(declare translate)
(defmethod translate :g
  [[k props & content] [x y]]
  (->> content
       (map #(translate % [x y]))
       (filter (complement nil?))
       (into [k props])))

#+END_SRC

** rotate
*** rotate-elements
Rotate-element-by-transform leaves 'nil' for content. I filtered that out, but I suspect there's a cleaner way to do it.

Consider refactor at some point.

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn rotate-element-by-transform
  "Rotate an element by using the SVG transform property.
  This function is used to transform elements that cannot 'bake' the transform into their other geometric properties. For example, the ellipse and circle elements have only center and radius properties which cannot affect orientation."
  [[k props content] deg]
  (let [xf (get-props props)
        new-xf (-> xf
                   (update-in [:rotate 0] + deg))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    (vec (filter (complement nil?) [k new-props (when content content)]))))

(defmulti rotate
  (fn [element _]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod rotate :list
  [elems deg]
  (map #(rotate % deg) elems))

(defmethod rotate :circle
  [[k props] deg]
  (rotate-element-by-transform [k props] deg))

(defmethod rotate :ellipse
  [[k props] deg]
  (rotate-element-by-transform [k props] deg))

(defmethod rotate :line
  [[k props] deg]
  (let [pts [[(:x1 props) (:y1 props)] [(:x2 props) (:y2 props)]]
        [[x1 y1] [x2 y2]]  (->> pts
                                (map #(utils/v- % (utils/centroid-of-pts pts)))
                                (map #(utils/rotate-pt % deg))
                                (map #(utils/v+ % (utils/centroid-of-pts pts))))
        new-props (assoc props :x1 x1 :y1 y1 :x2 x2 :y2 y2)]
    [k new-props]))

(defmethod rotate :polygon
  [[k props] deg]
  (let [ctr (centroid [k props])
        pts (mapv utils/s->v (str/split (:points props) #" "))
        xpts (->> pts
                  (map #(utils/v- % ctr))
                  (map #(utils/rotate-pt % deg))
                  (map #(utils/v+ % ctr))
                  (map utils/v->s))
        xprops (assoc props :points (str/join " " xpts))]
    [k xprops]))

(defmethod rotate :polyline
  [[k props] deg]
  (let [ctr (centroid [k props])
        pts (mapv utils/s->v (str/split (:points props) #" "))
        xpts (->> pts
                  (map #(utils/v- % ctr))
                  (map #(utils/rotate-pt % deg))
                  (map #(utils/v+ % ctr))
                  (map utils/v->s))
        xprops (assoc props :points (str/join " " xpts))]
    [k xprops]))

(defmethod rotate :rect
  [[k props] deg]
  (let [[cx cy] (centroid [k props])
        xf (get-props props)
        new-xf (-> xf
                   (update-in [:rotate 0] + deg)
                   (assoc-in  [:rotate 1] cx)
                   (assoc-in  [:rotate 2] cy))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props]))

(defmethod rotate :image
  [[k props] deg]
  (let [[cx cy] (centroid [k props])
        xf (get-props props)
        new-xf (-> xf
                   (update-in [:rotate 0] + deg)
                   (assoc-in  [:rotate 1] cx)
                   (assoc-in  [:rotate 2] cy))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props]))

(defmethod rotate :text
  [[k props text] deg]
  (rotate-element-by-transform [k props text] deg))

(defmethod rotate :path
  [elem deg]
  (path/rotate elem deg))
  
#+END_SRC

*** rotate-group
If I let the rotate 'pass through' a group, it rotates every child element locally. This has the effect of ignoring grouped elements that you do want to rotate about the group's center.

Each child of a group must be rotated around the group's midpoint.
So,
- find group midpoint
- apply rotation to children about group midpoint
  - rotate child by deg
  - translate child to new center (rotate its orig midpoint about group midpoint to find new position)

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmethod rotate :g
  [[k props & content :as elem] deg]
  (let [[gcx gcy] (utils/centroid-of-pts (bounds elem))
        xfcontent (for [child content]
                    (let [ch (translate child [(- gcx) (- gcy)])
                          ctr (if (= :g (first ch))
                                (utils/centroid-of-pts (bounds ch))
                                (centroid ch))
                          xfm (-> ctr
                                  (utils/rotate-pt deg)
                                  (utils/v+ [gcx gcy]))]
                      (-> ch
                          (translate (utils/v* [-1 -1] ctr))
                          (rotate deg)
                          (translate xfm))))]
    (into [k props] (filter (complement nil?) xfcontent))))

#+END_SRC

** scale
Scale implementation doesn't seem to work correctly in all cases. For example, scaling something down and translating a group containing it will shift it, which is undesired behaviour.

Scale should be 'baked into' all dimensions just like other transforms, where possible.

*** scale-elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defn scale-by-transform
  [[k props & content] [sx sy]]
  (let [xf (utils/str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    [k new-props] content))

(defmulti scale
  (fn [element _]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod scale :list
  [elems [sx sy]]
  (map #(scale [sx sy] %) elems))

;; transforms are applied directly to the properties of shapes.
;; I have scale working the same way. One issue is that scaling a circle
;; turns it into an ellipse. This impl WILL change the shape to ellipse if non-uniform scaling is applied.

(defmethod scale :circle
  [[_ props] [sx sy]]
  (let [[sx sy] (map #(Math/abs %) [sx sy])
        circle? (= sx sy)
        r (:r props)
        new-props (if circle?
                    (assoc props :r (* r sx))
                    (-> props
                        (dissoc :r)
                        (assoc :rx (* sx r))
                        (assoc :ry (* sy r))))
        k (if circle? :circle :ellipse)]
    [k new-props]))

(defmethod scale :ellipse
  [[k props] [sx sy]]
  (let [[sx sy] (map #(Math/abs %) [sx sy])
        new-props (-> props
                      (update :rx #(* sx %))
                      (update :ry #(* sy %)))]
    [k new-props]))

;; find bounding box center
;; translate bb-center to 0 0
;; scale all x y values by * [sx sy]
;; translate back to original bb-center

(defmethod scale :line
  [[k props :as elem] [sx sy]]
  (let [[cx cy] (centroid elem)
        new-props (-> props
                      (update :x1 #(+ (* (- % cx) sx) cx))
                      (update :y1 #(+ (* (- % cy) sy) cy))
                      (update :x2 #(+ (* (- % cx) sx) cx))
                      (update :y2 #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale :polygon
  [[k props :as elem] [sx sy]]
  (let [pts (map vec (partition 2 (utils/s->v (:points props))))
        ctr (centroid elem)
        xpts (->> pts
                  (map #(utils/scale-pt-from-center % [sx sy] ctr))
                  (map utils/v->s))]
    [k (assoc props :points (str/join " " xpts))]))

(defmethod scale :polyline
  [[k props :as elem] [sx sy]]
  (let [pts (map vec (partition 2 (utils/s->v (:points props))))
        ctr (centroid elem)
        xpts (->> pts
                  (map #(utils/scale-pt-from-center % [sx sy] ctr))
                  (map utils/v->s))]
    [k (assoc props :points (str/join " " xpts))]))

(defmethod scale :rect
  [[k props] [sx sy]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale :image
  [[k props] [sx sy]]
  (let [cx (+ (:x props) (/ (:width props) 2.0))
        cy (+ (:y props) (/ (:height props) 2.0))
        w (* sx (:width props))
        h (* sy (:height props))
        new-props (-> props
                      (assoc :width w)
                      (assoc :height h)
                      (update :x #(+ (* (- % cx) sx) cx))
                      (update :y #(+ (* (- % cy) sy) cy)))]
    [k new-props]))

(defmethod scale :text
  [[k props text] [sx sy]]
  (let [xf (get-props props)
        cx (get-in xf [:rotate 1])
        cy (get-in xf [:rotate 2])
        x (+ (* (- (:x props) cx) sx) cx)
        y (+ (* (- (:y props) cy) sy) cy)
        new-xf (-> xf
                   (assoc-in [:rotate 1] (- x))
                   (assoc-in [:rotate 2] (- y)))
        new-props (-> props
                      (assoc :transform (utils/xf-map->str new-xf))
                      (assoc :x x)
                      (assoc :y y)
                      (update-in [:style :font-size] #(* % sx)))]
    [k new-props text]))

(defmethod scale :path
  [elem [sx sy]]
  (path/scale elem [sx sy]))

#+END_SRC

*** scale-group
For a group scale to work as expected, two things must happen:

 - scale each element of the group around its own centroid
 - translate each element of the group by (utils/v* sc velem)
   - velem is (utils/v- elem-ctr group-ctr)

#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
#_(defmethod scale :g
  [[k props & content] [sx sy]]
  (let [xf (utils/str->xf-map (:transform props))
        new-xf (-> xf
                   (update :scale (fnil #(map * [sx sy] %) [1 1])))
        new-props (assoc props :transform (utils/xf-map->str new-xf))]
    (into [k new-props] content)))

(defmethod scale :g
  [[k props & content :as elem] [sx sy]]
  (let [g-ctr (utils/centroid-of-pts (bounds elem))
        xfcontent (for [child content]
                    (let [elem-ctr (if (= :g (first child))
                                     (utils/centroid-of-pts (bounds child))
                                     (centroid child))
                          ch (-> child
                                 (translate (utils/v* [-1 -1] elem-ctr))
                                 (scale [sx sy]))
                          elem-v (utils/v- elem-ctr g-ctr)]
                      (-> ch (translate (utils/v+ (utils/v* [sx sy] elem-v) g-ctr)))))]
    (into [k props] (filter (complement nil?) xfcontent))))

#+END_SRC

** offset
*** offset-elements
#+BEGIN_SRC clojure :tangle ./src/svg_clj/transforms.cljc
(defmulti offset
  (fn [element _]
    (if (keyword? (first element))
      (first element)
      :list)))

(defmethod offset :default
  [[k _ :as elem]]
  (println (str "Offset not implemented for " k "."))
  elem)

(defmethod offset :list
  [elems d]
  (map #(offset % d) elems))

(defmethod offset :circle
  [[k props] d]
  (let [new-props (update props :r + d)]
    [k new-props]))

(defmethod offset :ellipse
  [[k props] d]
  (let [new-props (-> props
                      (update :rx + d)
                      (update :ry + d))]
    [k new-props]))

(defmethod offset :rect
  [[k props] d]
  (let [new-props (-> props
                      (update :x - d)
                      (update :y - d)
                      (update :width + (* d 2))
                      (update :height + (* d 2)))]
    [k new-props]))

(defmethod offset :line
  [[k {:keys [x1 y1 x2 y2] :as props}] d]
  (let [[[nx1 ny1] [nx2 ny2]] (utils/offset-edge [[x1 y1] [x2 y2]] d)
        new-props (-> props
                      (assoc :x1 nx1)
                      (assoc :y1 ny1)
                      (assoc :x2 nx2)
                      (assoc :y2 ny2))]
    [k new-props]))

(defmethod offset :polygon
  [[k {:keys [points] :as props}] d]
  (let [pts (map vec (partition 2 (utils/s->v points)))
        opts (utils/offset-pts pts d)
        npoints (str/join " " (map utils/v->s opts))
        new-props (assoc props :points npoints)]
    [k new-props]))

(defmethod offset :polyline
  [[k {:keys [points] :as props}] d]
  (let [pts (map vec (partition 2 (utils/s->v points)))
        opts (utils/offset-pts pts d)
        npoints (str/join " " (map utils/v->s opts))
        new-props (assoc props :points npoints)]
    [k new-props]))

#+END_SRC

*** offset-path
Offsetting paths is trickier.

First, I have to make it possible to split cmd sequences into their sub parts (polyline/polygon are MLLL...Z commands only)

Bezier curve offsets cannot technically be represented with another bezier curve. What has to happen is a 'good enough' approximation. This is done by splitting the source curve into 'safe' segments, and for each segment doing a simpler point offset for the start/end of each curve.

See [[https://pomax.github.io/bezierinfo/#offsetting]]

For details.

First, I have to split up the bezier. To split a bezier curve, you have to create 'de Casteljau's Skeleton' which is all of the straight line segments that 'build up' to create the Bezier Curve.

#+BEGIN_SRC clojure
(defmulti offset-path-command
  (fn [cmd _]
    (:command cmd)))

(defmethod offset-path-command "M"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

(defmethod offset-path-command "L"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

(defmethod offset-path-command "H"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x] input)))

(defmethod offset-path-command "V"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [y] input)))

;; x y x y x y because input will ahve the form:
;; [x1 y1 x2 y2 x y] (first two pairs are control points)
(defmethod offset-path-command "C"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y x y] input)))

;; similar approach to above, but one control point is implicit
(defmethod offset-path-command "S"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y] input)))

(defmethod offset-path-command "Q"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y x y] input)))

(defmethod offset-path-command "T"
  [{:keys [:input] :as m} [x y]]
  (assoc m :input (utils/v+ [x y] input)))

;; [rx ry xrot laf swf x y]
;; rx, ry do not change
;; xrot also no change
;; large arc flag and swf again no change
(defmethod offset-path-command "A"
  [{:keys [:input] :as m} [x y]]
  (let [[rx ry xrot laf swf ox oy] input]
    (assoc m :input [rx ry xrot laf swf (+ x ox) (+ y oy)])))

(defmethod offset-path-command "Z"
  [cmd _]
  cmd)

(defmethod offset-path-command :default
  [cmd a]
  [cmd a])

#_(defmethod offset :path
  [[k props] d]
  [k props])
  #_(let [cmds (path/path-str->cmds (:d props))
        xcmds (map #(offset-path-command % d) cmds)]
    [k (assoc props :d (path/cmds->path-string xcmds))]))

#+END_SRC

* composites
Composites are drawing elements that are not represented in the base SVG elements. For example, arrows are combinations of a polygon and line shape. These kinds of composite shapes should work as if they were base elements. This means that all transform functions must work normally on them. This shouldn't be too difficult, as composites are mostly going to be grouped up elements anyway.
** ns
#+BEGIN_SRC clojure :tangle ./src/svg_clj/composites.cljc
(ns svg-clj.composites
  "Provides functions that combine transforms and primitive elements to make more complicated shapes.

  Additionally, the SVG container function is provided here as it relies on [[svg-clj.transforms]] to allow automatic veiwBox setup."
  (:require [clojure.string :as str]
            [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.transforms :as tf]))

#+END_SRC

** svg
#+begin_src clojure :tangle ./src/svg_clj/composites.cljc
(defn svg
   "Wraps `content` in an SVG container element whose width, height, and viewBox properties are automatically calculated when `w`, `h`, and `sc` are omitted.
   The SVG container is optionally parameterized by width `w`, height `h`, and scale `sc`."
  ([content]
   (let [[w h] (tf/bb-dims content)
         [[x y] _ _ _] (tf/bounds content)]
     [:svg {:width  w
            :height h
            :viewBox (str/join " " [x y w h])
            :xmlns "http://www.w3.org/2000/svg"}
      content]))

  ([content w h]
   [:svg {:width  w
          :height h
          :viewBox (str "0 0 " w " " h)
          :xmlns "http://www.w3.org/2000/svg"}
    content])

  ([content w h sc]
   (svg [:g {:transform (str "scale(" sc ")")} content] w h)))

#+end_src

** arrow
To be added later:

A 'arrow builder' function that lets you give a curve, a start-shape, and end-shape and it builds the appropriate group. This could be a basis for a bunch of utility arrows. Curves could be line, polyline, beziers, and arcs. 

#+begin_src clojure :tangle ./src/svg_clj/composites.cljc
(defn arrow
  ([a b]
   (let [tip-pts [ [0 0] [5 0] [5 5] ]
         tip-shape (el/polygon tip-pts)]
     (arrow a b tip-shape)))

  ([a b tip-shape]
   (let [[mx my] (tf/centroid tip-shape)
         r (utils/to-deg (apply #(Math/atan2 %1 %2) (utils/v- b a)))]
     (->
      (el/g
       (el/line a b)
       (-> tip-shape
           (tf/translate [(- mx) (- my)])
           (tf/rotate (- 315 r))
           (tf/translate a)
           (tf/style {})
           (tf/style {:fill "none"
                      :stroke "none"}))
       (-> tip-shape
           (tf/translate [(- mx) (- my)])
           (tf/rotate (- 135 r))
           (tf/translate b)))))))
#+end_src

** label
This is a helpful default for text elements. It expects a font size arg. This could be reworked in the future.

#+begin_src clojure :tangle ./src/svg_clj/composites.cljc
(defn label
  [font-size text]
  [:text 
   {:x 0 :y 0 
    :style {:font-family "Verdana"
            :text-anchor "middle"
            :dominant-baseline "middle"
            :font-size font-size}} text])
#+end_src
* algorithms
Various useful algorithms, usually working on points.

** ns
#+begin_src clojure :tangle ./src/svg_clj/algorithms.cljc
(ns svg-clj.algorithms
  (:require [svg-clj.utils :as utils]
            [clojure.set :as set]))

#+end_src

** delaunay
#+begin_src clojure :tangle ./src/svg_clj/algorithms.cljc
(def abs #?(:clj #(Math/abs %) :cljs js/Math.abs))
(def pow #?(:clj #(Math/pow %1 %2) :cljs js/Math.pow))

;; https://gist.github.com/mutoo/5617691
(defn circumscribe-tri
  [[[ax ay] [bx by] [cx cy]]]
  (let [A (- bx ax)
        B (- by ay)
        C (- cx ax)
        D (- cy ay)
        E (+ (* A (+ ax bx)) (* B (+ ay by)))
        F (+ (* C (+ ax cx)) (* D (+ ay cy)))
        G (* 2 (- (* A (- cy by)) (* B (- cx bx))))]
    (when (> (abs G) 0.000001)
      (let [cx (/ (- (* D E) (* B F)) G)
            cy (/ (- (* A F) (* C E)) G)
            dx (- cx ax)
            dy (- cy ay)
            r  (+ (pow dx 2) (pow dy 2))]
        {:x cx :y cy :radius-squared r}))))

(defn edges
  [pts]
  (partition 2 1 (conj (vec pts) (first pts))))

(defn contains-pt?
  [{:keys [x y radius-squared]} [px py]]
  (let [distance-squared (+ (pow (- x px) 2) (pow (- y py) 2))]
    (< distance-squared radius-squared)))

(defn outer-edges
  [tris]
  (let [all-edges (mapcat edges tris)
        matches (fn [edge] (filter #{edge (reverse edge)} all-edges))
        appears-once (fn [edge] (= (count (matches edge)) 1))]
    (filter appears-once all-edges)))

(defn make-new-tris
  [containers pt]
  (->> containers
       outer-edges
       (map (fn [[p1 p2]] [p1 p2 pt]))
       set))

(defn add-pt-to-tris
  [tris pt]
  (let [containers (filter #(contains-pt? (circumscribe-tri %) pt) tris)
        new-tris (make-new-tris containers pt)]
    (set/union (set/difference tris containers) new-tris)))

;; http://paulbourke.net/papers/triangulate/
(defn delaunay
  [pts]
  (let [pts (map (fn [[x y]] [(float x) (float y)]) pts)
        pt-indices (zipmap pts (range 0 (count pts)))
        [bl br tr tl] (map #(utils/v* % [2 2]) (utils/bounds-of-pts pts))
        initial #{[tl tr bl] [bl tr br]}
        with-bounds (reduce add-pt-to-tris initial pts)
        tris (remove #(some #{tl tr bl br} %) with-bounds)
        tri-indices (fn [tri] (mapv #(get pt-indices %) tri))]
    {:pts pts
     :tris tris
     :tri-indices (map tri-indices tris)
     :edges (distinct (mapcat edges tris))}))

#+end_src

** clip-ears
#+begin_src clojure :tangle ./src/svg_clj/algorithms.cljc
(defn remove-colinears
  [pts]
  (let [indices (zipmap pts (range (count pts)))
        tris (partition 3 1 (concat pts (take 2 pts)))
        clpts (set (map second (filter #(apply utils/colinear? %) tris)))
        xindices (vals (apply dissoc indices clpts))]
    (map #(get pts %) xindices)))

(defn- clip-one-ear
  [pts]
  (let [pts (vec pts)
        indices (zipmap pts (range (count pts)))
        corners (->> pts
                     (#(concat % (take 2 %)))
                     (partition 3 1)
                     (filter #(#{:convex} (apply utils/corner-condition %))))
        clear? (fn [corner]
                 (not (seq (filter #(utils/pt-inside? corner %) pts))))
        tri (first (filter clear? corners))]
    {:pts pts
     :npts (mapv #(get pts %) (sort (vals (dissoc indices (second tri)))))
     :tri tri}))

(defn clip-ears
  ([pts] (clip-ears {:indices (zipmap pts (range (count pts)))} pts [] []))
  ([data pts tris indices]
   (if (< (count pts) 3)
     (merge data {:tris tris :tri-indices indices})
     (let [{:keys [npts tri]} (clip-one-ear pts)
           local-indices (mapv #(get (:indices data) %) tri)]
       (recur data npts (conj tris tri) (conj indices local-indices))))))

#+end_src

** hull
#+begin_src clojure :tangle ./src/svg_clj/algorithms.cljc
(defn hull
  ([pts] (hull [{:pt (first (sort-by first pts))}] pts))
  ([acc pts]
   (if (or
        ;; stop the process if acc grows larger than the pts count
        (> (count acc) (count pts))
        ;; *should* always end where the last added point closes the poly
        (and (< 1 (count acc))
             (= (:pt (first acc)) (:pt (last acc)))))
     (map :pt (drop-last acc))
     (let [prev (:pt (last acc))
           dir (if (= 1 (count acc))
                 (utils/v+ [0 1] prev)
                 (:pt (last (drop-last acc))))
           f (fn [pt]
               (let [a (when (= 3 (count (into #{} [dir prev pt])))
                         (utils/angle-from-pts dir prev pt))]
                 {:pt pt :angle a}))
           sorted (->> (map f pts)
                       (remove #(nil? (:angle %)))
                       (sort-by #(utils/abs (- (:angle %) 180))))]
       (recur (conj acc (first sorted)) pts)))))

(defn nested-hull
  ([pts] (nested-hull [] pts))
  ([acc pts]
   (if (> 3 (count pts))
     acc
     (let [hull (hull pts)
           npts (remove (set hull) pts)]
       (recur (conj acc hull) npts)))))

#+end_src

* parametric
The parametric ns has functions that generate useful geometric elements. Primarily, they fall into one of two categories:
 - pt list generators (eg. regular-polygon-pts)
 - higher-order parametric functions, taking in args and returning (fn [t] ...), (fn [u v] ...)

The pt lists are not technically parametric, though they are quite useful in conjunction with the parametric functions, especially considering the polygon and polyline parametric functions which take in lists of points.

** parametric-fn-design
The parametric functions return a function expecting a parameter, denoted as t by convention.

Given a parametric function, you can pass in a parameter t with a value anywhere between 0 and 1. The function is then expected to return a position. It can be an n-dimensional position, but in SVG-CLJ, it is almost always 2D point [x y].

In my library, I am using a 0-arity call to any parametric function to return a map of details about that curve. This means that every function that 'constructs' one of these parametric functions must properly generate this map.

The required keys for the curve map are:

#+begin_src clojure
{:fn `fn-symbol
 :input [arg1 arg2 ...]
 :origin [0 0]
 :length "length of curve, exact if possible, estimated otherwise"
 :vertex-params "t values where the curve equals the input vertices."}
#+end_src

Additionally, it is required that any parametric function that modifies a function (transforms) also matches this 0-arity scheme. This is because certain algorithms will be built requiring data from these keys, in particular, :length is valuable to have basically pre-calculated when the curve is first created.

Finally, it must be true that (f 0) and (f 1) are valid points, not nil.

** ns
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(ns svg-clj.parametric
  "Provides functions that generate lists of points or return parametric curve functions."
  (:require [svg-clj.utils :as utils]
            [svg-clj.algorithms :as alg]))
#+end_src

** parametric-validator
A utility for checking validity of a parametric function based on the design requirements, in particular of the zero-arity function.

There are also some checks for validity at (f 0) and (f 1) since the end conditions can sometimes get confusing and break down.

One assumption made is that (f 0.5) will be valid in terms of the dimensionality of the curve. For now, this is perhaps a sufficient assumption for checks.

This check does not determine yet if the implied function from :fn :input will be equivalent. This may be a feature to build into a full-check-parametric or something later on. For now, I'm not worrying about that.

#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn check-parametric
  [f]
  (let [fdata (try (f) (catch #?(:cljs :default :clj Exception) e))
        [f0 f05 f1] (map f [0 0.5 1])
        t0 (if (seqable? f0) f0 [f0])
        t05 (if (seqable? f05) f05 [f05])
        t1 (if (seqable? f1) f1 [f1])
        dim (count t05)
        required [:fn :input :vertex-params :length :origin]
        keys-pred (every? #(contains? fdata %) required)
        t0-pred (and t0 (= (count t0) dim) (every? number? t0))
        t1-pred (and t1 (= (count t1) dim) (every? number? t1))
        missing (when-not keys-pred (remove (set (keys fdata)) (set required)))
        result {:dimension dim
                :data fdata
                :valid-data keys-pred
                :valid-t0 t0-pred
                :valid-t1 t1-pred}]
    (cond-> result
      missing       (assoc-in [:error :missing] missing)
      (not fdata)   (assoc-in [:error :invalid-0-arity] fdata)
      (not t0-pred) (assoc-in [:error :invalid-t0] t0)
      (not t1-pred) (assoc-in [:error :invalid-t1] t1))))

(defn valid-parametric?
  [f]
  (nil? (:error (check-parametric f))))

#+end_src

** remap
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn- remap-within
  [f [start end] x]
  (when (and (>= x start) (< x end))
    (let [step (- end start)
          t (/ (- x start) step)]
      (f t))))

#+end_src

** arc-length
Arc-length is slow at the moment. I have to figure out how to optimize it, and in a way that is portable to CLJS.

#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn arc-length
  ([curve] (arc-length curve 0 1))
  ([curve t] (arc-length curve 0 t))
  ([curve ta tb]
   (let [seg 13500
         start (/ (* ta seg) seg)
         end   (/ (inc (* tb seg)) seg)]
     (->> (range start end (/ 1 seg))
          (map curve)
          (partition 2 1)
          (map #(apply utils/distance %))
          (reduce +)
          (#(utils/round % 5))))))

#+end_src

** regular-polygons
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn regular-polygon-pts
  [r n]
  (let [angle (* 2 Math/PI (/ 1 n))]
    (map #(vector (utils/round (* r (Math/cos (* % angle))) 5)
                  (utils/round (* r (Math/sin (* % angle))) 5))
         (range n))))

#+end_src

** rectilinear-grid
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn rect-grid
  [nx ny w h]
  (for [a (range nx)
        b (range ny)]
    [(* w a) (* h b)]))

#+end_src

** hex-grid
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn hex-grid
  [nx ny w]
  (let [a-offset (/ w 2)
        h (/ w 0.8660254)]
    (concat
     (for [x (range 0 nx)
           y (range 0 (Math/floor (/ ny 2)))]
       [(+ a-offset (* w x)) (* 2 h y)])
     (for [x (range 0 nx)
           y (range 1 (Math/ceil (/ ny 2)))]
       [(* w x) (+ h (* 2 h y))]))))
  
#+end_src

** line
Line is a very simple parametric curve, but is used a lot in other contexts, especially because it can build some very useful interpolations for you.

To make certain circumstances faster, when the line's length is irrelevant, a user or other fn with lines internally (eg. bezier), fastline can be used to avoid calculating length at all. This speeds things up because a line's length uses Math/sqrt, which is fast enough but slows down when doing lots of calculations.

This was observed to have noticable improvement on estimating arc-length of a bezier curve, since lines are created for any t. Avoiding length calculations is critical as the lines generated depend on how many t values are used (lots for arc length estimation) and on the order of the bezier curve (more recursion for higher order bezier curvs).

#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn line
  [a b]
  (fn
    ([] {:fn `line
         :input [a b]
         :origin (utils/centroid-of-pts [a b])
         :vertex-params [0 1]
         :length (utils/distance a b)})
    ([t]
     (cond
       (= (float t) 0.0) a
       (= (float t) 1.0) b
       :else
       (utils/v+ a (utils/v* (utils/v- b a) (repeat t)))))))

(defn fastline
  [[ax ay :as a] [bx by :as b]]
  (let [[vx vy] (utils/v- b a)]
    (fn [t]
      [(+ ax (* vx t))
       (+ ay (* vy t))])))

#+end_src

** polyline
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn polyline
  [pts]
  (let [step (/ 1.0 (dec (count pts)))
        lines (map (partial apply line) (partition 2 1 pts))
        length (reduce + (map #(:length (%)) lines))
        intervals (->> lines
                       (map #(:length (%)))
                       (reductions +)
                       (concat [0])
                       (map #(/ % length))
                       (partition 2 1))]
    (fn
      ([] {:fn `polyline
           :input [pts]
           :origin (utils/centroid-of-pts pts)
           :vertex-params (concat [0] (mapv second intervals))
           :length length})
      ([t]
       (cond
         (= (float t) 0.0) (first pts)
         (= (float t) 1.0) (last pts)
         :else
         (first
          (filter some?
                  (map #(remap-within %1 %2 t) lines intervals))))))))

#+end_src

** polygon
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn polygon
  [pts]
  (let [pts (concat (vec pts) [(first pts)])
        step (/ 1.0 (dec (count pts)))
        lines (map (partial apply line) (partition 2 1 pts))
        length (reduce + (map #(:length (%)) lines))
        intervals (->> lines
                       (map #(:length (%)))
                       (reductions +)
                       (concat [0])
                       (map #(/ % length))
                       (partition 2 1))]
    (fn
      ([] {:fn `polygon
           :input [pts]
           :origin (utils/centroid-of-pts pts)
           :vertex-params (concat [0] (mapv second intervals))
           :length (reduce + (map #(:length (%)) lines))})
      ([t]
       (cond
         (= (float t) 0.0) (first pts)
         (= (float t) 1.0) (last pts)
         :else
         (first
          (filter some?
                  (map #(remap-within %1 %2 t) lines intervals))))))))

#+end_src

** circle
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn- radius-from-pts
  "compute the radius of an arc defined by 3 points"
  [p1 p2 p3]
  (let [a (utils/distance p3 p2)
        b (utils/distance p3 p1)
        c (utils/distance p2 p1)
        s (/ (+ a b c) 2)
        sa ( - s a)
        sb ( - s b)
        sc ( - s c)
        rt (Math/sqrt ^double (* s sa sb sc))
        radius (/ (/ (* a b c) 4) rt)]
    radius))

(defn- center-from-pts
  "compute the center point of an arc through 3 points"
  [p1 p2 p3]
  (let [u1 (utils/v- p2 p1)
        u2 (utils/v- p3 p1)
        w1 (utils/cross* (utils/v- p3 p1) u1)
        u (utils/normalize u1)
        w (utils/normalize w1)
        v (utils/cross* w u)
        [bx _] [(utils/dot* u1 u) 0]
        [cx cy] [(utils/dot* u2 u) (utils/dot* u2 v)]
        h (/ (+ (Math/pow (- cx (/ bx 2)) 2) 
                (Math/pow cy 2)
                (- (Math/pow (/ bx 2) 2))) 
             (* 2 cy))]
    (utils/v+ p1
              (utils/v* (repeat (/ bx 2)) u) 
              (utils/v* (repeat h) v))))

(defn circle
  ([r]
   (fn
     ([] {:fn `circle
          :input [r]
          :origin [0 0]
          :vertex-params [0]
          :length (* Math/PI 2 r)})
     ([t]
      (let [t (* 2 Math/PI t)
            x (* r (Math/cos t))
            y (* r (Math/sin t))]
        [x y]))))

  ([a b c]
   (let [[a b c] (map #(conj % 0) [a b c])
         n (utils/normalize (utils/normal a b c))
         r (radius-from-pts a b c)
         cp (center-from-pts a b c)
         u (utils/normalize (utils/v- a cp))
         v (utils/cross* n u)]
     (fn
       ([] {:fn `circle
            :input [a b c]
            :origin cp
            :vertex-params [0]
            :length (* Math/PI 2 r)
            :radius r})
       ([t]
       (cond
         (or (< t 0.0) (> t 1.0)) nil
         (= (float t) 0.0) (vec (drop-last a))
         (= (float t) 1.0) (vec (drop-last a))
         :else
         (let [t (* 2 Math/PI t)]
           (mapv 
            #(utils/round % 5)
            (drop-last 
             (utils/v+ cp
                       (utils/v* (repeat (* r (Math/cos t))) u)
                       (utils/v* (repeat (* r (Math/sin t))) v)))))))))))

#+end_src

** arc
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn arc
  [a b c]
  (let [[a b c] (map #(conj % 0) [a b c])
        f (circle a b c)
        cp (center-from-pts a b c)
        angle (utils/angle-from-pts a cp c)
        r (radius-from-pts a b c)]
    (fn
      ([] {:fn `arc
           :input [a b c]
           :origin cp
           :vertex-params [0 1]
           :length (* Math/PI 2 r (/ angle 360))
           :radius r
           :center cp})
      ([t]
       (let [t (* t (/ angle 360.0))]
         (f t))))))

#+end_src

** ellipse
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
;; https://www.mathsisfun.com/geometry/ellipse-perimeter.html
;; uses 'Infinite Series 2' exact calc. using 4 terms.
(defn- ellipse-perimeter
  [rx ry]
  (let [h (/ (Math/pow (- rx ry) 2)
             (Math/pow (+ rx ry) 2))]
    (* Math/PI (+ rx ry)
       (+ 1
          (* h (/ 1 4))
          (* h h (/ 1 64))
          (* h h h (/ 1 256))))))

(defn ellipse
  [rx ry]
  (fn 
    ([] {:fn `ellipse
         :input [rx ry]
         :origin [0 0]
         :vertex-params [0]
         :length (ellipse-perimeter rx ry)})
    ([t]
     (let [t (* 2 Math/PI t)
           x (* rx (Math/cos t))
           y (* ry (Math/sin t))]
       [x y]))))

#+end_src

** bezier
Implement bezier parametric curves so that I can use them for layouts and other advanced drawing functions.

[[https://pomax.github.io/bezierinfo/#splitting]]

Splitting is needed as part of approximating bezier curve offsets with 'chains' of other bezier curves.

#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn- quadratic-bezier
  [a b c]
  (fn [t]
    (let [l1 (fastline a b)
          l2 (fastline b c)
          l3 (fastline (l1 t) (l2 t))]
      (l3 t))))

(defn- bezier*
  [pts]
  (if (= 3 (count pts))
    (apply quadratic-bezier pts)
    (let [lines (map #(apply fastline %) (partition 2 1 pts))] 
      (fn
        [t]
        (let [npts (map #(% t) lines)]
          ((bezier* npts) t))))))

(defn bezier
  [pts]
  (let [curve (bezier* pts)
        length (arc-length curve)]
    (fn
      ([] {:fn `bezier
           :input [pts]
           :origin (utils/centroid-of-pts pts)
           :vertex-params [0 1]
           :length length})
      ([t] (curve t)))))

#+end_src

** rational-bezier
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn- next-pascal
  [row]
  (vec (concat [(first row)]
          (mapv #(apply + %) (partition 2 1 row))
          [(last row)])))

(defn- binomial
  [n i]
  (let [pascal-tri-row (last (take (inc n) (iterate next-pascal [1])))]
  (get pascal-tri-row i)))

(defn- polynomial
  [n i t]
  (* (Math/pow (- 1 t) (- n i)) (Math/pow t i)))

(defn- half-bezier
  [ws t]
  (let [n (dec (count ws))
        poly (partial polynomial n)
        bi (partial binomial n)]
    (reduce + (map-indexed 
               (fn [i w]
                 (* (bi i) (poly i t) w))
               ws))))

(defn rational-bezier*
  [pts wts]
  (let [xs (map #(* (first %1) %2) pts wts)
        ys (map #(* (second %1) %2) pts wts)
        dn (partial half-bezier wts)]
    (fn [t]
      [(/ (half-bezier xs t) (dn t)) 
       (/ (half-bezier ys t) (dn t))])))

(defn rational-bezier
  [pts wts]
  (let [curve (rational-bezier* pts wts)
        length (arc-length curve)]
    (fn
      ([] {:fn `rational-bezier
           :input [pts wts]
           :origin (utils/centroid-of-pts pts)
           :vertex-params [0 1]
           :length length})
      ([t] (curve t)))))

#+end_src

*** piecewise-curve
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn piecewise-curve
  [curves]
  (let [step (/ 1.0 (count curves))
        intervals (partition 2 1 (range 0 (+ 1 step) step))
        remapf (fn [curve [start end]]
                 (let [vertex-params (:vertex-params (curve))
                       sc (- end start)]
                   (map #(+ start (* sc %)) vertex-params)))
        vertex-params (vec (distinct (mapcat remapf curves intervals)))
        origin (utils/centroid-of-pts (map #(:origin (%)) curves))
        length (reduce + (map #(:length (%)) curves))
        sample-curve (first curves)]
    (fn
      ([] {:fn `piecewise-curve
           :input [curves]
           :origin origin
           :dimension (count (sample-curve 0.5))
           :vertex-params vertex-params
           :length length})
      ([t]
       (cond
         (= (float t) 0.0) ((first curves) 0)
         (= (float t) 1.0) ((last curves) 1)
         :else
         (first
          (filter some?
                  (map #(remap-within %1 %2 t) curves intervals))))))))

#+end_src

** WIP splitting-beziers
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn split-bezier
  "Returns the Control Point 'de Casteljau Skeleton', used to derive split Bezier Curve Control Points."
  ([curve t]
   (let [pts (-> (curve) :input first)]
     (split-bezier {:a [(first pts)]
                    :b [(last pts)]} pts t)))
 
  ([{:keys [a b]} pts t]
   (let [cs (map #(apply line  %) (partition 2 1 pts))
         npts (map #(% t) cs)]
     (if (= 1 (count npts))
       {:a (conj a (first npts))
        :b (-> b
               reverse
               (conj (first npts))
               vec)}
       (recur {:a (conj a (first npts))
               :b (conj b (last npts))} npts t)))))

(defn- get-t
  "Estimate curve parameter `t` that corresponds to length-percentage `target-lp`."
  [curve target-lp]
  (let [eps 0.00001
        length (:length (curve))
        target-l (* length target-lp)]
    (loop [t target-lp
           n 0]
        (let [next-t (+ t (/ (- target-l (arc-length curve t)) target-l))]
          (if (or
               (= (utils/round t 4) (utils/round next-t 4))
               (< (utils/abs (- target-l (arc-length curve t))) eps)
               (< 300 n))
            next-t
            (recur next-t (inc n)))))))

(defn- get-t-at-distance
  [curve d]
  (let [target-lp (/ d (:length (curve)))]
    (get-t curve target-lp)))

(defn split-bezier-between
  [curve ta tb]
  (let [da (arc-length curve ta)
        split1 (split-bezier curve tb)
        curve1 (bezier (:a split1))
        partial-result {:c (:b split1)}
        ta1 (get-t-at-distance curve1 da)]
    (merge (split-bezier curve1 ta1) partial-result)))

(defn multi-split-bezier
  ([curve ts]
   (let [ds (map #(arc-length curve %) (sort ts))]
     (multi-split-bezier [] curve (reverse ds))))
  ([acc curve ds]
   (if (< 1 (count ds))
     (let [remapped-t (get-t-at-distance curve (first ds)) 
           {:keys [a b]} (split-bezier curve remapped-t)]
       (recur (conj acc b) (bezier a) (rest ds)))
     (let [remapped-t (get-t-at-distance curve (first ds)) 
           {:keys [a b]} (split-bezier curve remapped-t)]
       (-> acc
           (conj b)
           (conj a)
           reverse)))))

(defn uniform-split-bezier
  [curve n-segments]
  (let [l (arc-length curve)
        step (/ l n-segments)
        ds (range step l step)]
    (if (= 2 n-segments)
      (split-bezier curve 0.5)
      (multi-split-bezier [] curve (reverse (sort ds))))))

#+end_src

** WIP b-spline
#+begin_src clojure tangle ./src/svg_clj/parametric.cljc
(defn- domain
  [degree knots]
  (let [knots (vec knots)]
    [(get knots degree)
     (get knots (- (count knots) 1 degree))]))

(defn- remap-t
  [degree knots t]
  (let [[ds de] (domain degree knots)
        sc (- de ds)]
    (+ ds (* sc t))))

(defn- section-index
  [degree knots t]
  (let [t (remap-t degree knots t)
        knots (vec knots)
        [ds de] (domain degree knots)]
    (->>
     (map (fn [[s0 s1]]
            (when (<= s0 t s1) s0))
                  (partition 2 1 (range ds (inc de))))
     (filter some?)
     first)))

;; degree example: quadratic b-spline = degree 2, cubic degree 3
;; order is (inc degree) and is the number of knots needed for any one section
;; order, k, is called 'knot interval'
;; n is number of control points. 
;; NOTE: for b-splines, the degree and n_cpts are NOT related.


;; current issue is index out of bounds. Seems like it's probably related to
;; incorrect s or i value, so (get knots i...) fails in some cases. 
(defn- b-spline-inner
  [[pts degree knots]
   [l v]
   t]
  (let [s (section-index degree knots t)
        order (inc degree)]
     (loop [v v
           i s]
      (if (> i (+ s l (- order)))
        (let [[x y :as vi] (get v i)
              numerator (- t (get knots i))
              denominator (- (get knots (+ i (- l) order))
                             (get knots i))
              alpha (/ numerator denominator)
              new-vi (utils/v+ (map #(* alpha %) vi)
                               (map #(* (- 1 alpha) %) (get v (dec i))))
              new-v (assoc v i new-vi)]
          (recur new-v (dec i)))
        v))))

(defn b-spline
  [pts degree knots]
  (let [k (count knots)
        d degree
        order (inc degree)
        n (count pts)]
    (when (= k (+ d n 1))
      (fn [t]
        (let [s (section-index degree knots t)]
          (loop [v-outer pts
                 l 1]
            (if (<= l order)
              (let [new-v (b-spline-inner
                           [pts degree knots]
                           [l v-outer]
                           t)]
                (recur new-v (inc l))
                #_(loop [v v-outer
                         i s]
                    (if (> i (+ s l (- order)))
                      (let [[x y :as vi] (get v i)
                            numerator (- t (get knots i))
                            denominator (- (get knots (+ i (- l) order))
                                           (get knots i))
                            alpha (/ numerator denominator)
                            new-vi (utils/v+ (map #(* alpha %) vi)
                                             (map #(* (- 1 alpha) %) (get v (dec i))))
                            new-v (assoc v i new-vi)]
                        (recur new-vi (dec i)))
                      v)))
              v-outer)))))))

#+end_src

#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
#_(def test-spline
  (let [degree 3
        pts [[0 0] [5 5] [10 -5] [15 25] [20 -5] [25 5] [30 0]]
        knots [1 2 3 4 5 6 7 8 9 10 11]]
    (partial b-spline-inner [pts degree knots] [1 pts])))

#+end_src

** blend
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn sinwave
  [amp freq]
  (fn [t]
    (* amp (Math/sin (* t freq Math/PI)))))

(defn blend
  ([fa fb alpha]
   (fn [t]
     (let [line (line (fa t) (fb t))]
       (line alpha))))
  ([fa fb easefn alpha]
   (fn [t]
     (let [line (line (fa t) (fb t))]
       (line (easefn alpha))))))

(defn eased-polyline
  [pts easefn]
  (let [step (/ 1.0 (dec (count pts)))
        lines (map (partial apply line) (partition 2 1 pts))
        length (reduce + (map #(:length (%)) lines))
        intervals (->> lines
                       (map #(:length (%)))
                       (reductions +)
                       (concat [0])
                       (map #(/ % length))
                       (partition 2 1))
        easedlines (map #(fn [t] (% (easefn t))) lines)]
    (fn
      ([] {:fn `polyline
           :input [pts]
           :length length})
      ([t]
       (cond
         (= (float t) 0.0) (first pts)
         (= (float t) 1.0) (last pts)
         :else
         (first
          (filter some?
                  (map #(remap-within %1 %2 t) easedlines intervals))))))))

(defn multiblend
  ([fs alpha]
   (fn [t]
     (let [line (polyline (map #(% t) fs))]
       (line alpha))))
  ([fs easefn alpha]
   (fn [t]
     (let [line (eased-polyline (map #(% t) fs) easefn)]
       (line alpha)))))

(defn fn-offset
  [curve f]
  (let [eps 0.000001]
    (fn [t]
      (let [t (cond (<= (- 1 eps) t) (- 1 eps)
                    (> eps t) eps
                    :else t)
            n (utils/normalize (utils/normal (curve (- t eps)) (curve (+ t eps))))
            tpt (curve t)
            l (line tpt (utils/v+ tpt n))]
        (l (f t))))))
#+end_src

** pts-utils
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn shift-pts
  "Shift a list of `pts` to begin at `start`, preserving order and cycling the list.
If no `start` is provided, pt with lowest x and y values is used."
  ([pts]
   (let [start (first (sort-by (juxt first second) pts))]
     (shift-pts pts start)))
  ([pts start]
   (let [[back front] (split-with (complement #{start}) pts)]
     (concat front back))))

(defn simplify
  "Simplifies the list of `pts` by evenly stepping `n` times along the parametric curve produced by the original list.
This does not guarantee that input pts are preserved in the output."
  [pts n]
  (let [c (polygon pts)]
    (mapv #(c (/ % (inc n))) (range n))))

;; not certain if this is a great design idea yet
(defn remove-colinears [pts] (alg/remove-colinears pts))
#+end_src

** stroke-pts
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn- pline
  [line]
  (let [[_ {:keys [x1 y1 x2 y2]}] line]
    (line [x1 y1] [x2 y2])))

(defn stroke-pts
  [curve width n-segments]
  (let [of (fn [_] (* 0.5 width))
        tcurve (fn-offset curve #(* 0.5 width))
        bcurve (fn-offset curve #(* -0.5 width))]
    (concat [(curve 0)]
            (map #(tcurve (/ % n-segments)) (range (inc n-segments)))
            [(curve 1)]
            (map #(bcurve (/ % n-segments)) (reverse (range (inc n-segments)))))))

#_(defn tapered-stroke-pts
  [curve width n-segments taper-t]
  (let [taper-n (int (* n-segments taper-t))
        taper (map #(ease-out-sin (/ % taper-n)) (range taper-n))
        dist (concat taper (repeat (- n-segments (* 2 (count taper))) 1) (reverse taper))
        tlns (->> (el/line [0 0] [0 (* 0.5 width)])
                  (repeat (inc n-segments))
                  (#(lo/distribute-on-curve % curve))
                  (map pline))
        blns (->> (el/line [0 0] [0 (* -0.5 width)])
                  (repeat n-segments)
                  (#(lo/distribute-on-curve % curve))
                  (map pline))]
    (concat [(curve 0)]
            (map #(%1 (* 1 (- 1 %2))) tlns dist)
            [(curve 1)]
            (reverse (map #(%1 (* 1 (- 1 %2))) blns dist)))))

#+end_src

** fillet-chamfer-pts
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn fillet-pts
  [pts r]
  (let [fillet (regular-polygon-pts r 50)
        ipts (utils/offset-pts pts (- r))
        f (fn [pt] (map #(utils/v+ pt %) fillet))
        npts (mapcat f ipts)]
    (alg/hull npts)))

(defn chamfer-pts
  [pts r]
  (let [fillet (regular-polygon-pts r 50)
        ipts (utils/offset-pts pts (- r))
        f (fn [pt] (map #(utils/v+ pt %) fillet))
        npts (mapcat f ipts)]
    (->> (alg/hull npts)
         (partition 2 1)
         (sort-by #(apply utils/distance %))
         reverse
         (take (count pts))
         (apply concat)
         alg/hull)))

#+end_src

** translate
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn translate
  [f [x y]]
  (let [data (f)]
    (fn
      ([] (merge data
                 {:fn `translate
                  :origin (utils/v+ (:origin data) [x y])
                  :input [f [x y]]}))
      ([t]
       (utils/v+ (f t) [x y])))))

#+end_src

** rotate
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn rotate
  [f deg]
  (let [data (f)
        ctr (:origin data)]
    (fn
      ([] {:fn `rotate
           :input [f deg]})
      ([t]
       (utils/rotate-pt-around-center (f t) deg ctr)))))

#+end_src

** scale
#+begin_src clojure :tangle ./src/svg_clj/parametric.cljc
(defn scale
  [f [sx sy]]
  (let [data (f)
        ctr (:origin data)]
    (fn
      ([] (merge data
                 {:fn `scale
                  :input [f [sx sy]]}))
      ([t]
       (utils/scale-pt-from-center (f t) [sx sy] ctr)))))

#+end_src

* layout
** ns
#+begin_src clojure :tangle ./src/svg_clj/layout.cljc
(ns svg-clj.layout
  "Provides functions for layout control of elements."
  (:require [svg-clj.elements :as el]
            [svg-clj.utils :as utils]
            [svg-clj.transforms :as tf]))

#+end_src

** distribute
Works like the distribute features in Inkscape.

My distribute functions will all be relative to the first item in the list. Typically, this will mean that the entire ditributed group will have an origin point at 0,0, but it can be arbitrary if the first item in the list has been translated somewhere else.

Distribute has a few options:
- left edges equidistant
- right edges equidistant
- centers equidistant
- gaps between equidistant

#+begin_src clojure :tangle ./src/svg_clj/layout.cljc
(defn distribute-linear
  [axis-key gap items]
  (let [dir (axis-key {:x first :y second})
        distances
        (reductions +
                    (map #(+ (/ (dir (tf/bb-dims %1)) 2)
                             (/ (dir (tf/bb-dims %2)) 2) gap)
                         items (rest items)))]
    (el/g
     (conj 
      (map
       #(tf/translate %1 (if (= axis-key :x) 
                           [%2 0]
                           [0 %2])) (rest items) distances)
      (first items)))))

(defn distribute-on-pts
  [items pts]
  (el/g (map #(-> %1 (tf/translate %2)) items pts)))

(defn distribute-on-curve
  [items curve]
  (let [eps 0.000001
        n (if (> (count items) 1) (dec (count items)) 1)
        xf (fn [item t]
             (let [t (cond (<= (- 1 eps) t) (- 1 eps)
                           (> eps t) eps
                           :else t)
                   n (utils/normal (curve (- t eps)) (curve (+ t eps)))
                   a (utils/angle-from-pts n [0 0] [0 1])
                   o (map #(utils/round % 4) (utils/rotate-pt (tf/centroid item) a))]
               (-> item
                   (tf/rotate a)
                   (tf/translate (utils/v- (curve t) o (tf/centroid item))))))]
    (map #(xf %1 (float (/ %2 n))) items (range 0 (inc n)))))

#+end_src

** patterning
Pattern and distribute are so similar, I wonder if I should remove one of them? As in, have pattern work on either a single item OR a list of items.

#+begin_src clojure :tangle ./src/svg_clj/layout.cljc
(defn pattern-on-pts
  [item pts]
  (el/g (map #(-> item (tf/translate %)) pts)))

(defn pattern-on-curve
  [item curve n]
  (let [step (/ 1.0 n)]
    (map #(-> item (tf/translate (curve %))) (range 0 1.0 step))))

#+end_src

* tools
** ns
#+begin_src clojure :tangle ./src/svg_clj/tools.clj
(ns svg-clj.tools
  (:require [clojure.java.browse]
            [clojure.java.io]
            [hiccup.core :refer [html]]
            [svg-clj.composites :refer [svg]]
            [svg-clj.elements :as el]
            [svg-clj.utils :as utils]))

#+end_src

** save-load
#+begin_src clojure :tangle ./src/svg_clj/tools.clj
(defn save-svg
  [svg-data fname]
  (let [data (if (= (first svg-data) :svg)
               svg-data
               (svg svg-data))]
    (spit fname (html data))))

(defn load-svg
  "Loads the SVG `fname` and parses the XML into a hiccup data structure, keeping all elements.
Use this function to load the SVG without throwing away any nodes, for example, if you want to keep meta and def tags."
  [fname]
  (-> fname
      slurp
      utils/svg-str->hiccup))

(defn load-svg-elems
  "Loads the SVG `fname`, parses the XML into hiccup, and returns a sequence of the SVG elements in the file.
Use this function to pull elements from an SVG that can be used directly with the other functions in this library."
  ([fname] (load-svg-elems fname el/svg-element-keys))
  ([fname key-set]
   (-> fname
       slurp
       utils/svg-str->hiccup
       (utils/get-elems key-set))))

#+end_src

** repl-show
Cider-show depends on CIDER's ability to display inline images. You have to enable this feature though:

~M-x~
~cider-repl-toggle-content-types~

Run that command in a CIDER REPL buffer to enable the feature.

Or, permanently enable the setting by placing this somewhere in your emacs init config:

~(setq cider-repl-content-types t)~

#+begin_src clojure :tangle ./src/svg_clj/tools.clj
(defn cider-show
  [svg-data]
  (let [fname "_tmp.svg"]
    (save-svg svg-data fname)
    (clojure.java.io/file fname)))

(defn show
  [svg-data]
  (let [fname "_tmp.svg.html"]
    (save-svg svg-data fname)
    (clojure.java.io/file fname)))

#+end_src

* tests
Create more tests. Try to use a bit of TDD to help improve implementations, starting with better transform functions.

Run tests with the following.
You can C-c-c on the block in Emacs/org-mode to see the results printed into the document directly. You can also just run the command using the terminal. Run it from the project's root directory.

#+begin_src shell :results drawer
clj -M:test
#+end_src

** utils
*** ns
#+BEGIN_SRC clojure :tangle ./test/svg_clj/utils_test.cljc
(ns svg-clj.utils-test
  (:require [svg-clj.utils :as utils]
            [svg-clj.parametric :as p]
            [svg-clj.transforms :as tf]
            [clojure.test :as test :refer [deftest is]]))

#+END_SRC

*** angle
#+BEGIN_SRC clojure :tangle ./test/svg_clj/utils_test.cljc
(deftest angle-from-pts
  (let [angles (map
                #(utils/angle-from-pts [10 0] [0 0] %)
                (p/regular-polygon-pts 10 20))
        sorted-angles (reverse (sort angles))]
    (is (= (rest (map #(Math/round %) angles)) ;; first angle is 0, rest are in decreasing order
           (drop-last (map #(Math/round %) sorted-angles))))))

(deftest angle-first-quadrant
  (let [eps 0.00001
        a (utils/angle-from-pts [0 10] [0 0] [10 0])]
    (is (< (Math/abs (- 90.0 a)) eps))))
  
#+END_SRC

*** cast-numerical-attrs
#+begin_src clojure :tangle ./test/svg_clj/utils_test.cljc
(deftest cast-numerical-attrs-test
  (let [attrs {:cx "10" :cy "20" :width "200" :height "200px"}
        {:keys [cx cy width height] :as res} (utils/cast-numerical-attrs attrs)]
    (is (= cx 10))
    (is (= cy 20))
    (is (= width 200))
    (is (= height "200px"))))
 
#+end_src

*** svg-str->elems
#+begin_src clojure :tangle ./test/svg_clj/utils_test.cljc
(deftest basic-string-to-elements
  (let [s "<rect width=\"10\" height=\"40\" x=\"50\" y=\"60\" />"
        res (utils/svg-str->elems s)
        [k props] (first res)]
    (is (= 1 (count res)))
    (is (= k :rect))
    (is (= (set (keys props)) #{:width :height :x :y}))))

#+end_src

** elements
*** ns
#+begin_src clojure :tangle ./test/svg_clj/elements_test.cljc
(ns svg-clj.elements-test
  (:require [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.transforms :as tf]
            [clojure.test :refer [deftest is]]))

#+end_src

*** shapes
#+begin_src clojure :tangle ./test/svg_clj/elements_test.cljc
(def test-circle (el/circle 5))
(def test-ellipse (el/ellipse 5 10))
(def test-line (el/line [0 0] [10 20]))
(def test-polygon (el/polygon [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-polyline (el/polyline [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-rect (el/rect 60 30))
(def test-image (el/image "https://www.fillmurray.com/g/200/300" 200 300))
(def test-g (el/g test-circle
                  test-ellipse
                  test-line
                  test-polygon
                  test-polyline
                  test-rect
                  test-image))

(def test-shapes [test-circle
                  test-ellipse
                  test-line
                  test-polygon
                  test-polyline
                  test-rect
                  test-image])

(deftest basic-shapes-test
  (is (= test-circle [:circle {:cx 0 :cy 0 :r 5}]))
  (is (= test-ellipse [:ellipse {:cx 0 :cy 0 :rx 5 :ry 10}]))
  (is (= test-line [:line {:x1 0 :y1 0 :x2 10 :y2 20}]))
  (is (= test-polygon [:polygon {:points "0,0 10,20 40,50 20,10"}]))
  (is (= test-polyline [:polyline {:points "0,0 10,20 40,50 20,10"}]))
  (is (= test-rect [:rect {:x -30.0 :y -15.0 :width 60 :height 30}]))
  (is (= test-image [:image 
                     {:href "https://www.fillmurray.com/g/200/300"
                      :x -100.0 :y -150.0 
                      :width 200 :height 300}])))
#+end_src

*** translate
#+begin_src clojure :tangle ./test/svg_clj/elements_test.cljc
(deftest basic-translate-test
  (is (= (-> test-circle (tf/translate [10 10]))
         [:circle {:r 5 :cx 10 :cy 10 :transform "rotate(0 10 10)"}]))
  (is (= (-> test-ellipse (tf/translate [10 10]))
         [:ellipse {:rx 5 :ry 10 :cx 10 :cy 10 :transform "rotate(0 10 10)"}]))
  (is (= (-> test-line (tf/translate [10 10]))
         [:line {:x1 10 :y1 10 :x2 20 :y2 30}]))
  (is (= (-> test-polygon (tf/translate [10 10]))
         [:polygon {:points "10,10 20,30 50,60 30,20"}]))
  (is (= (-> test-polyline (tf/translate [10 10]))
         [:polyline {:points "10,10 20,30 50,60 30,20"}]))
  (is (= (-> test-rect (tf/translate [10 10]))
         [:rect {:x -20.0 :y -5.0 :width 60 :height 30 :transform "rotate(0 10.0 10.0)"}]))
  (is (= (-> test-image (tf/translate [10 10]))
         [:image {:href "https://www.fillmurray.com/g/200/300"
                  :x -90.0 :y -140.0
                  :width 200 :height 300
                  :transform "rotate(0 10.0 10.0)"}])))

(deftest translate-group-test
  (is (= (drop 2 (tf/translate test-g [5 10]))
         (map #(tf/translate % [5 10]) (drop 2 test-g)))))

(deftest translate-list-test
  (let [a (repeat 10 (el/rect 10 20))]
    (is (= (tf/translate a [5 10])
           (map #(tf/translate % [5 10]) a)))))
#+end_src

*** rotate
#+begin_src clojure :tangle ./test/svg_clj/elements_test.cljc
(deftest basic-rotate-test
  (is (= (-> test-circle (tf/rotate 45))
         [:circle {:r 5 :cx 0 :cy 0 :transform "rotate(45 0 0)"}]))
  (is (= (-> test-ellipse (tf/rotate 45))
         [:ellipse {:rx 5 :ry 10 :cx 0 :cy 0 :transform "rotate(45 0 0)"}]))
  (is (= (-> test-line (tf/rotate 90))
         [:line {:x1 15.0 :y1 4.999999999999999 :x2 -5.0 :y2 15.0}]))
  (is (= (-> test-polygon (tf/rotate 90))
         [:polygon {:points "37.5,2.5 17.5,12.5 -12.5,42.5 27.5,22.5"}]))
  (is (= (-> test-polyline (tf/rotate 90))
         [:polyline {:points "37.5,2.5 17.5,12.5 -12.5,42.5 27.5,22.5"}]))
  (is (= (-> test-rect (tf/rotate 45))
         [:rect {:x -30.0 :y -15.0 :width 60 :height 30 :transform "rotate(45 0.0 0.0)"}]))
  (is (= (-> test-image (tf/rotate 45))
         [:image {:href "https://www.fillmurray.com/g/200/300"
                  :x -100.0 :y -150.0
                  :width 200 :height 300
                  :transform "rotate(45 0.0 0.0)"}])))

(def rotated-test-g-data-structure
  [:g
   {}
   [:circle {:cx 0.0 :cy 0.0 :r 5 :transform "rotate(90 0.0 0.0)"}]
   [:ellipse {:cx 0.0 :cy 0.0 :rx 5 :ry 10 :transform "rotate(90 0.0 0.0)"}]
   [:line {:x1 0.0 :y1 0.0 :x2 -20.0 :y2 10.000000000000002}]
   [:polygon {:points "0.0,0.0 -20.0,10.0 -50.0,40.0 -10.0,20.0"}]
   [:polyline {:points "0.0,0.0 -20.0,10.0 -50.0,40.0 -10.0,20.0"}]
   [:rect
    {:width 60 :height 30 :x -30.0 :y -15.0 :transform "rotate(90 0.0 0.0)"}]
   [:image
    {:href "https://www.fillmurray.com/g/200/300"
     :width 200
     :height 300
     :x -100.0
     :y -150.0
     :transform "rotate(90 0.0 0.0)"}]])

(deftest rotate-group-test
  (is (not= (drop 2 (tf/rotate test-g 45))
            (map #(tf/rotate % 45) (drop 2 test-g))))
  (is (= (tf/rotate test-g 90)
         rotated-test-g-data-structure)))

(deftest rotate-list-test
  (let [a (repeat 10 (el/rect 10 20))]
    (is (= (tf/rotate a 45)
           (map #(tf/rotate % 45) a)))))

#+end_src
** path
*** ns
#+BEGIN_SRC clojure :tangle ./test/svg_clj/path_test.cljc
(ns svg-clj.path-test
  (:require 
   [svg-clj.elements :as el]
   [svg-clj.path :as path]
   [svg-clj.transforms :as tf]
   [clojure.test :as test :refer [deftest is]]))

#+END_SRC

*** shapes
#+begin_src clojure :tangle ./test/svg_clj/path_test.cljc
(def test-circle (path/circle 5))
(def test-ellipse (path/ellipse 5 10))
(def test-line (path/line [0 0] [10 20]))
(def test-polygon (path/polygon [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-polyline (path/polyline [ [0 0] [10 20] [40 50] [20 10] ]))
(def test-rect (path/rect 60 30))
(def test-g (el/g test-circle
                  test-ellipse
                  test-line
                  test-polygon
                  test-polyline
                  test-rect))

(def test-shapes [test-circle
                  test-ellipse
                  test-line
                  test-polygon
                  test-polyline
                  test-rect])

(deftest basic-shapes-test
  (is (= test-circle [:path {:d "M5 0 A5 5 0 1 0 0 5 A5 5 0 1 0 -5 0 A5 5 0 1 0 0 -5 A5 5 0 1 0 5 0 Z", :fill-rule "evenodd"}]))
  (is (= test-ellipse [:path {:d "M5 0 A5 10 0 1 0 0 10 A5 10 0 1 0 -5 0 A5 10 0 1 0 0 -10 A5 10 0 1 0 5 0 Z", :fill-rule "evenodd"}]))
  (is (= test-line [:path {:d "M0 0 L10 20", :fill-rule "evenodd"}]))
  (is (= test-polygon [:path {:d "M0 0 L10 20 L40 50 L20 10 Z", :fill-rule "evenodd"}]))
  (is (= test-polyline [:path {:d "M0 0 L10 20 L40 50 L20 10", :fill-rule "evenodd"}]))
  (is (= test-rect [:path {:d "M-30.0 -15.0 L30.0 -15.0 L30.0 15.0 L-30.0 15.0 Z", :fill-rule "evenodd"}])))

#+end_src

*** rel->abs
#+begin_src clojure :tangle ./test/svg_clj/path_test.cljc
(def a-str "M453 83l15 -9q-13 -81 -96 -81q-34 0 -51 22.5t-20 53.5q-20 -23 -30.5 -33t-39.5 -27.5t-58 -17.5q-50 0 -86 28t-36 89q0 27 11.5 47t32 32.5t41.5 20.5t49 11.5t46.5 4.5t41 1.5t24.5 0.5q3 0 3 74q0 95 -87 95q-30 0 -48 -13t-22 -31q29 0 29 -44q0 -27 -18 -38.5\nt-35 -11.5q-19 0 -34 17.5t-15 38.5q0 37 47 72q38 29 105 29q63 0 112 -39t49 -106q0 -33 -2 -92t-2 -85q0 -67 31 -66q18 0 27 13t16 44zM297 94v118q-35 -3 -64.5 -6.5t-50.5 -11t-33 -25.5t-12 -50q0 -43 21.5 -63t54.5 -20q52 0 84 58z")

(def a-cmds (path/path-str->cmds a-str))

(deftest basic-cmds-test
  (is (= #{:abs} (set (map :coordsys a-cmds))))
  (is (nil? (#{"V" "H" "S" "T"} (set (map :command a-cmds))))))

#+end_src

*** translate
#+begin_src clojure :tangle ./test/svg_clj/path_test.cljc
(deftest basic-translate-test
  (is (= (-> test-circle (tf/translate [10 10]))
         [:path {:d "M15 10 A5 5 0 1 0 10 15 A5 5 0 1 0 5 10 A5 5 0 1 0 10 5 A5 5 0 1 0 15 10 Z", :fill-rule "evenodd"}]))
  (is (= (-> test-ellipse (tf/translate [10 10]))
         [:path {:d "M15 10 A5 10 0 1 0 10 20 A5 10 0 1 0 5 10 A5 10 0 1 0 10 0 A5 10 0 1 0 15 10 Z", :fill-rule "evenodd"}]))
  (is (= (-> test-line (tf/translate [10 10]))
         [:path {:d "M10 10 L20 30", :fill-rule "evenodd"}]))
  (is (= (-> test-polygon (tf/translate [10 10]))
         [:path {:d "M10 10 L20 30 L50 60 L30 20 Z", :fill-rule "evenodd"}]))
  (is (= (-> test-polyline (tf/translate [10 10]))
         [:path {:d "M10 10 L20 30 L50 60 L30 20", :fill-rule "evenodd"}]))
  (is (= (-> test-rect (tf/translate [10 10]))
         [:path {:d "M-20.0 -5.0 L40.0 -5.0 L40.0 25.0 L-20.0 25.0 Z", :fill-rule "evenodd"}])))

(deftest translate-group-test
  (is (= (drop 2 (tf/translate test-g [5 10]))
         (map #(tf/translate % [5 10]) (drop 2 test-g)))))

(deftest translate-list-test
  (let [a (repeat 10 (el/rect 10 20))]
    (is (= (tf/translate a [5 10])
           (map #(tf/translate % [5 10]) a)))))
#+end_src

*** rotate
These basic tests are brittle, as I manually copied path strings from the REPL. This is kinda risky, especially considering floating point comparisons. I need a better strategy. I think soon I should incorporate some property based testing, and use Spec or Malli to help.

#+begin_src clojure :tangle ./test/svg_clj/path_test.cljc
(deftest basic-rotate-test
  (is (= (-> test-circle (tf/rotate 45))
         [:path {:d "M3.5355339059327378 3.5355339059327373 A5 5 45 1 0 -3.5355339059327373 3.5355339059327378 A5 5 45 1 0 -3.5355339059327378 -3.5355339059327373 A5 5 45 1 0 3.5355339059327373 -3.5355339059327378 A5 5 45 1 0 3.5355339059327378 3.5355339059327373 Z" :fill-rule "evenodd"}]))
  (is (= (-> test-ellipse (tf/rotate 45))
         [:path {:d "M3.5355339059327378 3.5355339059327373 A5 10 45 1 0 -7.071067811865475 7.0710678118654755 A5 10 45 1 0 -3.5355339059327378 -3.5355339059327373 A5 10 45 1 0 7.071067811865475 -7.0710678118654755 A5 10 45 1 0 3.5355339059327378 3.5355339059327373 Z" :fill-rule "evenodd"}]))
  (is (= (-> test-line (tf/rotate 90))
         [:path {:d "M15.0 4.999999999999999 L-5.0 15.0", :fill-rule "evenodd"}]))
  (is (= (-> test-polygon (tf/rotate 90))
         [:path {:d "M37.5 2.5 L17.5 12.5 L-12.5 42.5 L27.5 22.5 Z", :fill-rule "evenodd"}]))
  (is (= (-> test-polyline (tf/rotate 90))
         [:path {:d "M37.5 2.5 L17.5 12.5 L-12.5 42.5 L27.5 22.5", :fill-rule "evenodd"}]))
  (is (= (-> test-rect (tf/rotate 45))
         [:path {:d "M-10.606601717798215 -31.819805153394636 L31.81980515339464 10.60660171779821 L10.606601717798215 31.819805153394636 L-31.81980515339464 -10.60660171779821 Z",
  :fill-rule "evenodd"}])))

(def rotated-test-g-data-structure
  [:g {}
   [:path {:d "M22.5 17.5 A5 5 90 1 0 17.5 12.5 A5 5 90 1 0 22.5 7.5 A5 5 90 1 0 27.5 12.5 A5 5 90 1 0 22.5 17.5 Z", :fill-rule "evenodd"}]
   [:path {:d "M22.5 17.5 A5 10 90 1 0 12.5 12.5 A5 10 90 1 0 22.5 7.5 A5 10 90 1 0 32.5 12.5 A5 10 90 1 0 22.5 17.5 Z", :fill-rule "evenodd"}]
   [:path {:d "M22.5 12.5 L2.5 22.5", :fill-rule "evenodd"}]
   [:path {:d "M22.5 12.5 L2.5000000000000004 22.5 L-27.5 52.5 L12.5 32.5 Z", :fill-rule "evenodd"}]
   [:path {:d "M22.5 12.5 L2.5000000000000004 22.5 L-27.5 52.5 L12.5 32.5", :fill-rule "evenodd"}]
   [:path {:d "M37.5 -17.5 L37.5 42.5 L7.500000000000002 42.5 L7.499999999999998 -17.5 Z", :fill-rule "evenodd"}]])

(deftest rotate-group-test
  (is (not= (drop 2 (tf/rotate test-g 45))
            (map #(tf/rotate % 45) (drop 2 test-g))))
  (is (= (tf/rotate test-g 90)
         rotated-test-g-data-structure)))

(deftest rotate-list-test
  (let [a (repeat 10 (el/rect 10 20))]
    (is (= (tf/rotate a 45)
           (map #(tf/rotate % 45) a)))))

#+end_src

** tools
*** ns
#+BEGIN_SRC clojure :tangle ./test/svg_clj/tools_test.cljc
(ns svg-clj.tools-test
  (:require [clojure.string :as str]
            [svg-clj.utils :as utils]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.elements :as el]
            [svg-clj.composites :refer [svg]]
            [svg-clj.tools :as tools]
            [clojure.test :as test :refer [deftest is]]))

#+END_SRC

*** loading
#+BEGIN_SRC clojure :tangle ./test/svg_clj/tools_test.cljc
(def loaded-sk (tools/load-svg "examples/load-svg-test.svg"))
(def sk-elems (tools/load-svg-elems "examples/load-svg-test.svg"))
(def circle-elems (tools/load-svg-elems "examples/load-svg-test.svg" #{:circle}))

(deftest basic-loading-test
  (is (= :svg (first loaded-sk)))
  (is (= :g (first (first sk-elems))))
  (is (= 10 (count sk-elems)))
  (is (= 2 (count circle-elems)))
  (is (= #{:circle} (set (map first circle-elems)))))

#+END_SRC

* examples
This is a WIP file for a more complex drawing to be used in tests. This will use all transforms, all shapes, etc.

** basics
#+begin_src clojure :tangle ./examples/basics.cljc
(ns examples.basics
  (:require [clojure.string :as str]
            [hiccup.core :refer [html]]
            [svg-clj.utils :as utils]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.elements :as el]
            [svg-clj.composites :refer [svg]]
            [svg-clj.tools :refer [show cider-show]]))

(defn show-debug-geom
  [elem]
  (let [ctr (tf/centroid elem)
        bds (tf/bounds elem)]
    (el/g elem
       (el/g (-> (el/polygon bds)
                 (tf/style {:fill "none"
                            :stroke "red"
                            :stroke-width "1px"
                            :opacity 0.3}))
          (-> (el/circle 2)
               (tf/translate ctr)
               (tf/style {:fill "red"
                          :opacity 0.3}))))))

(def basic-group
  (el/g
   (el/rect 20 20)
   (-> (el/rect 20 20) (tf/translate [20 0]))
   (-> (el/rect 20 20) (tf/translate [0 20]))
   (-> (el/rect 20 20) (tf/translate [20 20]))))

(def circles
  (-> (for [a (range 0 12)]
        (-> (el/circle (+ 5 (* a 4)))
            (tf/translate [(/ (+ 5 (* a 4)) 2) 0])
            (tf/translate (utils/rotate-pt [20 0] (* a -40)))
            (tf/style {:stroke 
                       (str "rgba(163,190,140," 
                            (/ (inc a) 10.0) ")")
                       :stroke-width "2px"
                       :fill "none"})))
      el/g
      (tf/translate [100 100])))

(def basics [(path/arc [0 0] [50 0] 90)
             (path/circle 40)
             (path/bezier [0 0] [30 20] [80 40] [120 180])
             (el/circle 80)
             (path/rect 70 120)
             (path/ellipse 40 80)
             (el/line [0 0] [100 100])
             (path/line [0 0] [100 100])
             (el/polygon [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (el/polyline [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (path/polygon [ [0 0] [30 0] [30 20] [15 10] [0 20] ])
             (el/text "this is text")
             (el/image "https://www.fillmurray.com/300/200" 100 67)
             (tf/merge-paths (path/rect 100 100) (path/rect 80 80))
             basic-group
             circles])

(def doc
  (->>
   (for [elem basics]
     (-> elem
         (tf/translate [80 80])
         (tf/rotate 20)
         (tf/style {:fill "pink"
                 :stroke-width "2px"
                 :stroke "hotpink"})
         show-debug-geom
         svg
         (tf/style {:style {:outline "1px solid blue"
                         :margin "10px"}})))
   (partition-all 3)
   (interpose [:br])))

(spit 
 "examples/basics.html"
 (html 
  [:html 
   [:body
    [:h1 "Basic Geometry Examples"]
    doc]]))

#+end_src

** layout
#+begin_src clojure :tangle ./examples/layout.cljc
(ns examples.layout
  (:require [clojure.string :as str]
            [clojure.java.shell :refer [sh]]
            [hiccup.core :refer [html]]
            [svg-clj.composites :as cp :refer [svg]]
            [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.layout :as lo]
            [svg-clj.parametric :as p]
            #?(:clj [svg-clj.tools :as tools])))

(defn show-debug-geom
  [elem]
  (let [ctr (tf/centroid elem)
        bds (tf/bounds elem)]
    (el/g elem
       (el/g (-> (el/polygon bds)
               (tf/style {:fill "none"
                       :stroke "red"
                       :stroke-width "3px"}))
          (-> (el/circle 2)
               (tf/translate ctr)
               (tf/style {:fill "red"}))))))

(defn rand-rect
  []
  (let [w (+ 5 (rand-int 20)) 
        h (+ 5 (rand-int 20))
        origin [0 (/ h 2)]]
    (-> (el/rect w h)
        (tf/translate origin)
        (tf/style {:fill (str "rgb("
                              (rand-int 255) ","
                              (rand-int 255) ","
                              (rand-int 255) ")")}))))

;; Distribute a list of elements along X/Y axis, keeping a constant gap between the boundaries of each element.

(def horizontal-dist
  (el/g
   (map show-debug-geom
        (drop 2 (lo/distribute-linear :x 10 (repeatedly 7 rand-rect))))))

(def vertical-dist
  (el/g
   (map show-debug-geom
        (drop 2 (lo/distribute-linear :y 10 (repeatedly 7 rand-rect))))))

;; Distribute a list of elements onto a list of points.
;; Works like map, so whichever runs out first (elements or points) is the limiter.

(def grid-dist
 (lo/distribute-on-pts 
  (repeatedly rand-rect)
  (p/rect-grid 10 10 30 30)))

(def grid-dist2
 (lo/distribute-on-pts
  (repeat (el/circle 1.5))
  (p/rect-grid 20 30 10 10)))

;; Distribute a list of elements onto a parametric curve.
(def redline
  (-> (el/line [0 0] [0 15])
      (tf/style {:stroke "red" :stroke-width "3px"})))

(def circle-curve-dist
 (el/g
  (el/circle 150)
  (lo/distribute-on-curve
   (repeat 80 redline)
   (p/circle 150))))

(def circle-curve-dist2
 (el/g
  (el/circle 150)
  (lo/distribute-on-curve
   (repeatedly 40 rand-rect)
   (p/circle 150))))

;; Distribute on any curve available in parametric.cljc
(def bez-curve (p/bezier [ [70 -20] [10 70] [200 -300] [300 0]]))

(def bezier-curve-dist 
 (lo/distribute-on-curve
  (repeatedly 20 rand-rect)
  bez-curve))

(def examples [horizontal-dist
               vertical-dist
               grid-dist
               grid-dist2
               circle-curve-dist
               circle-curve-dist2
               bezier-curve-dist])

(def doc
  (->>
   (for [elem examples]
     (-> elem
         svg
         (tf/style {:style {:outline "1px solid blue"
                         :margin "10px"}})))
   (partition-all 3)
   (interpose [:br])))

(spit 
 "examples/layout.html"
 (html 
  [:html 
   [:body
    [:h1 "Layout Examples"]
    doc]]))

#+end_src

** bezier
#+begin_src clojure :tangle ./examples/bezier.cljc
(ns examples.bezier
  (:require [clojure.string :as str]
            [hiccup.core :refer [html]]
            [svg-clj.composites :as cp :refer [svg]]
            [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.layout :as lo]
            [svg-clj.parametric :as p]
            #?(:clj [svg-clj.tools :as tools])))

(def pts [ [0 0] [100 -300] [200 -300] [300 0]])
#_(def pts [ [110 150] [25 190] [210 250] [210 30]])

(def ts [0.2 0.4 0.6 0.8])
(def curve (p/bezier pts))
(def curve2 (p/rational-bezier pts [1 2.5 0.5 1]))

(def cols ["blue" "cyan" "purple" "pink" "blue" "skyblue" "slategray" "gold" "orange" "red"]) 

;; runs slow due to arc-length calc
#_(def curves
  (let [cpts (p/uniform-split-bezier curve 6) #_(p/multi-split-bezier curve ts)]
    (map-indexed #(el/g 
                   (-> (apply path/bezier %2)
                       (tf/style {:fill "none"
                                  :stroke-width "3px"
                                  :stroke (get cols %1)}))
                   (-> (el/circle 5)
                       (tf/translate (last %2))
                       (tf/style {:fill "red"})))
                   cpts)))

#_(def split-curve (p/uniform-split-bezier curve 4))

(def a (-> (apply path/bezier pts)
           (tf/style {:fill "none"
                      :stroke-width "6px"
                      :stroke "pink"})))

(def aa (-> (p/split-bezier curve 0.2)
            :a
            (#(apply path/bezier %))
            (tf/style {:fill "none"
                       :stroke-width "3px"
                       :stroke "blue"})))

(def ab (-> (p/split-bezier curve 0.2)
            :b
            (#(apply path/bezier %))
            (tf/style {:fill "none"
                       :stroke-width "3px"
                       :stroke "green"})))

(def b
  (let [cpts (map curve2 (range 0 1.01 0.01))]
    (el/g
     (map #(-> (el/circle 3)
               (tf/translate %)
               (tf/style {:fill "red"}))
          cpts))))

(def c (el/g a aa ab b))

(def examples [a
               aa
               ab
               b
               c])

(def doc
  (->>
   (for [elem examples]
     (-> elem
         svg
         (tf/style {:style {:outline "1px solid blue"
                            :margin "10px"}})))
   (partition-all 3)
   (interpose [:br])))

(spit 
 "examples/bezier.html"
 (html 
  [:html 
   [:body
    [:h1 "Bezier Curve Examples"]
    doc]]))

#+end_src

** offset
#+begin_src clojure :tangle ./examples/offset.cljc
(ns examples.offset
  (:require [clojure.string :as str]
            [hiccup.core :refer [html]]
            [svg-clj.composites :as cp :refer [svg]]
            [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.parametric :as p]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.layout :as lo]
            #?(:clj [svg-clj.tools :as tools])))

(def a (-> (p/regular-polygon-pts 120 10)
           (el/polygon)
           (tf/style {:fill "none"
                      :stroke "red"
                      :stroke-width "3px"})))

(def b (-> (tf/offset a 20)
           (tf/style {:fill "none"
                      :stroke "limegreen"
                      :stroke-width "3px"})))

(def c (-> (el/circle 40)
           (tf/style {:fill "none"
                      :stroke "red"
                      :stroke-width "3px"})))

(def d (-> (tf/offset c -3)
           (tf/style {:fill "none"
                      :stroke "limegreen"
                      :stroke-width "3px"})))

(def pts [ [0 0] [100 -300] [200 -300] [300 0]])
(def curve (p/bezier pts))

(def e (-> (map curve (range 0 1.05 0.05))
           (el/polyline)
           (tf/style {:fill "none"
                      :stroke "red"
                      :stroke-width "3px"})))

(def f (-> (map curve (range 0 1.05 0.05))
           (tf/offset-pts 20)
           (el/polyline)
           (tf/style {:fill "none"
                      :stroke "limegreen"
                      :stroke-width "3px"})))

(def examples [a
               b
               c
               d
               (el/g a b)
               (el/g c d)
               e
               f
               (el/g e f)])

(def doc
  (->>
   (for [elem examples]
     (-> elem
         svg
         (tf/style {:style {:outline "1px solid blue"
                            :margin "10px"}})))
   (partition-all 3)
   (interpose [:br])))

(spit 
 "examples/offset.html"
 (html 
  [:html 
   [:body
    [:h1 "Offset Examples"]
    doc]]))
#+end_src

** algorithms
#+begin_src clojure :tangle ./examples/offset.cljc
(ns examples.algorithms
  (:require [clojure.string :as str]
            [hiccup.core :refer [html]]
            [svg-clj.composites :as cp :refer [svg]]
            [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.parametric :as p]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.layout :as lo]
            [svg-clj.algorithms :as alg]
            #?(:clj [svg-clj.tools :as tools])))

(defn inside-pt-example
  []
  (let [deg (rand-int 361)
        tri (->> (p/regular-polygon-pts 100 3)
                 (map #(utils/rotate-pt % deg)))
        rand-pt (fn [] [(- 100 (rand-int 200))
                        (- 100 (rand-int 200))])
        pts (repeatedly 1400 rand-pt)]
    (el/g
     (-> (el/polygon tri)
         (tf/style {:fill "none" :stroke "black"}))
     (into [:g {}]
           (for [pt pts]
             (if (utils/pt-inside? tri pt)
               (-> (el/circle 2)
                   (tf/translate pt)
                   (tf/style {:fill "green"}))
               (-> (el/circle 2)
                   (tf/translate pt)
                   (tf/style {:fill "red"}))))))))

(def remove-colinears-example
  (let [pts (-> (p/regular-polygon-pts 100 4)
                (p/simplify 160))
        xpts (p/remove-colinears pts)]
    (el/g
     (into [:g {}]
           (for [pt pts]
             (-> (el/circle 1.5)
                 (tf/translate pt)
                 (tf/style {:fill "black"}))))
     (into [:g {}]
           (for [pt xpts]
             (-> (el/circle 2.5)
                 (tf/translate pt)
                 (tf/style {:fill "green"})))))))

(defn draw-triangulation
  [{:keys [tris]}]
  (into [:g {}]
        (for [tri tris]
          (-> (el/polygon tri)
              (tf/style {:fill "none" :stroke "black"})))))

(def concave
  (let [f (p/blend (p/circle 100)
                   (p/polygon (p/regular-polygon-pts 100 6)) 2)]
    (map f (range 0 1 0.01))))

(def ear-clip-example
  (draw-triangulation (alg/clip-ears concave)))

(def examples [(inside-pt-example)
               (inside-pt-example)
               remove-colinears-example
               ear-clip-example])

(def doc
  (->>
   (for [elem examples]
     (-> elem
         svg
         (tf/style {:style {:outline "1px solid blue"
                            :margin "10px"}})))
   (partition-all 3)
   (interpose [:br])))

(spit 
 "examples/algorithms.html"
 (html 
  [:html 
   [:body
    [:h1 "Algorithms Examples"]
    doc]]))

#+end_src

** blossom
#+begin_src clojure :tangle ./examples/blossom.cljc
(ns examples.blossom
  (:require [svg-clj.utils :as utils]
            [svg-clj.elements :as el]
            [svg-clj.transforms :as tf]
            [svg-clj.composites :as comp :refer [svg]]
            [svg-clj.path :as path]
            [svg-clj.parametric :as p]
            [svg-clj.layout :as lo]
            [svg-clj.tools :as tools]
            #?(:clj [svg-clj.tools :as tools])))
            
(defn flip-y
  [pts]
  (mapv #(utils/v* % [1 -1]) pts))

(defn petal
  [cpts]
  (let [beza (apply path/bezier cpts)
        bezb (apply path/bezier (flip-y cpts))
        shape (tf/merge-paths beza bezb)
        ctr (tf/centroid shape)]
    (-> shape
        (tf/rotate -90)
        (tf/translate (utils/v* ctr [-1 -1])))))

(defn petal-ring
  [petal r n]
  (el/g
   (lo/distribute-on-curve
    (repeat n petal)
    (p/circle r))))

(def petal-01
  (-> (petal [[0 0] [5 -50] [50 -20] [75 0]])
      (tf/style {:fill "#ff8b94"
                 :stroke "#ffaaa5"
                 :stroke-width "4px"
                 :stroke-linecap "round"})))

(def petal-02
  (-> (petal [[0 0] [1 -20] [20 -10] [40 0]])
      (tf/style {:fill "#ffaaa5"
                 :stroke "none"})))

(def petal-03
  (-> (tf/merge-paths petal-01 petal-02)
      (tf/style {:fill "#a8e6cf"})))

(def petal-ring-01 (petal-ring petal-01 120 12))
(def petal-ring-02 (petal-ring petal-02 120 12))

(def petal-ring-03
  (-> (petal-ring petal-03 70 6)
      (tf/rotate (/ 360.0 24))))

(def petal-ring-04
  (let [petal (-> petal-03 (tf/style {:fill "#cc5963"}))]
    (-> (petal-ring petal 90 6)
        (tf/rotate (/ 360.0 24))
        (tf/rotate (/ 360.0 12)))))

(def petal-ring-05
  (let [petal (-> petal-02
                  (tf/rotate 180)
                  (tf/style {:fill "none"
                             :stroke "#f4f1d7"
                             :stroke-width "2px"}))]
    (-> (petal-ring petal 70 36)
        (tf/rotate (/ 360.0 24)))))

(def petal-ring-06
  (let [petal (-> petal-02
                  (tf/style {:fill "none"
                             :stroke "#f4f1d7"
                             :stroke-width "2px"}))]
    (-> (petal-ring petal 40 20)
        (tf/rotate (/ 360.0 24)))))

(def blossom (el/g
              (-> (el/circle 105) (tf/style {:fill "#69b599"}))
              petal-ring-01
              petal-ring-02
              petal-ring-06
              petal-ring-05
              petal-ring-04
              petal-ring-03))

;; when in a Clojure context, you can compile to SVG files
;; this uses the Hiccup html compiler
;; emitted SVG data works with Reagent as well.

(tools/save-svg blossom "examples/blossom.svg")
#+end_src

* scratch
Play around with code here.

#+begin_src clojure
(ns svg-clj.scratch
  (:require [clojure.string :as str]
            [hiccup.core :refer [html]]
            [svg-clj.utils :as utils]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]
            [svg-clj.elements :as el]
            [svg-clj.composites :refer [svg]]
            [svg-clj.parametric :as p]
            [svg-clj.layout :as lo]
            [svg-clj.algorithms :as alg]
            [svg-clj.tools :as tools :refer [show cider-show]]))

(def sk (slurp "/Users/adam/dev/forge/sk.svg"))
(def sk-elems (utils/svg-str->elems sk))
(tools/cider-show sk-elems)

;; manual test of scaling groups
(let [p (-> (p/regular-polygon-pts 100 5) path/polygon (tf/translate [150 150]))]
  (tools/cider-show
   (->
    (el/g
     (-> (el/circle 3) (tf/translate [150 150]))
     (-> p (tf/style {:stroke "green" :fill "none"}))
     (-> p (tf/scale [1.5 1.5]) (tf/style {:stroke "blue" :fill "none"})))
    (tf/scale [1 1])
    (svg 300 300))))

(defn show-parametric
  [f]
  (let [eps 0.00005
        closed? (< (utils/distance (f 0) (f 1)) eps)
        pts (map f (range 0 1 0.01))
        draw-fn (if closed? el/polygon el/polyline)]
    (-> (draw-fn pts)
        (tf/style {:fill "none"
                   :stroke "limegreen"
                   :stroke-width 3})
        tools/cider-show)))
        

(def a (p/bezier [[0 0] [10 20] [40 90] [120 230]]))

#+end_src
